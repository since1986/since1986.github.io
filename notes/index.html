<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


















  
  
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">







<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.2',
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="前言这里记录一些笔记 正文#1 等待通知机制123456789101112131415161718192021222324252627282930313233343536373839// JVM 实现public class Test2 &amp;#123;    private static final Object LOCK = new Object(); // 注意当作锁的对象一定要是final的，">
<meta property="og:type" content="website">
<meta property="og:title" content="notes">
<meta property="og:url" content="https://since1986.github.io/notes/index.html">
<meta property="og:site_name" content="Since1986">
<meta property="og:description" content="前言这里记录一些笔记 正文#1 等待通知机制123456789101112131415161718192021222324252627282930313233343536373839// JVM 实现public class Test2 &amp;#123;    private static final Object LOCK = new Object(); // 注意当作锁的对象一定要是final的，">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://since1986.github.io/notes/index/1-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/2-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/2-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/7-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/9-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/10-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/11-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/12-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/18-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/18-2.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/18-3.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/18-4.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/20-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/28-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/29-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/39-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/41-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/47-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/47-2.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/49-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/61-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/69-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/79-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/89-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/91-1.gif">
<meta property="og:image" content="https://since1986.github.io/notes/index/91-2.gif">
<meta property="og:image" content="https://since1986.github.io/notes/index/91-3.gif">
<meta property="og:image" content="https://since1986.github.io/notes/index/98-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/98-2.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/124-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/124-2.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/125-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/125-2.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/125-3.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/135-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/138-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/138-2.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/144-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/146-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/146-2.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/154-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/154-2.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/155-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/157-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/157-2.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/160-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/161-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/162-1.png">
<meta property="og:updated_time" content="2019-11-16T06:33:24.082Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="notes">
<meta name="twitter:description" content="前言这里记录一些笔记 正文#1 等待通知机制123456789101112131415161718192021222324252627282930313233343536373839// JVM 实现public class Test2 &amp;#123;    private static final Object LOCK = new Object(); // 注意当作锁的对象一定要是final的，">
<meta name="twitter:image" content="https://since1986.github.io/notes/index/1-1.png">





  
  
  <link rel="canonical" href="https://since1986.github.io/notes/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>notes | Since1986</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Since1986</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-notes menu-item-active">

    
    
    
      
    

    

    <a href="/notes/" rel="section"><i class="menu-item-icon fa fa-fw fa-sticky-note-o"></i> <br>notes</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  

  

  <a href="https://github.com/since1986" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

    
    
      
      
    
      
      
    
      
      
    
      
      
    
      
      
    
    

  


          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">notes

</h1>

<div class="post-meta">
  
  



</div>

</header>

      
      
      
      <div class="post-body">
        
        
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里记录一些笔记</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-等待通知机制"><a href="#1-等待通知机制" class="headerlink" title="#1 等待通知机制"></a>#1 等待通知机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JVM 实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object(); <span class="comment">// 注意当作锁的对象一定要是final的，加入不是final的，一个线程用此对象加锁后，这个对象变了，另一个线程再用这个对象加锁就已经是另一把锁了，那么锁就失去语义了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread0 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"即将等待"</span>);</span><br><span class="line">                        LOCK.wait(); <span class="comment">// 释放锁并进入等待</span></span><br><span class="line">                        System.out.println(<span class="string">"等待结束"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK) &#123; <span class="comment">// 注意 synchronized 块，进入代表 lock 也就是 monitorenter</span></span><br><span class="line">                    LOCK.notifyAll(); <span class="comment">// 通知等待的其他人</span></span><br><span class="line">                &#125; <span class="comment">// 注意 synchronized 块，退出代表 unlock 也就是 monitorexit，退出了才释放锁，只有这里释放锁，上边等着的人才能获得锁，这不放，上边永远都进不到 synchronized 块里</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意顺序，等待的先启动，发通知的后启动，要发通知的先启动了，通知空放，等待的空等</span></span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        thread0.join();</span><br><span class="line">        thread1.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// JDK 实现</span><br><span class="line"></span><br><span class="line">public class Test5 &#123;</span><br><span class="line"></span><br><span class="line">    private static Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    private static Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread0 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock(); // 先获得锁</span><br><span class="line">                    condition.await(); // 进入阻塞等待</span><br><span class="line">                    System.out.println(&quot;已被唤醒&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock(); // 释放锁</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock(); // 先获得锁</span><br><span class="line">                    System.out.println(&quot;通知正在阻塞等待的其他人&quot;);</span><br><span class="line">                    condition.signalAll(); // 通知正在阻塞等待的其他人</span><br><span class="line">                    System.out.println(&quot;先不释放锁，停2秒再释放&quot;);</span><br><span class="line">                    Thread.sleep(2000L);</span><br><span class="line">                    System.out.println(&quot;停2秒已到时间了&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock(); // 释放锁</span><br><span class="line">                    System.out.println(&quot;锁已经释放了&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>synchronized</code> + <code>Object#wait()</code> 内在的逻辑可以以一个通俗易懂的场景解释，想象一下这个场景：一个只有一个坑位的厕所，一次只能有一个人使用（<code>synchronized (LOCK)</code> ，获得锁的线程可以运行，未获得锁的线程，不能运行），这个人（某个线程）进去关上门插上门闩（也就是获得了锁）该干嘛干嘛，其他人需要在外面排队等待（也就是形成一个名为<code>同步队列</code>的队列），排队的规则是后来的人插入到队尾，然后里面的人解决完了，会打开门闩开开门（释放锁，也就是线程执行已经出了<code>synchronized</code>块）然后告诉队列排在最前面的那一个人（<code>同步队列</code> 头节点），让他进去；而对于 <code>LOCK.wait()</code> 和 <code>LOCK.notifyAll()</code> ,里面涉及到 <code>等待队列</code> 的概念，<code>等待队列</code>的理解可以想象这个场景：还是刚才那个厕所排队，除了厕所里边正在工作的（获得锁的线程），以及门口等待进去的（同步队列中的线程），还有一批（或者多批）人（也就是执行了<code>LOCK.wait()</code>的线程）排成一队打盹，这些人是由原来在坑位门里的人（已经获得了锁的线程）因为某些原因，自己放弃了此次的“工作”，主动形成另一个队伍（<code>等待队列</code>）打盹，这些人不参与排队等着进门（也就是排队获得锁），只有被当前在坑位门里的人（已经获得锁的线程）唤醒时，他们才会重新排到等待进坑位门的队列里（也就是已获得锁的线程执行了 <code>notifyAll()</code> ，就会让<code>等待队列</code>里的线程从<code>等待队列</code>移到<code>同步队列</code>）</p>
<p><code>Lock</code> + <code>Condition</code> 实现等待通知机制，实际上和<code>synchronized</code> + <code>Object#wait()</code> 在逻辑上差不太多，都是有两个队列：<code>synchronized</code> + <code>Object#wait()</code>是<code>同步队列</code>(入口集)和<code>等待队列</code>(等待集)，而<code>Lock</code> + <code>Condition</code>则是AQS内部的等待队列和<code>Condition</code>自己的等待队列，套路还是一个，只是实现的层面不同了，<code>synchronized</code> + <code>Object#wait()</code>是JVM层面实现的，<code>Lock</code> + <code>Condition</code>是JDK库层面实现的</p>
<p>另外等待通知有个比较特殊的例子就是<code>Thread</code>的<code>join()</code>，<code>join()</code>内部仍是<code>wait</code>和<code>notify</code>，但是锁对象变成了<code>Thread</code>对象实例，当在上边的代码中执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        thread0.join();</span><br><span class="line">        thread1.join();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>时，可以不严谨的理解为实际上执行者也就是<code>main</code>线程隐式调用了<code>thread0.wait()</code> 和 <code>thread1.wait()</code> 这时<code>main</code>线程就等待了，然后在<code>thread0</code>线程执行结束后，会隐式调用<code>thread0.notifyAll()</code>，在<code>thread1</code>线程执行结束后，会隐式调用<code>thread1.notifyAll()</code>，这样在等待的<code>main</code>线程就被唤醒了。</p>
<p>一张及不严谨的图，大概描述个意思：</p>
<p><img src="/notes/index/1-1.png" alt="图1-1"></p>
<h3 id="2-多态、虚方法表"><a href="#2-多态、虚方法表" class="headerlink" title="#2 多态、虚方法表"></a>#2 多态、虚方法表</h3><p>刚刚看书发现了一个有意思的点，在Java里多态背后的实现是：调用方法的实例在本身存储了自身的类型信息的引用，通过在类型信息引用中查找想要调用方法如果找不到则会去找父类信息，看看那里面有没有定义想要调用的方法，这个过程会一直持续到找不到父类为止，如果父类链路比较深的话则开销会很大，Java的做法是用“虚方法表”这个虚方法表其实就是把一个子类能拥有的所有方法的定义信息（包括从父类继承的）全都事先拽过来存储到自己的类信息里，这样再查找就不要去父类找了（等于用冗余的手段把层次结构扁平花了），我感觉这个和咱们平常业务量做表的冗余字段加速查询是一个套路，套路还是那个套路，只是用的地方不一样了。</p>
<p><img src="/notes/index/2-1.jpg" alt="图2-1"></p>
<p><img src="/notes/index/2-1.jpg" alt="图2-2"></p>
<h3 id="3-类初始化锁"><a href="#3-类初始化锁" class="headerlink" title="#3 类初始化锁"></a>#3 类初始化锁</h3><blockquote>
<p>当多个线程需要初始化一个类,仅有一个线程会进⾏,其他线程需要等待。当活动的线程完成初始化之后, 它必须通知其他等待线程</p>
</blockquote>
<h3 id="4-记录一次JVM-old过高的排查"><a href="#4-记录一次JVM-old过高的排查" class="headerlink" title="#4 记录一次JVM old过高的排查"></a>#4 记录一次JVM old过高的排查</h3><p>今天收到一条报警，有个实例JVM old过高，于是登录上去看了一下。</p>
<ol>
<li><p>首先，<code>jps -l</code> 查到程序进程号为 1161</p>
</li>
<li><p>然后 <code>jstat -gccause 1185 1000 5</code></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                 </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure</span><br></pre></td></tr></table></figure>

<p><a href="https://serverfault.com/questions/923717/what-does-gc-allocation-failure-mean-in-my-elasticsearch-5-6-logs" target="_blank" rel="noopener">What does “GC (Allocation Failure)” mean in my ElasticSearch 5.6 logs?</a></p>
<blockquote>
<p>GC (Allocation Failure) is a JVM message (not an Elasticsearch-specific one) that can be a sign that there’s memory pressure, but it’s not catastropic to the JVM (that would cause a OutOfMemoryError log line). It can also be completely innocuous.<br>GC (Allocation Failure) means that the Java garbage collector tried to run, ran out of space in the heap, then tried to allocate more memory. It’s not a bad sign, necessarily. If you’re receiving OutOfMemoryError errors and the JVM is crashing, then you know you’re in trouble.<br>Side note / disclaimer / full disclosure / whatever the heck you want: I work for a DBaaS company that hosts Elasticsearch clusters.</p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/28342736/java-gc-allocation-failure" target="_blank" rel="noopener">Java GC (Allocation Failure)</a></p>
<blockquote>
<p>“Allocation Failure” is a cause of GC cycle to kick in.<br>“Allocation Failure” means that no more space left in Eden to allocate object. So, it is normal cause of young GC.<br>Older JVM were not printing GC cause for minor GC cycles.<br>“Allocation Failure” is almost only possible cause for minor GC. Another reason for minor GC to kick could be CMS remark phase (if +XX:+ScavengeBeforeRemark is enabled).</p>
</blockquote>
<ol start="3">
<li><code>jinfo 1161</code> 可以确认一下应用的JVM参数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Command line:  -Djava.util.logging.config.file=/opt/web/xxx/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Xms4g -Xmx4g -Xmn1024m -Xss1024K -XX:PermSize=256m -XX:MaxPermSize=512m -XX:ParallelGCThreads=8 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+UseCMSCompactAtFullCollection -XX:SurvivorRatio=4 -XX:MaxTenuringThreshold=10 -XX:CMSInitiatingOccupancyFraction=80 -Djava.security.egd=file:/dev/./urandom -DWF.uspcluster= -DWF.uspcluster=xxx -Djava.endorsed.dirs= -Dcatalina.base=/opt/web/xxx -Dcatalina.home=/opt/soft/tomcat8 -Djava.io.tmpdir=/opt/web/xxx/temp</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>jmap -heap 1161</code> 可以看一下堆的整体情况，可以看到，新生代、老年代都已满</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID 1161, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.65-b01</span><br><span class="line"></span><br><span class="line">using parallel threads in the new generation.</span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Concurrent Mark-Sweep GC</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 40</span><br><span class="line">   MaxHeapFreeRatio         = 70</span><br><span class="line">   MaxHeapSize              = 4294967296 (4096.0MB)</span><br><span class="line">   NewSize                  = 1073741824 (1024.0MB)</span><br><span class="line">   MaxNewSize               = 1073741824 (1024.0MB)</span><br><span class="line">   OldSize                  = 3221225472 (3072.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 4</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">New Generation (Eden + 1 Survivor Space):</span><br><span class="line">   capacity = 894828544 (853.375MB)</span><br><span class="line">   used     = 894828536 (853.3749923706055MB)</span><br><span class="line">   free     = 8 (7.62939453125E-6MB)</span><br><span class="line">   99.99999910597398% used</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 715915264 (682.75MB)</span><br><span class="line">   used     = 715915264 (682.75MB)</span><br><span class="line">   free     = 0 (0.0MB)</span><br><span class="line">   100.0% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 178913280 (170.625MB)</span><br><span class="line">   used     = 178913272 (170.62499237060547MB)</span><br><span class="line">   free     = 8 (7.62939453125E-6MB)</span><br><span class="line">   99.99999552855998% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 178913280 (170.625MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 178913280 (170.625MB)</span><br><span class="line">   0.0% used</span><br><span class="line">concurrent mark-sweep generation:</span><br><span class="line">   capacity = 3221225472 (3072.0MB)</span><br><span class="line">   used     = 3221225472 (3072.0MB)</span><br><span class="line">   free     = 0 (0.0MB)</span><br><span class="line">   100.0% used</span><br><span class="line"></span><br><span class="line">62273 interned Strings occupying 7047888 bytes.</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>既然内存被占满了，那么我们需要看看是什么占了内存，使用 <code>jmap -histo 1161</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:      82597943     3245691336  [B</span><br><span class="line">   2:       6768948      541514920  [[B</span><br><span class="line">   3:       6768814      162451536  com.mysql.jdbc.ByteArrayRow</span><br><span class="line">   4:        347621       42931968  [C</span><br><span class="line">   5:         79883       41219352  [Ljava.lang.Object;</span><br><span class="line">   6:        104039        9155432  java.lang.reflect.Method</span><br><span class="line">   7:        343375        8241000  java.lang.String</span><br><span class="line">   8:        220766        7064512  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">   9:         93615        3744600  java.util.LinkedHashMap$Entry</span><br><span class="line">  10:         56944        2733312  org.aspectj.weaver.reflect.ShadowMatchImpl</span><br><span class="line">  </span><br><span class="line">  ...省略</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>com.mysql.jdbc.ByteArrayRow</code> 很可疑，有6768814个实例占了154M多，在他前边的 <code>[B</code> 代表字节数组，有82597943个实例占了3.24G多，<code>[[B</code>代表二位字节数组，他有6768948个实例，占了541M多，基本上这三个货基本把整个堆（从前面jinfo打出的JVM参数可知最大4G）占满了，同时我们找一台正常的实例（与这个实例完全相同的工程、完全相同的配置）看一下他的jmap -histo，对比一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:        190913      105464840  [B</span><br><span class="line">   2:        886653       84314088  [C</span><br><span class="line">   3:        270310       55553000  [I</span><br><span class="line">   4:        191697       16869336  java.lang.reflect.Method</span><br><span class="line">   5:        659489       15827736  java.lang.String</span><br><span class="line">   6:        460922       14749504  java.util.concurrent.locks.AbstractQueuedSynchronizer$Node</span><br><span class="line">   7:        220887        7068384  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">   8:        129368        6858776  [Ljava.lang.Object;</span><br><span class="line">   9:        151208        6048320  java.util.LinkedHashMap$Entry</span><br><span class="line">  10:         77036        5630744  [Ljava.util.HashMap$Node;</span><br></pre></td></tr></table></figure>

<p>经过对比可知，前面排在第三名的 <code>com.mysql.jdbc.ByteArrayRow</code> 基本上可以确定为疑犯了，那么我们就大致确定了排查的方向。</p>
<ol start="6">
<li>来看 <code>com.mysql.jdbc.ByteArrayRow</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A RowHolder implementation that is for cached results (a-la mysql_store_result()).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteArrayRow</span> <span class="keyword">extends</span> <span class="title">ResultSetRow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[][] internalRowData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，这个类里包含了一个二维字节数组，这基本上符合了 <code>[B</code>  <code>[[B</code> <code>com.mysql.jdbc.ByteArrayRow</code> 这三个实例都很多的现象。再往下我们可以结合搜索引擎以及大胆的假设来继续排查下去了。</p>
<ol start="7">
<li>总结一下</li>
</ol>
<p>通过这个实例我们可以得出 <strong>JVM问题排查的一般步骤</strong>：通过工具（调优三大件：jstat jstack jmap 以及其他工具：jps、jinfo、jcmd）观察现象，通过现象加以猜测和对比得出方向，通过方向进一步白盒排查外加猜测尝试得出结论</p>
<h3 id="5-实现一个小顶堆"><a href="#5-实现一个小顶堆" class="headerlink" title="#5 实现一个小顶堆"></a>#5 实现一个小顶堆</h3><p>再写数据结构题时，我们先要搞明白数据结构的定义，以及要写的数据结构有哪些特性，有什么样的行为，有了这些特性、行为的理解，我们才可能写出代码，空中楼阁是造不出来的</p>
<p>可以把数据结构的特性1，2，3，4的列出来再写，另外一开始可以先把次要的元素用简单的东西实现出来（比如我这个小顶堆一开始并没有“节点Node的概念”只是先用一个整形代替了，一开始先关注实现堆的行为，节点是不是对象并不影响堆的行为，可先忽略），实现完主流程然后再回过头来改成更复杂的实现，这样循序渐进，早期把关注点集中在主流程上更容易成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.since1986.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         堆的性质</span></span><br><span class="line"><span class="comment">         1. 父节点比左子节点和右子节点都大或比左子节点和右子节点都小</span></span><br><span class="line"><span class="comment">         2. 节点和兄弟节点之间的大小无所谓(也就是左右子节点之间大小与位置无关)</span></span><br><span class="line"><span class="comment">         3. 每个节点都有编号，根节点编号为1，自根节点向下，从左至右依次顺序编号(也就是编号+1)</span></span><br><span class="line"><span class="comment">         4. 每个节点的编号有这样的规律：某个节点N的有左子节点L和右子节点R，L.number = N.number * 2,  R.number = N.number * 2 + 1,  L.number = R.number + 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         基于堆的上述性质，可以将堆在物理上使用数组存储(编号即是数组索引)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        SmallTopHeap smallTopHeap = <span class="keyword">new</span> SmallTopHeap();</span><br><span class="line">        smallTopHeap.add(<span class="number">10</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">7</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">8</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">5</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">9</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">6</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">4</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">3</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">1</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(smallTopHeap);</span><br><span class="line"></span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小顶堆</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallTopHeap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点索引恒定为1</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ROOT_NODE_INDEX = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正的堆的承载数组是需要扩容的，但是我这个只是演示用的堆，写的简单一点，不支持承载数组扩容</span></span><br><span class="line">        <span class="keyword">private</span> Node[] nodes = <span class="keyword">new</span> Node[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> largestNodeIndex = ROOT_NODE_INDEX;</span><br><span class="line"></span><br><span class="line">        SmallTopHeap() &#123;</span><br><span class="line">            <span class="comment">// 注意数组的索引是从0开始的，但是我为了方便起见，承载数组索引0位置空着不用了，因为概念上堆的索引从要从1开始</span></span><br><span class="line">            nodes[<span class="number">0</span>] = <span class="keyword">new</span> Node(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer nodeValue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (largestNodeIndex &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"这个只是演示用的堆，不支持承载数组扩容"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Node currentNode = <span class="keyword">new</span> Node(nodeValue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入时总是将要插入的节点放在整个堆的最后</span></span><br><span class="line">            <span class="keyword">int</span> currentIndex = largestNodeIndex;</span><br><span class="line">            nodes[currentIndex] = currentNode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入节点以后需要更新最大节点的索引+1(加了一个元素因此最大的索引要 + 1)</span></span><br><span class="line">            <span class="keyword">if</span> (largestNodeIndex &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                largestNodeIndex++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前承载数组中还没有存储根节点，那么当前插入的节点就是根节点，插入完成直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (currentIndex == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前承载数组中已经存储了根节点，那么插入完成后就需要进行校验，检查当前堆是否还符合堆的特性</span></span><br><span class="line">            <span class="comment">// 也就是从新插入节点的父节点开始一直循环比较大小是关系否合规，直到合规或者已经到根节点为止(根节点是编号最小的节点)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到刚刚插入的节点的父节点 parentElementIndex = currentIndex / 2 这里不用考虑当前是右节点还是左节点，不管是哪个节点，得到父节点编号都是简单的除以2即可，我们可以想一下：</span></span><br><span class="line">            <span class="comment">// 假如左子节点索引为 6 那么他的兄弟节点(也就是右节点)索引就是 6 + 1 = 7 父节点索引为 6 / 2 = 3 ，用右节点 7 来推算父节点索引： 7 / 2 = 3，这里 7 除以 2 等于 3 是因为整形除法会丢弃小数点，索引必然都是整形，因此不管是用左子节点还是右子节点来计算父节点的索引，公式都是除以2就可以了</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> parentNodeIndex = currentIndex / <span class="number">2</span>;</span><br><span class="line">                Node parentNode = nodes[parentNodeIndex];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 我们这里是小顶堆(也就是父节点的值小于子节点的值)</span></span><br><span class="line">                <span class="keyword">if</span> (parentNode.value.compareTo(currentNode.value) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果父节点的值小于当前节点的值，是符合小顶堆的特性的，那么循环就可以结束了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 要是父节点的值大于当前节点的值，那么就交换父节点与当前节点</span></span><br><span class="line">                nodes[parentNodeIndex] = currentNode;</span><br><span class="line">                nodes[currentIndex] = parentNode;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将当前索引设置为父节点索引，并且将当前节点设置为父节点这样就可以进行下次循环了</span></span><br><span class="line">                currentIndex = parentNodeIndex;</span><br><span class="line">                currentNode = nodes[currentIndex];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环到了根节点(也就是索引为1的节点)就退出</span></span><br><span class="line">                <span class="keyword">if</span> (currentIndex == ROOT_NODE_INDEX) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Integer <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (largestNodeIndex &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果只剩一个了，直接置空并返回</span></span><br><span class="line">            <span class="keyword">if</span> (largestNodeIndex == <span class="number">1</span>) &#123;</span><br><span class="line">                Node firstNode = nodes[<span class="number">1</span>];</span><br><span class="line">                nodes[<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> firstNode.value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 堆删除节点一般是删除承载数组第一个元素，然后将承载数组最后一个元素填到第一个元素的位置上，然后将最后一个元素置为null，将最后一个元素放到第一个后会破坏原来堆的性质，需要重新调整让整个承载数组重新符合堆的性质</span></span><br><span class="line">            Node nodeThatBeenDeleted = nodes[<span class="number">1</span>];</span><br><span class="line">            Integer result = nodeThatBeenDeleted.value;</span><br><span class="line"></span><br><span class="line">            Node largestIndexNode = nodes[largestNodeIndex];</span><br><span class="line">            nodes[<span class="number">1</span>] = largestIndexNode;</span><br><span class="line">            nodes[largestNodeIndex] = <span class="keyword">null</span>;</span><br><span class="line">            largestNodeIndex--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新调整结构，让承载数组重新符合堆的特性</span></span><br><span class="line">            <span class="comment">// 找到左子节点和右子节点，比较一下它们的值大小，将当前节点的值大小与他们两个之中小的那个进行比较，如果值大于就置换(置换后能保证上边的比下边的小，举个例子 假设当前节点值为 10 它的左子节点值为 5，右子节点值为 6，置换后5变为当前节点，比10和6都小，这样是符合小顶堆的性质的)，如果小于就返回</span></span><br><span class="line">            <span class="keyword">int</span> currentIndex = <span class="number">1</span>;</span><br><span class="line">            Node currentNode = nodes[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> leftChildNodeIndex = currentIndex * <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> rightChildNodeIndex = currentIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 特殊流程1：如果左子节点的索引已经大于最大索引了，那直接跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (leftChildNodeIndex &gt; largestNodeIndex) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 特殊流程2：如果左子节点已经是最后一个了，那么直接比较交换并结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (leftChildNodeIndex == largestNodeIndex) &#123;</span><br><span class="line">                    Node leftChildNode = nodes[leftChildNodeIndex];</span><br><span class="line">                    <span class="keyword">if</span> (leftChildNode.value.compareTo(currentNode.value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    nodes[currentIndex] = leftChildNode;</span><br><span class="line">                    nodes[leftChildNodeIndex] = currentNode;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 普通流程：左子节点没有到最大索引(此时右子节点有可能是最大索引也有可能不是，倒无所谓，不影响流程，走普通流程就好)</span></span><br><span class="line">                    Node leftChildNode = nodes[leftChildNodeIndex];</span><br><span class="line">                    Node rightChildNode = nodes[rightChildNodeIndex];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到左子节点右子节点中小的那个</span></span><br><span class="line">                    Node smallerChild = leftChildNode.value.compareTo(rightChildNode.value) &lt; <span class="number">0</span> ? leftChildNode : rightChildNode;</span><br><span class="line">                    <span class="keyword">int</span> smallerChildIndex = leftChildNode.value.compareTo(rightChildNode.value) &lt; <span class="number">0</span> ? leftChildNodeIndex : rightChildNodeIndex;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 并于当前节点比较，如果小于就返回(父节点比两个子节点小是符合小顶堆性质的，就不用再置换处理了)</span></span><br><span class="line">                    <span class="keyword">if</span> (smallerChild.value.compareTo(currentNode.value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前节点的值大小与他们两个之中小的那个进行比较，如果值大于就置换处理</span></span><br><span class="line">                    nodes[currentIndex] = smallerChild;</span><br><span class="line">                    nodes[smallerChildIndex] = currentNode;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 并将当前索引置为较小子节点的索引，将当前节点置为较小节点，以便进行下一轮循环</span></span><br><span class="line">                    currentIndex = smallerChildIndex;</span><br><span class="line">                    currentNode = nodes[currentIndex];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果已经到了最大索引，就退出循环</span></span><br><span class="line">                    <span class="keyword">if</span> (currentIndex == largestNodeIndex) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StringJoiner(<span class="string">","</span>, <span class="string">"&#123;"</span>, <span class="string">"&#125;"</span>)</span><br><span class="line">                    .add(<span class="string">"\"nodes\":"</span> + Arrays.toString(nodes))</span><br><span class="line">                    .add(<span class="string">"\"largestNodeIndex\":"</span> + largestNodeIndex)</span><br><span class="line">                    .toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> Integer value;</span><br><span class="line"></span><br><span class="line">            Node(Integer value) &#123;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> StringJoiner(<span class="string">":"</span>, <span class="string">"&#123;"</span>, <span class="string">"&#125;"</span>)</span><br><span class="line">                        .add(<span class="string">"\"value\""</span>)</span><br><span class="line">                        .add(String.valueOf(value))</span><br><span class="line">                        .toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;nodes&quot;:[&#123;&quot;value&quot;:null&#125;, &#123;&quot;value&quot;:1&#125;, &#123;&quot;value&quot;:2&#125;, &#123;&quot;value&quot;:5&#125;, &#123;&quot;value&quot;:4&#125;, &#123;&quot;value&quot;:3&#125;, &#123;&quot;value&quot;:8&#125;, &#123;&quot;value&quot;:6&#125;, &#123;&quot;value&quot;:10&#125;, &#123;&quot;value&quot;:7&#125;, &#123;&quot;value&quot;:9&#125;],&quot;largestNodeIndex&quot;:10&#125;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h3 id="6-JMM对64位数据类型有特殊规范"><a href="#6-JMM对64位数据类型有特殊规范" class="headerlink" title="#6 JMM对64位数据类型有特殊规范"></a>#6 JMM对64位数据类型有特殊规范</h3><p>第一点：JMM 规范定义了8种操作（逻辑上的定义）lock、unlock、read、load、use、assign、store、write ，并且有规定：“不允许read和load、store和write操作单一出现”，也就是 read必然伴随load 、store必然伴随write，也就是主内存中的变量同步至工作内存（read和load）这个操作是原子的，同时工作内存中的值同步到主内存这个操作（store和write）也是原子的 我不知道你问题里“原子的”是不是指的这个范畴</p>
<p>第二：以上那两个操作，JMM的设计是：对于64为数据类型，不要求完全遵守，但是强烈建议遵守，商业虚拟机在实现上也一般听从了JMM的建议，将64位类型的那两种操作也实现成了原子的</p>
<h3 id="7-new-都做了什么操作"><a href="#7-new-都做了什么操作" class="headerlink" title="#7 new 都做了什么操作"></a>#7 <code>new</code> 都做了什么操作</h3><p>一个 new 语句分为4步 第一步NEW是创建并默认初始化 然后放到栈顶 然后复制一份栈顶再放到栈顶 然后用栈顶传入 <init> 最后再哪栈顶放到局部变量</init></p>
<p>参考 <a href="https://www.zhihu.com/question/52749416" target="_blank" rel="noopener">关于JVM字节码中dup指令的问题？</a></p>
<p><img src="/notes/index/7-1.png" alt="图7-1"></p>
<h3 id="8-随机数"><a href="#8-随机数" class="headerlink" title="#8 随机数"></a>#8 随机数</h3><p>Java的随机数生成的大致逻辑是：用户提供（或Random类内部自行生成）一个初始的数，然后通过一个公式（名字叫线性同余公式）把这个初始数作为输入给你算出另一个数，用这个过程模拟随机性，构造器里有值就是使用者给初识数，没值就是Random类自己给生成一个初识数（初始数叫做种子）</p>
<h3 id="9-annotation-类型的切入点只在有接口方法声明的前提下生效，为什么"><a href="#9-annotation-类型的切入点只在有接口方法声明的前提下生效，为什么" class="headerlink" title="#9 @annotation 类型的切入点只在有接口方法声明的前提下生效，为什么"></a>#9 @annotation 类型的切入点只在有接口方法声明的前提下生效，为什么</h3><p>昨天那个问题我基本上已经串起来了，我灵机一动看了一下 idea 的调用栈视图（这个方法在整个流程的什么位置已经直观的在调用栈里显示出来了，很清晰，想知道流程就沿着调用栈倒推即可）</p>
<p><img src="/notes/index/9-1.png" alt="图9-1"></p>
<p>大致的是：</p>
<ol>
<li><p>在Spring创建我那个被切入的Service的Bean的时候，也就是 doCreateBean 的时候会执行一个初始化流程，也就是执行这个方法： org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(java.lang.String, java.lang.Object, org.springframework.beans.factory.support.RootBeanDefinition)</p>
</li>
<li><p>在上面这个方法里有一个应用后处理器（BeanPostProcessor）的调用 ，也就是 执行applyBeanPostProcessorsAfterInitialization </p>
</li>
<li><p>在上面那个方法里会调用 BeanPostProcessor的postProcessAfterInitialization，而执行的对象是AbstractAutoProxyCreator，也就是执行这个方法： org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessAfterInitialization</p>
</li>
<li><p>上边那个方法会调用 wrapIfNecessary （Wrap the given bean if necessary, i.e. if it is eligible for being proxied.）</p>
</li>
<li><p>上边那个方法会调用 getAdvicesAndAdvisorsForBean （ Return whether the given bean is to be proxied, what additional advices (e.g. AOP Alliance interceptors) and advisors to apply.）</p>
</li>
<li><p>上边方法会调用 findEligibleAdvisors （Find all eligible Advisors for auto-proxying this class.）也就是找到所有合格的 Advisor （Advisor 是增强器，对应了我们自己写的标注了@Aspect的类中具体对原需要增强方法的增强操作）</p>
</li>
<li><p>然后上边方法调用 findAdvisorsThatCanApply （Search the given candidate Advisors to find all Advisors that）</p>
</li>
<li><p>然后上边调用 findAdvisorsThatCanApply （Determine the sublist of the {@code candidateAdvisors} list that is applicable to the given class.）</p>
</li>
<li><p>然后调用 canApply （Can the given advisor apply at all on the given class?）</p>
</li>
<li><p>然后调用 org.springframework.aop.support.AopUtils#canApply(org.springframework.aop.Pointcut, java.lang.Class<?>, boolean)
这个也就是昨天我加断点的方法，在这个方法里通过切入点定义 Pointcut 以及通过 ClassUtils.getAllInterfacesForClassAsSet(targetClass) 找到的切入目标类的接口（重点是*接口*）然后循环此接口的所有方法来判断是不是能被切入（具体调用 org.springframework.aop.aspectj.AspectJExpressionPointcut#matches(java.lang.reflect.Method, java.lang.Class<?>, boolean) 来判断） 关键就在于是找的是接口而不是实现</p>
</li>
</ol>
<p>切面（Aspect） = 切入点（Pointcut） + 通知（Advice）</p>
<p><em>spring 中 AOP 是通过 BeanPostProcessor 插入到 IoC 流程里的</em></p>
<p><a href="https://www.cnblogs.com/leeSmall/p/10236553.html" target="_blank" rel="noopener">框架源码系列十：Spring AOP（AOP的核心概念回顾、Spring中AOP的用法、Spring AOP 源码学习）</a></p>
<h3 id="10-责任链模式尝试"><a href="#10-责任链模式尝试" class="headerlink" title="#10 责任链模式尝试"></a>#10 责任链模式尝试</h3><p><img src="/notes/index/10-1.png" alt="图10-1"></p>
<h3 id="11-spring配置方式的变更与DRY"><a href="#11-spring配置方式的变更与DRY" class="headerlink" title="#11 spring配置方式的变更与DRY"></a>#11 spring配置方式的变更与DRY</h3><p>Spring的配置信息由外部配置xml的方式改为内部注解配置的方式正是DRY原则的一种体现，原有的xml配置方式你需要将类的完全限定名等元信息重复的在XML里再写一份，而注解则不需要，因为类自己就是对象的元信息，自描述了，当然不需要外部描述了，这正是DRY的一种体现。</p>
<p><img src="/notes/index/11-1.jpg" alt="图11-1"></p>
<h3 id="12-容器管理实例的模式"><a href="#12-容器管理实例的模式" class="headerlink" title="#12 容器管理实例的模式"></a>#12 容器管理实例的模式</h3><p>Spring对于Java中标准的new逻辑的增强，与hibernate中的实体的概念有着异曲同工之妙，都是是用外部容器管理实例，这样可以给整个实例的生命周期中插入很多扩展点，通过扩展点就能玩出很多new玩不出来的新花样</p>
<p><img src="/notes/index/12-1.jpg" alt="图12-1"></p>
<h3 id="13-编程本质"><a href="#13-编程本质" class="headerlink" title="#13 编程本质"></a>#13 编程本质</h3><p>编程本质的一个方面：将人类的逻辑转化为机器逻辑。</p>
<p>人类逻辑 -&gt; 自然语言<br>自然语言 -&gt; 高级编程语言<br>高级编程语言 -&gt; 底层编程语言<br>底层编程语言 -&gt; 机器语言<br>机器语言 -&gt; 机器逻辑</p>
<p>编程的一方面本质：恰恰是在造轮子，某个业务工程的设计思想完全可能来自于某个中间件的设计思想，比如我将netty中责任链的设计思路和Spring的MethodHandleAdptor中的SPI思路移植到支付系统的架构思路中，这本质上是将表象的代码逻辑实现回归拆解提炼为最基本的逻辑内核，然后再反相用这个逻辑内核结合业务需求提炼出的细节来重塑一个完整体系的过程</p>
<p>刚才思考了一个问题和大家分享一下：<br>前一阵我在我的一个支付业务工程里应用了类似netty中的责任链的设计方式 我觉得这个过程背后有一些通用的东西</p>
<p>编程的一方面本质：构建逻辑内核，用逻辑内核制造上层建筑。</p>
<p>某个业务工程的设计思想完全可能来自于某个中间件的设计思想，比如将netty中责任链的设计思路和Spring的MethodHandleAdptor中的SPI思路移植到支付系统的架构思路中</p>
<p>这本质上是将表象的代码逻辑实现回归拆解提炼为最基本的逻辑内核，然后再反相用这个逻辑内核结合业务需求提炼出的细节来重塑一个完整体系的过程</p>
<p>不过这个理解感觉还不是特别深 毕竟 netty的这个设计思路我不是自己看懂的 而是看来别人写的分析 算是间接的 但是感觉整体的方向应该差不多</p>
<p>自顶向下然后又自底而上</p>
<p>归根结底是逻辑</p>
<p>共性的东西</p>
<p>其实也就是把轮子拆解一下，或者把造轮子的过程拆解一下，提取出构造的通用办法，然后配合手头的工具箱和原材料再去造自己的轮子或者造别的什么东西的一个过程</p>
<p>简单点说就是不断琢磨比人的轮子然后造自己的轮子</p>
<h3 id="14-分析Java线程CPU占用率高的步骤"><a href="#14-分析Java线程CPU占用率高的步骤" class="headerlink" title="#14 分析Java线程CPU占用率高的步骤"></a>#14 分析Java线程CPU占用率高的步骤</h3><ol>
<li><code>jps -l</code> 找到Java进程pid</li>
<li><code>echo &quot;obase=16;&lt;pid&gt;&quot; | bc</code> 得到pid的十六进制值（也可使用在线转换工具）</li>
<li><code>jstack &lt;pid&gt; | grep &lt;pid_hex&gt;</code> 按上一步得到的十六进制pid搜素jstack的输出结果，从而定位到具体的栈信息</li>
<li>根据得到的栈信息进行推测</li>
</ol>
<h3 id="15-对于Spring-IoC的理解"><a href="#15-对于Spring-IoC的理解" class="headerlink" title="#15 对于Spring IoC的理解"></a>#15 对于Spring IoC的理解</h3><p>对于Spring IoC的理解 ：自动化车间。给定原材料（原始类定义）和规格说明书（元数据，包括注解和xml等），就会生产出产品（Bean），在这个期间不需过多干预，但是提供了扩展点可以进行必要的干预（BeanFactoryPostProcessor 和 BeanPostProcessor）</p>
<h3 id="16-Spring的设计哲学"><a href="#16-Spring的设计哲学" class="headerlink" title="#16 Spring的设计哲学"></a>#16 Spring的设计哲学</h3><p>核心功能 + 扩展点</p>
<p>spring的轻量是轻量在设计上 他的微内核设计思想 核心功能BeanFactory很小 很多功能比如自动装配Autoware均是通过扩展点PostProcessor实现的</p>
<p>比如各种Awre如ApplicationContextAware也是通过PostProcessor实现的？<br>AOP也是通过BeanPostProcessor这个扩展点插入的IoC这个主逻辑中的</p>
<h3 id="17-对象的本质是-状态-行为"><a href="#17-对象的本质是-状态-行为" class="headerlink" title="#17 对象的本质是 状态 + 行为"></a>#17 对象的本质是 状态 + 行为</h3><blockquote>
<p>A Class is a software bundle of related states(properties, or variables) and behavior(methods)</p>
</blockquote>
<h3 id="18-Spring-兼容循环依赖的做法"><a href="#18-Spring-兼容循环依赖的做法" class="headerlink" title="#18 Spring 兼容循环依赖的做法"></a>#18 Spring 兼容循环依赖的做法</h3><p><img src="/notes/index/18-1.png" alt="图18-1"></p>
<p><img src="/notes/index/18-2.png" alt="图18-2"></p>
<p><img src="/notes/index/18-3.png" alt="图18-3"></p>
<p><img src="/notes/index/18-4.png" alt="图18-4"></p>
<p>这样加一下断点调一下试试，所有断点都是条件断点 然后两个Bean的无参构造器上加方法断点</p>
<p>先通过 getBean -&gt; createBean 流程创建Bean3实例，然后通过 InstantiationAwareBeanPostProcessorBean3 在其中解析依赖，解析依赖又会触发创建流程创建，创建Bean4实例，然后又会通过 InstantiationAwareBeanPostProcessorBean4  在其中进行Bean4解析依赖拿出来Bean3设置到自己的属性，然后将已经设置了Bean3 的 Bean4 设置到一开始的 Bean3上，这样Bean3和Bean4就实现了循环依赖</p>
<p>这个过程大概通俗一点就是  (A -&gt; (B -&gt; BA)) -&gt; ABA</p>
<p>整个流程应该就是先各自生成一个没依赖的光棍对象Bean，然后把前一个光棍设置后一个光棍当依赖，然后再把已经有依赖的后一个光棍（其实现在已经不是光棍了）设置给前一个光棍当依赖，这样就成了一个环状依赖了</p>
<h3 id="19-Spring-Bean-Scope"><a href="#19-Spring-Bean-Scope" class="headerlink" title="#19 Spring Bean Scope"></a>#19 Spring Bean Scope</h3><p>Spring bean的两种scope的区别在于对待状态的态度 一个是共享状态 一个是状态独立</p>
<h3 id="20-RootBeanDefinition"><a href="#20-RootBeanDefinition" class="headerlink" title="#20 RootBeanDefinition"></a>#20 RootBeanDefinition</h3><p>RootBeanDefinition 是对于容器内实例的定义</p>
<p><img src="/notes/index/20-1.jpg" alt="图20-1"></p>
<h3 id="21-IoC-的两种实现方式-DF-和-DI"><a href="#21-IoC-的两种实现方式-DF-和-DI" class="headerlink" title="#21 IoC 的两种实现方式 DF 和 DI"></a>#21 IoC 的两种实现方式 DF 和 DI</h3><p>通过容器提供的回调Api而非Java语言级别的Api（setter 、构造器）完成控制，这种方式叫做DF也就是依赖查找 是IoC的另一种实现方式</p>
<h3 id="22-对于-IoC-的理解"><a href="#22-对于-IoC-的理解" class="headerlink" title="#22 对于 IoC 的理解"></a>#22 对于 IoC 的理解</h3><p>对于IoC的理解：怎样对待依赖：是自己创建依赖，也就是new还是从外部获取依赖，从外部获取依赖分为DF和DI也就是依赖查找和依赖注入</p>
<h3 id="23-ApplicationContext"><a href="#23-ApplicationContext" class="headerlink" title="#23 ApplicationContext"></a>#23 ApplicationContext</h3><p>ApplicationContext 比 BeanFactory 多了 事件监听机制、MessageSource和统一的资源加载Api（ResourceLoader）,另外比普通BeanFactory 多了 BeanFactoryPostProcessor 可以在ApplicationContext启动时修改Bean声明,比如内置的后处理器PropertyOverrideConfigure就可以用于覆盖Bean中的属性</p>
<h3 id="24-ProxyFactoryBean"><a href="#24-ProxyFactoryBean" class="headerlink" title="#24 ProxyFactoryBean"></a>#24 ProxyFactoryBean</h3><p>ProxyFactoryBean 也是一个重要的扩展点，事物AOP通过这个实现，FactoryBean是个重要的扩展点，</p>
<h3 id="25-Spring事务处理的顶层设计"><a href="#25-Spring事务处理的顶层设计" class="headerlink" title="#25 Spring事务处理的顶层设计"></a>#25 Spring事务处理的顶层设计</h3><p>Spring事务处理的顶层设计：面对事物资源（数据库）用PlatformTransactionManager去对接，而面向客户端代码（业务逻辑）使用AOP来对接（细粒度的实现：ProxyFactoryBean 和 Interceptor 或 粗粒度的实现；TransactionProxyFactoryBean）</p>
<p>事物定义：TransactionDefinition 这个可类比 BeanDefinition</p>
<p>事物属性需TransactionAttribute要事物定义</p>
<p>事物管理器（面向事物资源的顶层接口）需要事物定义 然后返回事物状态，事物状态是面向客户端的接口</p>
<p>Spring允许客户端通过两种方式使用事物支持：编程式（直接使用TransactionManager或用TransactionTemplate）和声明式（用AOP来接入TransactionManager）</p>
<p>Spring通过TransactionProxyFactoryBean，也就是FactoryBean这个IoC扩展点实现了代理对象的生成，然后通过TransactionIterseptor完成对代理方法的拦截将事务处理功能编织到拦截方法里（PlatformTransactionManager实现了TransactionInterception</p>
<p><a href="https://www.cnblogs.com/chihirotan/p/6739748.html" target="_blank" rel="noopener">spring—transaction（1）—源代码分析(事务的拦截器TransactionInterceptor)
</a></p>
<h3 id="26-持续重构"><a href="#26-持续重构" class="headerlink" title="#26 持续重构"></a>#26 持续重构</h3><p>持续重构 说白了其实就是当看到自己之前写的代码有可以改进的地方，比如可以提出方法的逻辑块，就着手改进，而不是放任不管，追求卓越是重构的精髓</p>
<h3 id="27-SpringBoot"><a href="#27-SpringBoot" class="headerlink" title="#27 SpringBoot"></a>#27 SpringBoot</h3><p>SpringBoot 不再像传统 Spring 需要从外部容器的回掉中启动 应用上下文，而是反过来将容器纳入了应用上下文</p>
<h3 id="28-spring-mvc请求处理过程"><a href="#28-spring-mvc请求处理过程" class="headerlink" title="#28 spring-mvc请求处理过程"></a>#28 spring-mvc请求处理过程</h3><p>在某一 Controller 方法上加断点，走到断点处，在调试视图中通过调用栈视图可看到 spring-mvc 的入口点为 FrameworkServlet 的 doService，我们可在此加断点，从新来一遍进行分析</p>
<p><img src="/notes/index/28-1.png" alt="图28-1"></p>
<p><em>整体概念</em></p>
<p>DispatcherServlet 做请求分发</p>
<p>分发是根据 HandlerMapping 获得 Handler 然后封装成 HandlerExecutionChain </p>
<p>HandlerExecutionChain中包含两部分，一部分是标识执行主体的HandlerMethod，另一部分是其拦截器集合，拦截器分别在其执行handle前、后执行。</p>
<p>HandlerMethod 会再封装为 HandlerAdapter 在其中用反射调用真正的 Controller中的方法逻辑</p>
<p><em>大流程</em></p>
<ul>
<li><p>入口 FrameworkServlet 模板方法 doService</p>
</li>
<li><p>DispatcherServlet 实现 doService</p>
</li>
</ul>
<p>org.springframework.web.servlet.DispatcherServlet#doService</p>
<ul>
<li>doDispatch 做请求分发</li>
</ul>
<p>org.springframework.web.servlet.DispatcherServlet#doDispatch</p>
<ul>
<li>getHandler 获得 HandlerExecutionChain，HandlerExecutionChain是Handler（也就是Controller）和一组HandlerInterceptor的聚合 org.springframework.web.servlet.DispatcherServlet#getHandler 其内部处理流程：<ul>
<li>循环 this.handlerMappings 调用每一个 mapping 的 getHandler ：org.springframework.web.servlet.HandlerMapping#getHandler 其内部处理流程：<ul>
<li>org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandlerInternal 获得HandlerMethod（实际上也就是我们写的Controller中各种标记了@RequestMapping的方法包装后的结果）</li>
<li>如果上一步获得的是null那么就获得默认的handler org.springframework.web.servlet.handler.AbstractHandlerMapping#getDefaultHandler</li>
<li>如果上一步默认handler也为null那么直接返回null退出方法</li>
<li>如果 handler instanceof String 那么证明handler是需要通过Bean名字从ApplicationContext里拿，如果是那么就去拿出来</li>
<li>org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandlerExecutionChain 获得 HandlerExecutionChain 并返回，其内部处理流程：<ul>
<li>如果handler不是HandlerExecutionChain类型的，那么将handler套入new HandlerExecutionChain（） 创建成 HandlerExecutionChain</li>
<li>获得Handler的lookupPath，也就是我们自己写的Controller的RequestMapping中的URI</li>
<li>循环所有MappedInterceptor看起是否match到lookupPath，如果match到则此拦截器放到第一步生成的HandlerExecutionChain中然后返回</li>
</ul>
</li>
</ul>
</li>
<li>遇到第一个不为null的HandlerExecutionChain 立刻（跳出循环）返回</li>
</ul>
</li>
</ul>
<ul>
<li><p>将上一步产生的HandlerExecutionChain中的HandlerMethod拿出来当作参数传入getHandlerAdapter获得HandlerAdapter ，HandlerAdapter 是一个SPI，用于外部扩展干预spring-mvc内部流程用的，其内部流程：</p>
<ul>
<li>循环handlerAdapters找到第一个supports的就返回</li>
</ul>
</li>
<li><p>Process last-modified header 处理 last-modified</p>
</li>
<li><p>org.springframework.web.servlet.HandlerExecutionChain#applyPreHandle 进行handle前处理</p>
</li>
<li><p>org.springframework.web.servlet.HandlerAdapter#handle 进行真正的Handler的handle（也就是 Controller 中对应的我们自己实现的逻辑）并返回 ModelAndView 其内部处理流程：</p>
<ul>
<li>调用 checkRequest 校验是否支持当前请求方法类别</li>
<li>将HandlerMethod 封装为 InvocableHandlerMethod 并执行其 invokeAndHandle，在其内部流程中最终会通过反射（ java.lang.reflect.Method#invoke）执行HandlerMethod中对应的我们自己定义的Controller中的方法</li>
<li>调用 getModelAndView 完成并返回</li>
</ul>
</li>
<li><p>org.springframework.web.servlet.DispatcherServlet#applyDefaultViewName 为上一步返回的 ModelAndView 应用DefaultViewName 其内部流程：</p>
</li>
<li><p>org.springframework.web.servlet.HandlerExecutionChain#applyPostHandle 进行handle后处理</p>
</li>
<li><p>org.springframework.web.servlet.DispatcherServlet#processDispatchResult 完成处理</p>
</li>
</ul>
<h3 id="29-Bean"><a href="#29-Bean" class="headerlink" title="#29 @Bean"></a>#29 @Bean</h3><p>@Bean 在 @Componet 和 @Configuration 中语义不同，在 @Configuration 中会被 cglib 增强而在 @Componet 中则不会</p>
<p><img src="/notes/index/29-1.jpg" alt="图29-1"></p>
<h3 id="30-spring-boot-自动配置实现的重要的点"><a href="#30-spring-boot-自动配置实现的重要的点" class="headerlink" title="#30 spring-boot 自动配置实现的重要的点"></a>#30 spring-boot 自动配置实现的重要的点</h3><p>META-INF/spring.factories</p>
<h3 id="31-Controller-注解"><a href="#31-Controller-注解" class="headerlink" title="#31 @Controller 注解"></a>#31 @Controller 注解</h3><p>主要用于标识当前Bean是否是spring-mvc中的 “Handler” 概念</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Expects a handler to have either a type-level @&#123;<span class="doctag">@link</span> Controller&#125;</span></span><br><span class="line"><span class="comment"> * annotation or a type-level @&#123;<span class="doctag">@link</span> RequestMapping&#125; annotation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHandler</span><span class="params">(Class&lt;?&gt; beanType)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||</span><br><span class="line">			AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="32-AbstractHandlerMethodMapping"><a href="#32-AbstractHandlerMethodMapping" class="headerlink" title="#32 AbstractHandlerMethodMapping"></a>#32 AbstractHandlerMethodMapping</h3><p>spring-mvc 注册 Controller与请求映射路径的对应关系的入口在 <code>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#initHandlerMethods</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scan beans in the ApplicationContext, detect and register handler methods.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getCandidateBeanNames()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #processCandidateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #handlerMethodsInitialized</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">			processCandidateBean(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33-RequestMappingHandlerMapping"><a href="#33-RequestMappingHandlerMapping" class="headerlink" title="#33 RequestMappingHandlerMapping"></a>#33 RequestMappingHandlerMapping</h3><p>RequestMappingHandlerMapping 这个类型的 Bean 是通过 @EnableWebMvc 中的 @Import(DelegatingWebMvcConfiguration.class) 进入容器的</p>
<p>具体的通过：</p>
<p><code>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#requestMappingHandlerMapping</code><br> 注册到容器的</p>
<h3 id="34-ExecutionChain"><a href="#34-ExecutionChain" class="headerlink" title="#34 ExecutionChain"></a>#34 ExecutionChain</h3><p>Spring mvc 的 Handler （也就是Controller）会被链接上若干拦截器然后包装成 ExecutionChain</p>
<h3 id="35-原型方式的Bean是否支持依赖注入？"><a href="#35-原型方式的Bean是否支持依赖注入？" class="headerlink" title="#35 原型方式的Bean是否支持依赖注入？"></a>#35 原型方式的Bean是否支持依赖注入？</h3><p>Spring 本身能够支持 prototype 类型 Bean 的依赖注入，无需特殊处理</p>
<h3 id="36-Lookup"><a href="#36-Lookup" class="headerlink" title="#36 @Lookup"></a>#36 @Lookup</h3><p>@Lookup 用于单例引用另一个单例而另一单例引用原型的场景，如不做处理，这种场景每回得到的原型Bean都是同一实例，因为单例引用单例时不会触发另一个单例中原型的重新创建实例操作，@Lookup 内部的解决方法是将被引用的单例也就是@Lookup所在的单例用cglib每次都生成一个子类实例，每次实例不同这样就可触发引用的原型的实例化了</p>
<p>（如果不用Lookup则那个原型不回生成新实例 那么原型的语义就丢失了）</p>
<h3 id="37-生命周期"><a href="#37-生命周期" class="headerlink" title="#37 生命周期"></a>#37 生命周期</h3><p>关于生命周期：没有容器管理 生命周期只有 new 和 被垃圾回收，有容器管理 容器会给它安排一系列回调比如 PostConstruct</p>
<p>所谓生命周期是容器内部的状态转换，但是一般对外提供回调从而可以进行干预</p>
<h3 id="38-ServletContextListener"><a href="#38-ServletContextListener" class="headerlink" title="#38 ServletContextListener"></a>#38 ServletContextListener</h3><p>ServletContextListener 是Servlet容器提供的扩展点，spring的ContextLoaderListener实现了这个扩展点，是传统 spring-mvc 的入口点</p>
<h3 id="39-Configuration"><a href="#39-Configuration" class="headerlink" title="#39 @Configuration"></a>#39 @Configuration</h3><p>@Configuration 是通过 ConfigurationClassPostProcessor 这个 BeanFactoryPostProcessor 接入的</p>
<p><img src="/notes/index/39-1.png" alt="图39-1"></p>
<h3 id="40-什么是语法？"><a href="#40-什么是语法？" class="headerlink" title="#40 什么是语法？"></a>#40 什么是语法？</h3><p>在编程中，语法意味着一个调用命令，输入参数去让应用执行程序的文法结构。这些语法被规则或明或暗的约束。程序员遵循语法规范以和计算机交互。如果一段程序语法不正确，计算机将无法识别。这些语法可以自我释义，支持注释。</p>
<h3 id="41-GC日志释意"><a href="#41-GC日志释意" class="headerlink" title="#41 GC日志释意"></a>#41 GC日志释意</h3><p><img src="/notes/index/41-1.jpg" alt="图41-1"></p>
<h3 id="42"><a href="#42" class="headerlink" title="#42"></a>#42</h3><p>把自己对于一个话题的扩展理解说出来 而不是局限于具有话题本身</p>
<h3 id="43"><a href="#43" class="headerlink" title="#43"></a>#43</h3><p>ServletContainerInitializer 是一种 SPI</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface which allows a library/runtime to be notified of a web</span></span><br><span class="line"><span class="comment"> * application's startup phase and perform any required programmatic</span></span><br><span class="line"><span class="comment"> * registration of servlets, filters, and listeners in response to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementations of this interface may be annotated with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> javax.servlet.annotation.HandlesTypes HandlesTypes&#125;, in order to</span></span><br><span class="line"><span class="comment"> * receive (at their &#123;<span class="doctag">@link</span> #onStartup&#125; method) the Set of application</span></span><br><span class="line"><span class="comment"> * classes that implement, extend, or have been annotated with the class</span></span><br><span class="line"><span class="comment"> * types specified by the annotation.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If an implementation of this interface does not use &lt;tt&gt;HandlesTypes&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * annotation, or none of the application classes match the ones specified</span></span><br><span class="line"><span class="comment"> * by the annotation, the container must pass a &lt;tt&gt;null&lt;/tt&gt; Set of classes</span></span><br><span class="line"><span class="comment"> * to &#123;<span class="doctag">@link</span> #onStartup&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;When examining the classes of an application to see if they match</span></span><br><span class="line"><span class="comment"> * any of the criteria specified by the &lt;tt&gt;HandlesTypes&lt;/tt&gt; annotation</span></span><br><span class="line"><span class="comment"> * of a &lt;tt&gt;ServletContainerInitializer&lt;/tt&gt;, the container may run into</span></span><br><span class="line"><span class="comment"> * classloading problems if any of the application's optional JAR</span></span><br><span class="line"><span class="comment"> * files are missing. Because the container is not in a position to decide</span></span><br><span class="line"><span class="comment"> * whether these types of classloading failures will prevent</span></span><br><span class="line"><span class="comment"> * the application from working correctly, it must ignore them,</span></span><br><span class="line"><span class="comment"> * while at the same time providing a configuration option that would</span></span><br><span class="line"><span class="comment"> * log them. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementations of this interface must be declared by a JAR file</span></span><br><span class="line"><span class="comment"> * resource located inside the &lt;tt&gt;META-INF/services&lt;/tt&gt; directory and</span></span><br><span class="line"><span class="comment"> * named for the fully qualified class name of this interface, and will be </span></span><br><span class="line"><span class="comment"> * discovered using the runtime's service provider lookup mechanism</span></span><br><span class="line"><span class="comment"> * or a container specific mechanism that is semantically equivalent to</span></span><br><span class="line"><span class="comment"> * it. In either case, &lt;tt&gt;ServletContainerInitializer&lt;/tt&gt; services from web</span></span><br><span class="line"><span class="comment"> * fragment JAR files excluded from an absolute ordering must be ignored,</span></span><br><span class="line"><span class="comment"> * and the order in which these services are discovered must follow the</span></span><br><span class="line"><span class="comment"> * application's classloading delegation model.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> javax.servlet.annotation.HandlesTypes</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> Servlet 3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletContainerInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notifies this &lt;tt&gt;ServletContainerInitializer&lt;/tt&gt; of the startup</span></span><br><span class="line"><span class="comment">     * of the application represented by the given &lt;tt&gt;ServletContext&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If this &lt;tt&gt;ServletContainerInitializer&lt;/tt&gt; is bundled in a JAR</span></span><br><span class="line"><span class="comment">     * file inside the &lt;tt&gt;WEB-INF/lib&lt;/tt&gt; directory of an application,</span></span><br><span class="line"><span class="comment">     * its &lt;tt&gt;onStartup&lt;/tt&gt; method will be invoked only once during the</span></span><br><span class="line"><span class="comment">     * startup of the bundling application. If this</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;ServletContainerInitializer&lt;/tt&gt; is bundled inside a JAR file</span></span><br><span class="line"><span class="comment">     * outside of any &lt;tt&gt;WEB-INF/lib&lt;/tt&gt; directory, but still</span></span><br><span class="line"><span class="comment">     * discoverable as described above, its &lt;tt&gt;onStartup&lt;/tt&gt; method</span></span><br><span class="line"><span class="comment">     * will be invoked every time an application is started.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the Set of application classes that extend, implement, or</span></span><br><span class="line"><span class="comment">     * have been annotated with the class types specified by the </span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> javax.servlet.annotation.HandlesTypes HandlesTypes&#125; annotation,</span></span><br><span class="line"><span class="comment">     * or &lt;tt&gt;null&lt;/tt&gt; if there are no matches, or this</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;ServletContainerInitializer&lt;/tt&gt; has not been annotated with</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;HandlesTypes&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx the &lt;tt&gt;ServletContext&lt;/tt&gt; of the web application that</span></span><br><span class="line"><span class="comment">     * is being started and in which the classes contained in &lt;tt&gt;c&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * were found</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException if an error has occurred</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="44-JVM内存划分"><a href="#44-JVM内存划分" class="headerlink" title="#44 JVM内存划分"></a>#44 JVM内存划分</h3><p>JVM 分为 堆 Java栈 native栈 方法区 PC</p>
<p>Java栈 中是 帧</p>
<p>桢中包含 本地变量表 异常处理表 操作数栈 常量池指针</p>
<p>调用方法时帧入栈 return或exception时帧出栈</p>
<h3 id="45-栈上分配"><a href="#45-栈上分配" class="headerlink" title="#45 栈上分配"></a>#45 栈上分配</h3><p>栈上分配：经逃逸分析后发现未逃逸（也就是没有其他引用到的地方）那么会分配到栈上，标量替换 将对象的属性拆出来各自分配到栈 <a href="http://blueskykong.com/2019/07/13/kong1/" target="_blank" rel="noopener">http://blueskykong.com/2019/07/13/kong1/</a></p>
<h3 id="46-HashMap"><a href="#46-HashMap" class="headerlink" title="#46 HashMap"></a>#46 HashMap</h3><p>HashMap 获得节点的逻辑 ： 入参为 key 的 hash 值和 key 的值<br>先用 key的hash值 &amp; (桶数组长度 - 1)也就是对于桶长度取模，也就是掩码操作得出key在桶中index由此index拿出元素，若此元素和key的hash值相同并且此元素的key和给定的key相同 那么直接返回此元素</p>
<p>如果不满足上边条件，同时此元素有后继，则一路看其后继的 hash、key是否与传入值相等（这里分为两种情况，如果当前元素为树节点，则走树检索，若不是树节点则走普通的链表检索）</p>
<h3 id="47-HashMap-是扩容成2倍"><a href="#47-HashMap-是扩容成2倍" class="headerlink" title="#47 HashMap 是扩容成2倍"></a>#47 HashMap 是扩容成2倍</h3><p>HashMap 是扩容成2倍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">         oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">    newThr = oldThr &lt;&lt; 1; // double threshold</span><br></pre></td></tr></table></figure>

<p>左移1位等效于 *2</p>
<p>HashMap 扩容时 如果节点是普通的节点 则用新的容量作为掩码从新计算原来元素的的索引<br>newTab[e.hash &amp; (newCap - 1)] = e;</p>
<p>注意：是不需要计算索引下标，节点的Hash值是不会发生变化的！！！<br>&amp;运算的定义：两位同时为”1”，结果才为”1”，否则为0<br>首先，我们先根据下标计算公式得出扩容前后索引的变化</p>
<p><img src="/notes/index/47-1.png" alt="图47-1"></p>
<p>根据图片可知，扩容后的21的索引下标比扩容前的索引下标多了一个1，且这个1位于newCap-1的掩码最高位<br>结论：元素在重新计算hash后，因为n变为2倍，那么n-1的mask范围在高位多1bit，即多了个原容量的距离<br>优化：无需重新计算Hash，节省了时间，新索引=原索引+原容量</p>
<p><a href="https://www.zybuluo.com/kiraSally/note/836217" target="_blank" rel="noopener">集合番@HashMap一文通（1.8版）</a></p>
<p>(e.hash &amp; bit) 实际上是为了达到一个布尔值的效果 (e.hash &amp; bit) == 0 相当于 true 否则为 false</p>
<p><img src="/notes/index/47-2.png" alt="图47-2"></p>
<h3 id="48-自学英语"><a href="#48-自学英语" class="headerlink" title="#48 自学英语"></a>#48 自学英语</h3><p><a href="https://www.jianshu.com/p/f90f35ab32cb" target="_blank" rel="noopener">自学英语阶段记录二</a></p>
<h3 id="49-ConcurrentHashMap"><a href="#49-ConcurrentHashMap" class="headerlink" title="#49 ConcurrentHashMap"></a>#49 ConcurrentHashMap</h3><p>ConcurrentHashMap 的 update操作 happen-before retrieval操作 </p>
<p>More formally, an update operation for a given key bears a<br><em>happens-before</em> relation with any (non-null) retrieval for<br>that key reporting the updated value.</p>
<p>ConcurrentHashMap 的 update操作 happen-before retrieval操作 </p>
<p>ConcurrentHashMap 的 size 当没有并非更新时才有用 它返回的是个近似值 或者说是个不能保证完全准确的值</p>
<p>ConcurrentHashMap 不能允许 null 键 HashMap可有有null键</p>
<p>不能为null的一点原因:</p>
<p>Conversely, because keys<br>and values in the map are never null, null serves as a reliable<br>atomic indicator of the current lack of any result. </p>
<p>ConcurrentHashMap取消了segment分段锁，而采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。<br>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。<br>JDK1.8的ConcurrentHashMap的结构图如下：</p>
<p><img src="/notes/index/49-1.png" alt="图49-1"></p>
<p> JDK8中的实现也是锁分离的思想，它把锁分的比segment（JDK1.5）更细一些，只要hash不冲突，就不会出现并发获得锁的情况。它首先使用无锁操作CAS插入头结点，如果插入失败，说明已经有别的线程插入头结点了，再次循环进行操作。如果头结点已经存在，则通过synchronized获得头结点锁，进行后续的操作。性能比segment分段锁又再次提升。</p>
<p>也就是乐观的思想：大部分插入由于hash值并不冲突（hash冲突毕竟是少数）因此并不需要加锁，少部分有hash冲突的插入</p>
<h3 id="50-CAS"><a href="#50-CAS" class="headerlink" title="#50 CAS"></a>#50 CAS</h3><p>Java CAS 通过 unsafe调用底层 cmpxchgl 指令的支持实现 用记数量比对来避免ABA</p>
<h3 id="51-hash索引"><a href="#51-hash索引" class="headerlink" title="#51 hash索引"></a>#51 hash索引</h3><p>hash索引存储上无序无法应对区间查询 只能用于等值查询 B+树索引存储有序 hash索引不支持复合索引左匹配 B+树索引叶节点可能存储整行数据或主键值</p>
<h3 id="52-覆盖索引"><a href="#52-覆盖索引" class="headerlink" title="#52 覆盖索引"></a>#52 覆盖索引</h3><p>覆盖索引就是从索引就能直接拿到想要的值不用回表</p>
<h3 id="53-mysql复合索引"><a href="#53-mysql复合索引" class="headerlink" title="#53 mysql复合索引"></a>#53 mysql复合索引</h3><p>mysql复合索引 前边的字段是定值那就只需要考虑后边的字段顺序就可以了 因为复合索引是将 所有字段 concat 以后排序的 前边是定值就不需要考虑他的顺序了</p>
<p>左匹配原则是 查询条件中包含的字段能从复合索引最左侧开始的字段匹配上 就一直能用到这个索引 直到中间断档了或者是不等值查询了 后边字段就用不到索引了</p>
<p>从某个字段断档或者不是等值查询就意味着无法在树节点上确定前部分的顺序 前部分无序则后边是有序还是无序整体上都是无序的 而无序就无法使用二分查找 因此也就是无法使用索引带来的查询时间复杂度降低了</p>
<p>最左匹配：查询条件中必须存在复合索引中最左边那个字段</p>
<blockquote>
<p>全值匹配我最爱，最左前缀要遵守；</p>
<p>带头大哥不能死，中间兄弟不能断；</p>
<p>索引列上少计算，范围之后全失效；</p>
<p>LIKE百分写最右，覆盖索引不写星；</p>
<p>不等空值还有or，索引失效要少用。</p>
</blockquote>
<p><a href="https://chenjiabing666.github.io/2018/09/07/mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">mysql索引优化详解</a></p>
<p>带头大哥不能死并且中间兄弟不能断</p>
<p>abc这个索引 where a= and c= 这种中间少了b 也就是中间兄弟断了不能用索引</p>
<p>where b= and c= 这种没有开头的a 带头大哥死了也不能用索引</p>
<h3 id="54-UUID"><a href="#54-UUID" class="headerlink" title="#54 UUID"></a>#54 UUID</h3><p>uuid作为主键的话由于uuid任意两个实体间本身无序 在构建索引时回造成页频繁分裂和调整 从而导致插入效率变低</p>
<p>而顺序主键则依次插入 到插入不下时才会页分裂 而由于是顺序插入因此其插入不下的情况较少 因此页分裂不频繁 插入效率高</p>
<h3 id="55-redolog、undolog"><a href="#55-redolog、undolog" class="headerlink" title="#55 redolog、undolog"></a>#55 redolog、undolog</h3><p>redolog永远灾后重新提交 undolog用于回滚</p>
<p>redolog记录物理页修改 undolog记录回滚逻辑</p>
<h3 id="56-通过间隙锁解决幻读"><a href="#56-通过间隙锁解决幻读" class="headerlink" title="#56 通过间隙锁解决幻读"></a>#56 通过间隙锁解决幻读</h3><p>行级锁分为 记录锁 间隙锁 临间锁</p>
<p>用间隙锁防止幻读（MVCC也可防止幻读）：间隙锁锁定记录范围，这样其他事物无法在当前事务结束前在指定范围内插入新值（因为这个范围被锁定了）</p>
<p>临间锁（next-key lock）= 普通记录锁 + 间隙锁 临间锁即锁定记录前的间隙 又锁定记录后的区间 这样其他事务及不能再当前事务完成前在前之前插新值同时也不能在其后插新值，也就是两边都锁定了</p>
<p>select for update 会在行上加排他锁</p>
<h3 id="57-ObjectId"><a href="#57-ObjectId" class="headerlink" title="#57 ObjectId"></a>#57 ObjectId</h3><p>时间戳 + 主机名hash + pid + 自增</p>
<h3 id="58-Redis删除策略"><a href="#58-Redis删除策略" class="headerlink" title="#58 Redis删除策略"></a>#58 Redis删除策略</h3><p>redis使用定期删除+惰性删除（也就是触发式删除）</p>
<h3 id="59-Redis高性能"><a href="#59-Redis高性能" class="headerlink" title="#59 Redis高性能"></a>#59 Redis高性能</h3><p>redis通过io多路复用实现高性能</p>
<h3 id="60-io多路复用"><a href="#60-io多路复用" class="headerlink" title="#60 io多路复用"></a>#60 io多路复用</h3><p>io多路复用模块监听多个FD当事件来临回调FD绑定处理器处理</p>
<p>epoll 比 select的优势在于不用遍历fd数组，。</p>
<p>在 epoll_wait 函数返回时会提供一个 epoll_event 数组：其中保存了事件以及发生事件的fd </p>
<h3 id="61-Redis哨兵"><a href="#61-Redis哨兵" class="headerlink" title="#61 Redis哨兵"></a>#61 Redis哨兵</h3><p>redis通过哨兵模式实现高可用</p>
<p>Redis的哨兵是一种高可用方案，若干互备的哨兵节点负责接收客户端请求，将请求路由到Master，并且在出现Master挂了的情况下进行重新选主操作</p>
<p><img src="/notes/index/61-1.jpg" alt="图61-1"></p>
<h3 id="62-Redis-分布式锁-setNX"><a href="#62-Redis-分布式锁-setNX" class="headerlink" title="#62 Redis 分布式锁 setNX"></a>#62 Redis 分布式锁 setNX</h3><p>setNX指令可实现分布式锁</p>
<p>Redis分布式锁可能遇到的三个问题：</p>
<p>1.锁超时时间设置的原子性，使用setnx和expire连用来解决</p>
<p>2.如何防止锁被其他进程释放：在setnx时给value设置一个id值，下一次设置时先比对id是否相等，相等才获得锁成功（比对然后设置这是一个典型的check-then-act竞态条件，需要用lua来保证两个操作的原子性和隔离性）</p>
<p>3.如何保证可重入：使用加锁前先判断是否已setnx过，set过就直接获取的办法（具体点用ThreadLocal来存储计数量来实现）</p>
<p>Redis实现分布式锁的可重入可以 ThreadLocal记数的办法，在真正操作setnx前看看ThreadLocal里有没有记数值，有就说明之前已经操作过setnx里就不用在操作了直接返回可获得锁就好了（再操作Redis会报错，因为已经有止里，而setnx是没有值才能set成功）</p>
<p>RedLock算法实现分布式锁：对多个节点setnx 过半成功则为成功</p>
<h3 id="63-synchronized-锁升级"><a href="#63-synchronized-锁升级" class="headerlink" title="#63 synchronized 锁升级"></a>#63 synchronized 锁升级</h3><p>synchronized 偏向锁 在对象头中用CAS记录线程ID 若有竞争升级为轻量锁 轻量锁自旋获得锁 自旋次数到阈值或又多了一个线程竞争那么升级为重量锁</p>
<h3 id="64-Kafka"><a href="#64-Kafka" class="headerlink" title="#64 Kafka"></a>#64 Kafka</h3><p>Kafka单分区有序</p>
<p>Kafka将主题分为若干分区，在每个分区内，按时间排序（offset）并保证客户端只有一个线程消费一个分区，这样多个线程消费多个分区，保证消息有序同时还实现了负载均衡</p>
<p>Kafka是用的拉（Pull）模型，由消费者自行记录消费状态 由watermark控制能消费的偏移量的阈值</p>
<h3 id="65-Xmn"><a href="#65-Xmn" class="headerlink" title="#65 Xmn"></a>#65 Xmn</h3><p>Xmn一般设置为整个堆空间的1/3或1/4</p>
<h3 id="66-模拟内存分配"><a href="#66-模拟内存分配" class="headerlink" title="#66 模拟内存分配"></a>#66 模拟内存分配</h3><p>可用新建byte数组的方式模拟内存分配</p>
<h3 id="67-CardTable"><a href="#67-CardTable" class="headerlink" title="#67 CardTable"></a>#67 CardTable</h3><p>CardTable用来记录老年代某个区域是否持有新生代引用，这样新生代在GC时不必遍历老年代查看是否持有引用而只需先看卡表中是否为1，是才需要扫描对应的老年代</p>
<p>卡表里实际上就是存的一堆flag</p>
<h3 id="68-水平分表"><a href="#68-水平分表" class="headerlink" title="#68 水平分表"></a>#68 水平分表</h3><p>水平分表用字段作为依据分 如取模</p>
<h3 id="69-spring-Bean-生命周期"><a href="#69-spring-Bean-生命周期" class="headerlink" title="#69 spring Bean 生命周期"></a>#69 spring Bean 生命周期</h3><p><img src="/notes/index/69-1.png" alt="图69-1"></p>
<h3 id="70-zset"><a href="#70-zset" class="headerlink" title="#70 zset"></a>#70 zset</h3><p>zset计算排行排</p>
<h3 id="71-mvcc"><a href="#71-mvcc" class="headerlink" title="#71 mvcc"></a>#71 mvcc</h3><p>mvcc 读不加锁 读写不冲突</p>
<p>rc隔离和rr隔离级别通过mvcc来实现写-读或读-写操作之间不用加锁，rc隔离级别会在每次select前生成rearview，rr级别会在第一次select前生成rearview</p>
<p>readview包含当前所有事务id所形成的数组，当聚簇索引行当中trx_id小于这个数组中最小值的时候，说明此条记录已提交，那么对于readview可见，大于则不可见，若大小在这个数组上下界之间并且not in这个数组，则也可见</p>
<p>mvcc会在每次update操做时增加一个undo日志，每个undo日志都有一个roll_pointer指向上一次的undo日志，这样每次update操作的undo日志会串成一个链，称为版本链，ReadView会沿着版本链一种回溯，每个链节上都执行tr_id比对从而确定此链节更新对于ReadView中的事物是否可见</p>
<p><a href="https://juejin.im/post/5c9b1b7df265da60e21c0b57#heading-10" target="_blank" rel="noopener">MySQL事务隔离级别和MVCC</a></p>
<h3 id="72-MySQL事务隔离级别"><a href="#72-MySQL事务隔离级别" class="headerlink" title="#72 MySQL事务隔离级别"></a>#72 MySQL事务隔离级别</h3><p>脏读：一个事务读到了另一个事务还未提交的数据 见于read uncommited</p>
<p>不可重复读：一个事务中两次相同的查询得到不同的结果（另一个事务在两次读之间提交事务修改了数据） 见于 read commited</p>
<p>幻读：见于 用读来确认是否已存在，不存在才能插入然后再执行插入 的情况 事务1查询是否能插入后事务2完成了插入然后事务1插入时发现已存在了就不能插入了，但实际上事务上一步时得到的结果是能插入的 这样就造成了事物第一步得到的结论是幻像的结果 也就是所谓幻读</p>
<p>幻读：在事务未完成前另一个事务又新增了一些记录</p>
<p>理论上 repeatable read 不能防止幻读 但是？</p>
<h3 id="73"><a href="#73" class="headerlink" title="#73"></a>#73</h3><p><a href="https://juejin.im/post/5d905039e51d45782d053ca3" target="_blank" rel="noopener">https://juejin.im/post/5d905039e51d45782d053ca3</a> 极为靠后的分页 大量数据后的分页 可用 定位偏移位置的 id，然后往后查询的办法解决</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> orders_history <span class="keyword">where</span> <span class="keyword">type</span>=<span class="number">8</span> <span class="keyword">limit</span> <span class="number">100000</span>,<span class="number">1</span>; <span class="keyword">select</span> * <span class="keyword">from</span> orders_history <span class="keyword">where</span> <span class="keyword">type</span>=<span class="number">8</span> <span class="keyword">and</span> <span class="keyword">id</span>&gt;=(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> orders_history <span class="keyword">where</span> <span class="keyword">type</span>=<span class="number">8</span> <span class="keyword">limit</span> <span class="number">100000</span>,<span class="number">1</span>) <span class="keyword">limit</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>或者从业务上优化 避免掉这种情况</p>
<h3 id="74-mvcc原理"><a href="#74-mvcc原理" class="headerlink" title="#74 mvcc原理"></a>#74 mvcc原理</h3><p>mvcc ：聚簇索引包含两个隐藏列 trx_id 每次对聚簇索引修改都会将事务id赋给trx_id，roll_pointer 每次聚簇索引改动后都会将 undo日志中对应内容的指针赋给roll_pointer</p>
<p>ReadView 包含了当前所有事务的id的列表m_ids 然后如果trx_id 小于m_ids中最小值则说明对应事务在生成ReadView之前已经提交 那么该版本就可以被当前的m_ids对应对事物们可见</p>
<p>如果trx_id大于m_ids最大值 则说明 trx_id对应的事物在 ReadView创建之后 那么m_ids对应的事物们不能访问此版本</p>
<p>如果trx_id大小介于m_ids的最小值和最大值之间同时不与m_ids中任何一个数相等则说明生成ReadView时事物已提交则可以访问</p>
<p>如果大小介于之间并且存在等值则说明此事物还活跃则不可访问</p>
<p>某个trx_id对m_ids不可访问就依次沿版本链找下一版本的trx_id重复以上过程直到找不到trx_id为止</p>
<p><a href="https://juejin.im/post/5c9b1b7df265da60e21c0b57#heading-10" target="_blank" rel="noopener">MySQL事务隔离级别和MVCC</a></p>
<h3 id="75-CountDownLatch"><a href="#75-CountDownLatch" class="headerlink" title="#75 CountDownLatch"></a>#75 CountDownLatch</h3><p>new CountDownLatch(10) 设置 AQS state 为 10</p>
<p>count() ：</p>
<ol>
<li>用 CAS 给 state进行 state-1 操作，减完后判断如果为 0 返回true</li>
<li>如果上一步返回了 true 那么就调用 AQS 的doReleaseShared()流程 也就是唤醒等待队列头节点的流程</li>
</ol>
<p>在需要等待的线程中await() 这个会调用 AQS 的 doAcquireSharedInterruptibly()<br>AQS 的 doAcquireSharedInterruptibly() 会判断tryAcquireShared(1) 的返回值，如果大于0就让等待的出队 如果小于0则让其入等待队列队 </p>
<p>而 CountDownLatch 的tryAcquireShared(1)返回的是 -1 是小于0的，也就是上一步中会进入等待的的分支，因此当前调用的线程会等待</p>
<h3 id="76-TCP三次握手"><a href="#76-TCP三次握手" class="headerlink" title="#76 TCP三次握手"></a>#76 TCP三次握手</h3><p>三次握手：<br>1 客户端 sync<br>2 服务端 ack + sync<br>3 客户端 ack</p>
<h3 id="77-TCP四次挥手"><a href="#77-TCP四次挥手" class="headerlink" title="#77 TCP四次挥手"></a>#77 TCP四次挥手</h3><p>四次挥手：客户端和服务端均可为主动方</p>
<p>1 主动方 fin + ack<br>2 被动方 ack<br>3 被动方 fin<br>4 主动方 ack</p>
<p>主动方最后收到被动方的fin后需要time_wait一下（一般4分种）然后才close</p>
<h3 id="78-滑动窗口"><a href="#78-滑动窗口" class="headerlink" title="#78 滑动窗口"></a>#78 滑动窗口</h3><p>滑动窗口：<br>要是一个包一个包的发送-确认 发送-确认 效率太低，因此需要一次性发多个包</p>
<p>缓存大小就是窗口 一次性发出去多个包 收到第一个 ack 就将缓存第一个值赶出去，同时最后一个值后面的值进来一个 一点一点往后滑动着重复这个过程：走一个来一个 走一个来一个。。。 就像是拉链一样 拉链能容纳的拉齿数量就是窗口大小 拉链拉过去就是出一个进一个</p>
<p>如果拉链头那个没收到ack（也就是超时）那么就需要重传，只有他收到ack才能继续往后拉</p>
<p>也就近似类似于拉拉链卡在某个齿了那么就再试一下（超时重传）</p>
<p><a href="https://juejin.im/post/5c9f1dd651882567b4339bce" target="_blank" rel="noopener">一篇带你读懂TCP之“滑动窗口”协议</a></p>
<h3 id="79-netty线程模型"><a href="#79-netty线程模型" class="headerlink" title="#79 netty线程模型"></a>#79 netty线程模型</h3><p>netty线程模型：同时支持 Reactor单线程 Reactor多线程 主从Reactor多线程</p>
<p><img src="/notes/index/79-1.jpg" alt="图79-1"></p>
<p>client -&gt; Reactor Thread(内部含有Dispatcher Acceptor接收TCP连接请求 链路建成后通过Dispatcher把ByteBuffer派发到Handler</p>
<h3 id="80-Reactor-模型"><a href="#80-Reactor-模型" class="headerlink" title="#80 Reactor 模型"></a>#80 Reactor 模型</h3><p>Acceptor相当于店小二招呼客人建立好菜单 然后发给厨师让他们处理菜单上的请求</p>
<p>Reactor单线程：一个店小二一个厨师</p>
<p>Reactor多线程：一个店小二多个厨师</p>
<p>Reactor主从多线程：一个总店小二发派多个店小二，然后店小二们发派多个厨师</p>
<h3 id="81-netty-handler无锁设计"><a href="#81-netty-handler无锁设计" class="headerlink" title="#81 netty handler无锁设计"></a>#81 netty handler无锁设计</h3><p>netty handler处理时不切换线程 这样不需要加锁 不存在切换成本 类似于一道菜从头到尾只有一个厨师负责做</p>
<h3 id="82-粘包拆包"><a href="#82-粘包拆包" class="headerlink" title="#82 粘包拆包"></a>#82 粘包拆包</h3><p>TCP粘包：收到多个包黏在一起</p>
<p>TCP拆包：一个包被分为两部分 一次收到一部分</p>
<p>解决方案：在上层协议栈解决</p>
<p>1 消息定长</p>
<p>2 包尾分隔符</p>
<p>3 分为消息头和消息体 在消息头中包含消息总长度</p>
<p>netty使用编/解码器解决拆包黏包</p>
<h3 id="83-Linux-io模型"><a href="#83-Linux-io模型" class="headerlink" title="#83 Linux io模型"></a>#83 Linux io模型</h3><p>Linux io模型：</p>
<p>阻塞io： 进程调用recvfrom后一直等待数据包到达应用进程缓冲区或返回错误后再执行</p>
<p>非阻塞io：recvfrom没数据返回的话之间返回错误让进程继续 然后轮询看看是否有数据到来</p>
<p>io多路复用：select或epoll 进程将fd传给select或poll系统调用阻塞在select/poll上select/poll替进程（也就是不用像普通非阻塞io那样进程自己轮询了 而是让帮手轮询）轮询看看是否有数据来</p>
<p>epoll：比select队列基于事件的处理 不必每次完整轮询一遍 而是有就绪的就会入一个数组 然后回调告知有数据</p>
<p>类比：</p>
<p>阻塞io：客人自己点完菜只能傻等着菜来别的什么也不能做</p>
<p>非阻塞io：客人点完菜需要不断询问厨师做好了没有直到菜来</p>
<p>select：客人点完菜自己干点别的事，店小二不断问厨师菜好了没有，好了就端过来给客人</p>
<p>epoll：客人点完菜自己干点别的事，厨师做好菜了会放到一个固定的取菜窗口并按铃告诉店小二过来拿菜，店小二拿了菜给客人</p>
<p>epoll通过mmap加速了内存从内核空间到用户空间的拷贝</p>
<p>epoll不受fd数量限制</p>
<p>epoll不会因为fd数量增加而效率线性下降</p>
<h3 id="84-netty零拷贝"><a href="#84-netty零拷贝" class="headerlink" title="#84 netty零拷贝"></a>#84 netty零拷贝</h3><p>netty零拷贝：通过CompositeByteBuf等机制实现数据不需频繁的复制粘贴</p>
<h3 id="85-一致性Hash"><a href="#85-一致性Hash" class="headerlink" title="#85 一致性Hash"></a>#85 一致性Hash</h3><p>负载均衡时用普通的 hash 算法比如 对集群节点数取模 当集群大小发生变化时，hash需要重新计算，否则原hash可能无法命中</p>
<p>一致性 hash 做法是将 hash 范围定位一个有上限的范围区间</p>
<p>然后将节点进行 hash 到这个区间内</p>
<p>数据的位置也是做 hash 然后看看数据的hash离哪个节点的hash近，就归属于哪个节点（小蝌蚪找妈妈）当某个节点掉线从范围内摘除，其影响到的是hash值比起小的最接近的又比另一个比其小节点大的这一批数据，而不是全部数据，这样就降低了rehash的成本</p>
<p>一致性hash如果节点少的可能造成数据倾斜 解决办法是一个节点生成多个hash 也就是一个节点当作n个节点</p>
<h3 id="86-mvcc-ReadView"><a href="#86-mvcc-ReadView" class="headerlink" title="#86 mvcc ReadView"></a>#86 mvcc ReadView</h3><p>RR下，事务在第一个Read操作时，会建立Read View<br>RC下，事务在每次Read操作时，都会建立Read View</p>
<p><a href="https://blog.csdn.net/z50L2O08e2u4afToR9A/article/details/82393019" target="_blank" rel="noopener">InnoDB，快照读，在RR和RC下有何差异？</a></p>
<p>可重复读(Repeated Read, RR)<br>这是InnoDB默认的隔离级别，在RR下：</p>
<p>普通的select使用快照读(snapshot read)，这是一种不加锁的一致性读(Consistent Nonlocking Read)，底层使用MVCC来实现</p>
<p><a href="https://blog.csdn.net/z50L2O08e2u4afToR9A/article/details/82186189" target="_blank" rel="noopener">4种事务的隔离级别，InnoDB如何巧妙实现？</a></p>
<p><a href="https://blog.csdn.net/z50L2O08e2u4afToR9A/article/details/82027049" target="_blank" rel="noopener">数据库索引，到底是什么做的？</a></p>
<h3 id="87-旁路缓存解决数据库和缓存双写一致性"><a href="#87-旁路缓存解决数据库和缓存双写一致性" class="headerlink" title="#87 旁路缓存解决数据库和缓存双写一致性"></a>#87 旁路缓存解决数据库和缓存双写一致性</h3><p>旁路缓存</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961349&idx=1&sn=59119a223f62d3740712ca0f62064f04&chksm=bd2d0dd98a5a84cf94d75e8e84ad7fe35fd040dfe02fe49db8dd64127c548aa194d2d169e149&scene=21#wechat_redirect" target="_blank" rel="noopener">Cache Aside Pattern</a></p>
<p>对于读请求</p>
<ul>
<li>先读cache，再读db</li>
<li>如果，cache hit，则直接返回数据</li>
<li>如果，cache miss，则访问db，并将数据set回缓存</li>
</ul>
<p>对于写请求</p>
<ul>
<li>淘汰缓存，而不是更新缓存</li>
<li>先操作数据库，再淘汰缓存</li>
</ul>
<p>Cache Aside Pattern为什么建议淘汰缓存，而不是更新缓存？</p>
<p>答：如果更新缓存，在并发写时，可能出现数据不一致。所以，Cache Aside Pattern建议，delete缓存，而不是set缓存。</p>
<h3 id="88-主线程"><a href="#88-主线程" class="headerlink" title="#88 主线程"></a>#88 主线程</h3><p>是主线程执行main，而不是main创建主线程</p>
<h3 id="89-线程状态转换"><a href="#89-线程状态转换" class="headerlink" title="#89 线程状态转换"></a>#89 线程状态转换</h3><p>线程状态转换：创建好线程实例还未调用start：NEW</p>
<p>调用start后：Runnable，这里面分为两种情况，被调度器调度到（不可控，但可建议）：Running，调用yield：Ready</p>
<p>执行阻塞操作，也就是进入同步队列后：Blocked，出了同步队列并争抢到了锁后：Runnable</p>
<p>调用Object.wait后，也就是释放锁进入等待队列后：Waiting，notify或notifyall，也就是出了等待队列进入同步队列，或被中断后：Runnable</p>
<p>调用wait(long)后，也就是有限期在等待队列中等待：Timed_waiting，等待到了时间（超时）后：Runnable</p>
<p>run正常返回或抛异常后：Terminated</p>
<p>注意：ready和running在Thread.getState的返回中并不存在</p>
<p><img src="/notes/index/89-1.jpg" alt="图89-1"></p>
<h3 id="90-Thread-sleep"><a href="#90-Thread-sleep" class="headerlink" title="#90 Thread.sleep"></a>#90 Thread.sleep</h3><p>不释放锁</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNDUwOTc0Nw==&mid=2247483893&idx=1&sn=2cbbbf87d934b3f017627e55b8d35493&chksm=f9459f29ce32163f32eb0eae2fcf638a46201e3435221dac55486c4f5a5e7aa706269e3b07b8&mpshare=1&scene=1&srcid=10079GuGvknljHAourvGOrbm&sharer_sharetime=1570414594958&sharer_shareid=5549e44ad88a51bc740c6fdae62c8748#rd" target="_blank" rel="noopener">Java中Thread.sleep源码分析</a></p>
<h3 id="91"><a href="#91" class="headerlink" title="#91"></a>#91</h3><p><a href="https://www.cnblogs.com/dk666/p/7341020.html" target="_blank" rel="noopener">C线程同步</a></p>
<blockquote>
<p>Thread 设计模式1<br>在程序中有不同的方法使用线程,这里讨论 3 种线程设计模式,没有哪一种模式最好,每种模式都有相应适合的应用场合.</p>
<p>Boss/worker(Thread pool)</p>
</blockquote>
<p><img src="/notes/index/91-1.gif" alt="图91-1"></p>
<blockquote>
<p>如上图,一个 Boss 线程创建其他 Worker 线程,并给它们分配任务,必要的话,并等待其他线程运行结束.通常 Boss 线程会在初始建立 Thread Pool 来为之后分配.尽管线程是轻量级的,但是创建它们仍是有开销的.</p>
<p>Peer(Workcrew)</p>
</blockquote>
<p><img src="/notes/index/91-2.gif" alt="图91-2"></p>
<blockquote>
<p>Peer 模式又叫做 workcrew 模式,一个 thread 创建其他 peer threads 当程序开始,但是如上图,与 Boss/worker 模式不同,这个 thread 之后也变成 peer thread 去处理自己的任务.</p>
<p>Pipeline</p>
</blockquote>
<p><img src="/notes/index/91-3.gif" alt="图91-3"></p>
<blockquote>
<p>Pipeline 模式假定:</p>
<p>一串连续长输入.<br>每个输入经过一连串的子操作(熟知为 stages 或 fliers).<br>每个处理 stage 能一次处理个不同的输入.<br>如上图, Pipeline 就像流水线一般,每个 thread 是一个长链中的一部分.每个 thread 处理由之前 thread 过的数据.</p>
</blockquote>
<h3 id="92-线程同步原语"><a href="#92-线程同步原语" class="headerlink" title="#92 线程同步原语"></a>#92 线程同步原语</h3><blockquote>
<p>线程同步原语<br>如上线程中的定义,线程们共享进程中的全局变量或资源,它们可以并行同时对这些数据和资源操作,如果没有一定的机制协调它们,那么数据或资源将处于一个不安全状态,引起诸如如下的一些问题:</p>
<p>Race condition发生于不能决定行为的结果因为线程们操作共享数据或资源没有遵循一定的同步规则.<br>ABA problem发生于一个地方被读取两次,都读到相同的值,’值是相同的’被用来说明’没有东西被改变’.但是,另外一个线程能在这两次读取中间执行操作并修改这个位置的值,然后做一些其他操作,最后把这个值改回去,以致愚弄第一个线程让它认为’没有东西被改变’,即使第二个线程的操作已经破坏了这个假设.<br>所以我们需要如下的一些线程同步原语满足不同的线程间同步需求.</p>
<p>Mutex<br>Mutex 又被称为 Lock,所以它就像一把 Lock,一个线程 Lock 住一段资源,那么其他线程就不能去访问那段资源,只有等到第一个线程 Unlock 那么资源,它才能访问.</p>
<p>在 Lock 和 Unlock 之间的代码,一般被称为 critical section.</p>
<p>Mutex 也包含一些复杂的类型,如下:</p>
<p>Recursive: 允许占有锁的那一个线程再次获取同样的锁,对递归算法是必要的.<br>Queuing: 使得 公平 的获取锁,通过 FIFO 排序锁的请求.<br>Reader/Writer(rwlock): 允许多个 reader 同时获取锁,如果有 reader 占用锁,writer 只有等到 reader 释放锁.<br>Scoped: RAII 类型定义的锁获取和解锁.<br>但 Mutex 也会引入其他一些问题,如deadlock 和 priority inversion.</p>
<p>在 Blog 中之前浅谈 Mutex (Lock)中可以看到更多有关 Mutex 的性能和开销分析,并如何实现一个轻量级的 Mutex.</p>
<p>Join<br>线程 join 机制能让一个线程 join 到另外一个线程中.比如一个子线程 join 回主线程,那么主线程就会等待子线程运行结束.从而达到线程间等待的同步机制.</p>
<p>Condition Variable<br>Condition variable 允许线程同步到某个共享资源的某个值.</p>
<p>比如,程序有一个计数器,当计数器达到某一个值时去激活某个线程运行.把计数器当成一个 Condition variable.这个线程可以等待这个 Condition variable,其他 active 线程操作完这个 Condition variable,可以通过 signal/broadcast 去唤醒那些等待这个 Condition variable 睡眠的线程.</p>
<p>Barrier<br>Barrier 是一种能让一系列线程在某个点得到同步的方法,通过让参与 barrier 的线程等待直到所有参与线程都调用了这个 barrier 函数.本质上就是,阻塞所有参与 barrier 的线程直到最慢的那个参与线程调用 barrier.</p>
<p>Spinlock<br>Spinlock 与 mutex 类似,是种锁,但当获取锁失败时,spinlock 不会让线程进入睡眠,而是不断 poll 去获取这个锁直到获取成功.更多Mutex 与 Spinlock 的区别.</p>
<p>Semaphore<br>当某些资源具有多个时,简单的 Mutex 不能满足,引入 Semphore,Semphore 可以根据资源个数初始化为任意值.当线程们占有所有资源,使得 Semphore 为 0,那么其他线程再获取资源只有等待.当 Semphore 值只能是 1 或 0 时,它相当于简单的 Mutex.</p>
</blockquote>
<h3 id="93-ArrayList的remove"><a href="#93-ArrayList的remove" class="headerlink" title="#93 ArrayList的remove"></a>#93 ArrayList的remove</h3><p>ArrayList在自身的remove中会检测modCount和expectdModCount是否相等，不想等会抛异常，自身的remove并未进行调整使其相等，因此会抛出异常，而iterator的remove则会进行调整使两个值相等，因此不会异常</p>
<h3 id="94-ConcurrentHashMap"><a href="#94-ConcurrentHashMap" class="headerlink" title="#94 ConcurrentHashMap"></a>#94 ConcurrentHashMap</h3><p>ConcurrentHashMap：在内部维持一个 segments 每个 segment 中是 HashEntry 形成的数组，也就是table 在加锁时，各自segment持有自己各自的锁，在操作同一segment时才会出现同步，操作不同segment由于锁不同，因此不存在同步，当segment分的足够细的时候，同步就很少了</p>
<p>1.8的ConcurrentHashMap放弃了segments的设计，使用CAS和synchronized来实现并发更新的控制,结构与HashMap相同，都是table里每个元素为链表或树。</p>
<p>在初始化table时通过循环CAS设置一个状态量sizeCtl是否成功，来分成两个执行路径，成功设置了sizeCtl的线程有权初始化table，而未成功的则Thread.yield来让出被调度到的权利，从而保证保证只有一个线程在进行初始化table的操作</p>
<p>当进行更新操作（put）时：当插入元素时发现table对应元素为null时，也就是没产生hash冲突，那么就使用循环CAS尝试在此位置插入，如果发现已有元素了，也就是已经hash冲突了，那么就用synchronized对插入进行同步</p>
<p>由于ConcurrentHashMap中value不允许null值存在，因此在get中利用了这一点，在获得value时首先尝试不加锁读，如果发现获得的值为null那么就说明发生了冲排序，则就升级为加锁读</p>
<p>ConcurrentHashMap的每一个segment中有一个记录此segment的table里包含多少HashEntry的属性count，而不是在整个ConcurrentHashMap中记录了count，这样避免了对这个频繁更新值进行全局加锁</p>
<p><a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html" target="_blank" rel="noopener">探索 ConcurrentHashMap 高并发性的实现机制</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">V get(Object key, int hash) &#123; </span><br><span class="line">    if(count != 0) &#123;       // 首先读 count 变量</span><br><span class="line">        HashEntry&lt;K,V&gt; e = getFirst(hash); </span><br><span class="line">        while(e != null) &#123; </span><br><span class="line">            if(e.hash == hash &amp;&amp; key.equals(e.key)) &#123; </span><br><span class="line">                V v = e.value; </span><br><span class="line">                if(v != null)            </span><br><span class="line">                    return v; </span><br><span class="line">                // 如果读到 value 域为 null，说明发生了重排序，加锁后重新读取</span><br><span class="line">                return readValueUnderLock(e); </span><br><span class="line">            &#125; </span><br><span class="line">            e = e.next; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="95-MySQL主从同步"><a href="#95-MySQL主从同步" class="headerlink" title="#95 MySQL主从同步"></a>#95 MySQL主从同步</h3><p>mysql主从同步：主端生成binlog 从端io线程将binlog复制为relaylog然后另一个线程读出relaylog并执行</p>
<p>解决主从同步延迟：开启并行复制；分库；延迟查（业务上给写完和可读直接留一些时间）；直接强制从主库查</p>
<h3 id="96-线程池"><a href="#96-线程池" class="headerlink" title="#96 线程池"></a>#96 线程池</h3><p>线程池：当提交任务时如果当前任务数小于corPoolSize那么不管核心线程们是否空闲，一定会创建线程并执行任务，如果当前线程数大于corePoolSize了，那么再来任务就尝试入队，如果队列满了或因为其他原因入队失败并且当前线程数小于maxPoolSize则创建非核心线程，如果已经大于maxPoolSize了则走拒绝策略，拒绝策略包括直接抛异常、放弃当前入队任务、放弃等待最久任务、调用者线程执行任务</p>
<h3 id="97-spring-boot自动配置实现"><a href="#97-spring-boot自动配置实现" class="headerlink" title="#97 spring-boot自动配置实现"></a>#97 spring-boot自动配置实现</h3><p>spring-boot通过@EnableAutoConfiguration实现自动配置：具体的，在@EnableAutoConfiguration中@Import了EnableAutoConfigurationImportSelector然后其使用SpringFactoryLoader根据spring.properties中的配置反射实例化指定的标注了@Configuration的配置类，然后加载到IoC容器</p>
<h3 id="98-G1-收集可能有4个阶段"><a href="#98-G1-收集可能有4个阶段" class="headerlink" title="#98 G1 收集可能有4个阶段"></a>#98 G1 收集可能有4个阶段</h3><p>G1 收集可能有4个阶段：</p>
<ul>
<li>新生代收集</li>
<li>并发标记周期</li>
<li>混合收集</li>
<li>如果需要进行FullGC</li>
</ul>
<p>G1的并发标记周期：</p>
<ul>
<li>初始标记，初始标记必然伴随一次新生代收集 STW</li>
<li>根区域扫描，根区域扫描会由survivor区可达的老年代区 并记录这些可达对象</li>
<li>并发标记 标记堆中所有存活对象</li>
<li>重新标记 STW</li>
<li>独占清理：计算各区 存活对象和GC回收比 然后进行排序 同时还会更新记忆集 Remembered Set（记忆集）</li>
</ul>
<p>以上整个并发标记周期后 会标示出垃圾比例高的区，这些区会被放入 Collection Sets</p>
<p>混合回收阶段：</p>
<p>并发标记周期中标记出来的垃圾比例高的区会被回收，混合回收会阶段也会进行新生代收集，注意 被清理的区中的存活对象会被复制到其他区以减少内存碎片，</p>
<p>混合GC 并发标记周期 年轻代GC 会循环进行</p>
<p><img src="/notes/index/98-1.jpg" alt="图98-1"></p>
<p><img src="/notes/index/98-2.jpg" alt="图98-2"></p>
<p>如果混合GC发生时空间不足或者新生代GC时surviver区和老年代区无法容纳幸存对象 都会导致FullGC</p>
<h3 id="99-CMS的步骤"><a href="#99-CMS的步骤" class="headerlink" title="#99 CMS的步骤"></a>#99 CMS的步骤</h3><p>CMS的步骤：</p>
<ul>
<li>初始标记（标记根对象）STW</li>
<li>并发标记（标记所有对象）</li>
<li>预清理（可降低停顿时间）</li>
<li>重新标记（修正并发标记阶段的标记）STW</li>
<li>并发清理</li>
<li>并发重置</li>
</ul>
<p>为了保证能和工作线程并发，CMS不会等到快要耗尽才触发 而是留较大剩余空间时就触发（G1也是同理）,默认68%时触发 可调,CMS可配置为若干次回收后进行一次内存压缩以解决内存碎片</p>
<h3 id="100-内在逻辑共性"><a href="#100-内在逻辑共性" class="headerlink" title="#100 内在逻辑共性"></a>#100 内在逻辑共性</h3><p>了解原理可用帮助理解技术的内在逻辑共性：比如CopyOnWriteArrayList 内部实现机制类比与MySQL的快照度</p>
<p>Redis的zset和Jdk的ConcurrentSkipListMap 内部都利用了 SkipList 来实现</p>
<p>SkipList使用在数据上（链表实现）添加若干层索引的方式来达到排序二叉树的同等效果</p>
<p>还可继续发散 将特定技术领域的内在逻辑与其他领域的内在逻辑建立共性,比如生活常识:</p>
<p>厕所排队和同步队列</p>
<p>餐馆点菜和io多路复用</p>
<h3 id="101-什么是线程安全"><a href="#101-什么是线程安全" class="headerlink" title="#101 什么是线程安全"></a>#101 什么是线程安全</h3><p>什么是线程安全：可以先考虑什么是线程不安全，它的反面就是线程安全</p>
<p>某逻辑在竞态条件下由于线程调度的不确定性导致了结果的不可预测以及不确定性就是线程不安全</p>
<h3 id="102-竞态条件"><a href="#102-竞态条件" class="headerlink" title="#102 竞态条件"></a>#102 竞态条件</h3><p>竞态条件：</p>
<ul>
<li>check-then-act</li>
<li>读-改-写</li>
</ul>
<p>可以用 加锁、循环CAS或写时复制 来确保可预测</p>
<h3 id="103-任务的抽象"><a href="#103-任务的抽象" class="headerlink" title="#103 任务的抽象"></a>#103 任务的抽象</h3><p>Runnable 只是任务的抽象，而线程则是执行的抽象，是两个不同层面的概念 不可混为一谈</p>
<h3 id="104-netty的线程模型"><a href="#104-netty的线程模型" class="headerlink" title="#104 netty的线程模型"></a>#104 netty的线程模型</h3><p>netty的线程模型：事件循环</p>
<p>一个事件循环（EventLoop）将永远只有某一个线程驱动 不会发生线程切换</p>
<p>一个事件循环可能服务多个Channel（Channel是io部分的抽象）</p>
<p>也就是说一个事件循环可以服务多个io 但是就某一个io来说其只会被一个事件循环服务</p>
<p>类似于办事窗口：某个窗口只有一个工作人员，但是有多个顾客 一般一个事分为多分步骤 办事员每次处理一个人的一个步骤，当这个步骤需要顾客填写资料时这个顾客去一边填写，此时办事员给下一个顾客办理，原来那个去填写资料的顾客自东排到这个办事队列的尾部 对于某个顾客，从其开始办事到结束只允许对应一个办事员，而在办事员看来，他是依次循环着服务多个客户</p>
<p>同时，一个办事大厅里有多个办事员，也有多个办事顾客队列</p>
<p>netty分为io处理部分和执行处理部分 也就是io模型（具体的是io多路复用）和线程模型（事件循环）或者说是事件循环组</p>
<p>netty线程模型之所以设计成某个客户自始至终对应一个办事员这样是为了消除上下文切换的成本</p>
<p>类似于你办一个事，一个办事员办了A步骤，假如你去另一个办事员那，那个办事员就需要你告诉他现在办倒那个步骤了，然后需要提交一堆材料，你每次换人都需要记住自己办到哪个步骤了，还得把材料拿着到处跑，假如自始至终是一个人，那么你只需第一次把材料给他，然后他会记住你办到哪个步骤了，不需要额外记忆，也不需要拿着材料来回跑</p>
<h3 id="105-netty的组件"><a href="#105-netty的组件" class="headerlink" title="#105 netty的组件"></a>#105 netty的组件</h3><p>netty的组件：io处理组件和执行组件</p>
<p>io处理组件：Channel 代表某一次io，类似于jdbc中的Connection的概念；在Channel的生命周期中会有很多事件产生（事件是NIO 中Selector逻辑的高层次封装）这些事件交由ChannelHandler处理，ChannelHandler是编程人员用来干预Channel的入口</p>
<p>执行组件：事件循环，一个Channel整个生命周期一直由同一个事件循环来执行</p>
<p>EventLoop是对于Thread的高级抽象，一个EventLoop整个生命周期只对应一个线程 一对一</p>
<p>EventLoopGroup对应于线程池</p>
<p>编解码器：用于数据的格式处理，比如转换，界定长度等（Socket的数据皆是二进制数据）</p>
<p>Bootstrap：整个服务器抽象或客户端抽象的入口</p>
<p>ByteBuf是对于数据自身的封装</p>
<p>Handler：链上对应的任务</p>
<p>HandlerContext：链的某一环</p>
<p>HandlerPipeline：用于将链穿起来的工厂</p>
<p>FileRegion 实现零拷贝</p>
<h3 id="106-Selector"><a href="#106-Selector" class="headerlink" title="#106 Selector"></a>#106 Selector</h3><p>elector是NIO中最关键的API 他是事件模型的 用事件API来通知那些套接字可以已就绪可进行操作</p>
<p>Selector的使用方式：</p>
<ol>
<li>打开一个Selector</li>
<li>将Channel设置为非阻塞模式</li>
<li>将Channel注册到Selector</li>
<li>while(true)轮询select<br>4.1 如果select()返回0则进行下一轮<br>4.2 如果返回不是0则从Selector获得SelectorKey集合然后迭代这个集合，判断（四种）感兴趣的事件是否存在，并坐业务处理；处理完成后需要将处理过的当前SelectorKey从迭代器中移除，然后进入下轮迭代</li>
</ol>
<p>Channel对应于Socket</p>
<h3 id="107-netty使用引用计数"><a href="#107-netty使用引用计数" class="headerlink" title="#107 netty使用引用计数"></a>#107 netty使用引用计数</h3><p>netty使用引用计数来处理资源释放</p>
<h3 id="108-布隆过滤器"><a href="#108-布隆过滤器" class="headerlink" title="#108 布隆过滤器"></a>#108 布隆过滤器</h3><p>布隆过滤器大致原理：每一个key计算多个hash 再由每个计算出来的hash确定一个在桶中的index然后在相应index位置标记为1</p>
<p>在判断给定key是否存在于其中时，重复上面计算index的过程看看得到的index位是否都是1只有有一个不是1就不存在</p>
<p>实际上，即便都是1也有可能不存在，因为有可能恰好有另一个完全不同的key算出来的index和给定的key算出来的index完全重合</p>
<p>就像是两组完全不同的双色球组合却都中了一等奖一样，这种可能是存在的但是概率较低，因为只一个index碰上了比较容易，但是同时多个一块碰上就不容了</p>
<h3 id="109-HyperLogLog"><a href="#109-HyperLogLog" class="headerlink" title="#109 HyperLogLog"></a>#109 HyperLogLog</h3><p>HyperLogLog用于粗略记数</p>
<h3 id="110-Paxos协议"><a href="#110-Paxos协议" class="headerlink" title="#110 Paxos协议"></a>#110 Paxos协议</h3><p>Paxos协议简单理解：<br>两种角色：提案评审者 提案发布者</p>
<p>过程：分为两个阶段</p>
<p>第一阶段：提案预提交。多个提案发布者共同发布提案给多个评审者组成的评审委员会，评审委员会根据某个规则给这些提案进行编号，然后共同常试告知编号最大提案对应的提案发布者可以正式提交提案了</p>
<p>第二阶段：正式提交提案。提出最大编号的那个提案提交者收到半数以上的评审委员会委员返回“你可以正式提交提案了”的批复，则正式提交自己的提案</p>
<p>注意，在第一阶段和第二阶段进行的过程中，不不阻碍新的一轮第一阶段的发生</p>
<p>因此，接着说第二阶段：评审委员会接到提案者的正式提案后，先要看一下，现在有没有新的编号更大的提案，如果没有，则通过此正式提案，如果有，则不通过</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&mid=2651478500&idx=2&sn=66e3e836ff8b6f54c25ea77065fe37c6&chksm=bd25359b8a52bc8d590cb9ba6e7cb449c703e7f912dea7543d763e22ace6824565e7b293761a&mpshare=1&scene=1&srcid=1004r7qyrPOJXGWl7eEWgcHL&sharer_sharetime=1570151151896&sharer_shareid=5549e44ad88a51bc740c6fdae62c8748#rd" target="_blank" rel="noopener">zookeeper 入门系列 : paxos 协议</a></p>
<h3 id="111-ZooKeeper所有数据都在内存中"><a href="#111-ZooKeeper所有数据都在内存中" class="headerlink" title="#111 ZooKeeper所有数据都在内存中"></a>#111 ZooKeeper所有数据都在内存中</h3><p>ZooKeeper所有数据都在内存中，结构为树状结构名为ZNode Tree，每个斜杠分割中的都对应一个ZNode</p>
<p>ZNode分为两种：一种是持久节点（创建后除非主动删除否则一直存在）另一种是临时节点，客户端会话结束会销毁</p>
<h3 id="112-ZAB协议"><a href="#112-ZAB协议" class="headerlink" title="#112 ZAB协议"></a>#112 ZAB协议</h3><p>ZooKeeper使用ZAB协议</p>
<p>ZAB协议：ZooKeeper原子广播协议</p>
<p>可以大致分为两种情况的处理：正常情况和异常情况</p>
<p>两个角色：主（Leader）和从（Follower）</p>
<p>Leader只能存在一个，Follower可以多个，正常情况下只能由Leader接收事务请求（如果Follower接收了也需要转交给Leader）</p>
<p>Leader接收了事务请求（写请求）后，类似于Paxos协议，也需要经过两个阶段：第一阶段预提议：Leader将事务提交封装为提案交由各个Follower 等有过半的Follower返回通过预提案了就进入第二阶段：Leader告诉所有Follower真正提交事务</p>
<p>异常情况：当Leader挂掉或不存在半数Follower能与Leader正常通信就进入异常情况的处理。</p>
<p>异常情况处理过程：首先ZAB协议需要保证异常情况出现之前那些在正常情况下进入第二阶段的事务能被所有Follower提交，或者，如果第二阶段明确指明需要忽略这些事务的提交的话则所有Fellower都要忽略事务的提交</p>
<p>为了满足上述要求，ZAB协议会选出持有最大事务编号（在正常情况中Leader会为每一个事务编一个事务编号，也就是提案编号，所有提案按编号排序进行提案）的Follower为新的Leader</p>
<p>然后新的Leader会让所有Follower完成之前未完成的事务的提交或者回退事务。当提交或回退完成后整个系统又会回归到正常状态</p>
<h3 id="113-ZooKeeper实现分布式锁"><a href="#113-ZooKeeper实现分布式锁" class="headerlink" title="#113 ZooKeeper实现分布式锁"></a>#113 ZooKeeper实现分布式锁</h3><p>ZooKeeper实现分布式锁：在某一节点下常识创建（create）一个临时节点，在创建时，多个客户端同时创建只能有一个成功（这就模拟了共同争抢锁只能有一个成功的场景）</p>
<p>其他未成功的，在锁对应节点的父节点上注册对于锁节点的Watcher,用来监听锁对应节点的变化（比如节点销毁）,锁的释放：正常释放 锁使用者使用完后主动删除锁节点，这个逻辑可类比于synchronized内部的同步队列机制和显式锁Lock内部AQS的同步队列机制，逻辑是相通的，可互相借鉴</p>
<p>锁的释放：</p>
<ul>
<li>正常释放 锁使用者使用完后主动删除锁节点</li>
<li>异常释放：获得了锁的客户端出了异常，那么会导致和ZooKeeper会话的结束，然后临时节点会自行销毁</li>
</ul>
<h3 id="114-零拷贝"><a href="#114-零拷贝" class="headerlink" title="#114 零拷贝"></a>#114 零拷贝</h3><p>零拷贝：免除了 内核读缓冲到用户缓冲、用户缓冲到socket缓冲、socket缓冲到网卡的拷贝过程</p>
<p>直接从磁盘中读到内核读缓冲，然后再由内核读缓冲到网卡</p>
<h3 id="115-StringBuilder-为什么线程不安全"><a href="#115-StringBuilder-为什么线程不安全" class="headerlink" title="#115 StringBuilder 为什么线程不安全"></a>#115 StringBuilder 为什么线程不安全</h3><p>简单的说就是 append 中存在 读-改-写 竞态条件</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUxOTc4NjEyMw==&mid=2247484960&idx=1&sn=0eb882367ecf48ee0f74b3d139ac3e92&chksm=f9f51dc4ce8294d297fc4a86b4b0f12788f1fc1a5fa6f289efbb09153167d6a6bf10c9aca224&mpshare=1&scene=1&srcid=&sharer_sharetime=1570262032966&sharer_shareid=5549e44ad88a51bc740c6fdae62c8748#rd" target="_blank" rel="noopener">StringBuilder 为什么线程不安全？</a></p>
<h3 id="116-CAP"><a href="#116-CAP" class="headerlink" title="#116 CAP"></a>#116 CAP</h3><p>CAP：当网络发生分区时，有可能需要牺牲可用性来保全一致性，比如全体服务不可写；或者牺牲一致性（强一致）来保全可用性，比如Redis的主从同步不保证强一致同步，当某一节点挂掉然后重启后，并不会阻断其他同步的进行，此节点再恢复后数据已经不一致了，但是节点会尝试重新让数据恢复一致（也就是做最终一致）</p>
<h3 id="117-Redis内存回收"><a href="#117-Redis内存回收" class="headerlink" title="#117 Redis内存回收"></a>#117 Redis内存回收</h3><p>Redis内存回收：近似LRU，给每个key加一个最后一次访问时间戳，当内存超过阈值时，随机选取5个key，删掉时间戳最靠前的（最旧的），如果内存还超阈值，则重复一次上述过程</p>
<h3 id="118-Radix-Sort"><a href="#118-Radix-Sort" class="headerlink" title="#118 Radix Sort"></a>#118 Radix Sort</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484076&idx=1&sn=fb551e1eb83cd483c7a963cbc432e4bd&chksm=fa0e6d2dcd79e43bc4387b3fd89c61dcc084a4e7396c453d9194f0ae357f1cf725eabd39ebb9&mpshare=1&scene=1&srcid=1006lh7S2n3cYkzNGp8EBSeY&sharer_sharetime=1570347036267&sharer_shareid=5549e44ad88a51bc740c6fdae62c8748#rd" target="_blank" rel="noopener">【图解数据结构】 一组动画彻底理解基数排序</a></p>
<h3 id="119-happens-before"><a href="#119-happens-before" class="headerlink" title="#119 happens-before"></a>#119 happens-before</h3><ol>
<li>同一个线程中的每个Action都happens-before于出现在其后的任何一<br>个Action。</li>
<li>对一个监视器的解锁happens-before于每一个后续对同一个监视器的<br>加锁。</li>
<li>对volatile字段的写入操作happens-before于每一个后续的同一个字段 的读操作。</li>
<li>Thread.start()的调用会happens-before于启动线程里面的动作。</li>
<li>Thread中的所有动作都happens-before于其他线程检查到此线程结束<br>戒者Thread.join()中返回戒者Thread.isAlive()==false。</li>
<li>一个线程A调用另一个另一个线程B的interrupt()都happens-before 于线程A发现B被A中断(B抛出异常戒者A检测到B的isInterrupted() 戒者interrupted())。<br>那么A动作happens-before于C动作。 <a href="http://www.blogjava.net/xylz/archive/2010/07/03/325168.html" target="_blank" rel="noopener">http://www.blogjava.net/xylz/archive/2010/07/03/325168.html</a></li>
<li>一个对象构造函数的结束happens-before与该对象的finalizer的开始</li>
<li>如果A动作happens-before于B动作，而B动作happens-before与C动作，</li>
</ol>
<h3 id="120-ConcurrentHashMap在1-7和1-8的不同实现"><a href="#120-ConcurrentHashMap在1-7和1-8的不同实现" class="headerlink" title="#120 ConcurrentHashMap在1.7和1.8的不同实现"></a>#120 ConcurrentHashMap在1.7和1.8的不同实现</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzY1OTU1NQ==&mid=2247483894&idx=1&sn=72e7fb63296ff382568a7861c75068c1&chksm=96cd41baa1bac8ace9a8c99a76851a59ebc57997bfaa680e5cdf8e42191dd8c0b3b281851edd&mpshare=1&scene=1&srcid=1006PdZ63ISY9031rIvdTJdA&sharer_sharetime=1570370348811&sharer_shareid=5549e44ad88a51bc740c6fdae62c8748#rd" target="_blank" rel="noopener">谈谈ConcurrentHashMap在1.7和1.8的不同实现</a></p>
<h3 id="121-到底什么是线程"><a href="#121-到底什么是线程" class="headerlink" title="#121 到底什么是线程"></a>#121 到底什么是线程</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NjcwOTkzOA==&mid=2247483880&idx=1&sn=bf09f1a775aaf3b4f0b3a265d687c258&chksm=ebd98035dcae09234c2cdc5811db302d4f9ab38e112cf83c4a750d8137945237d58023b6ab12&mpshare=1&scene=1&srcid=1007aGK2sfEdOUerzbeVkDSJ&sharer_sharetime=1570408031815&sharer_shareid=5549e44ad88a51bc740c6fdae62c8748#rd" target="_blank" rel="noopener">到底什么是线程？又是怎么从start到run？</a></p>
<h3 id="122-限流算法"><a href="#122-限流算法" class="headerlink" title="#122 限流算法"></a>#122 限流算法</h3><p>漏桶算法：可以想象为买煎饼果子，煎饼果子摊处理能力有限，人多了直接拍队，老板基本上保持恒定的速度出煎饼，出一个走一个</p>
<p>令牌桶算法：（guava的RateLimiter就是一种实现）可以想象成看电影买票，有发票窗口专门安排出票，出票速率可调，排队不直接拍在影厅，而是拍在售票处，然后影厅门口会有检票员，拿到票的才能进</p>
<p>普通的计数法限流无法限制峰值聚集的情况，也就是说如果设定10秒内不能超过10个，那恶意者完全可以利用这样的漏洞：两个10秒，在第一个10秒的最后一秒一次性走10个，然后立刻在第二个10秒的第一秒一次性走10个，这样峰值仍然可能压垮系统</p>
<p>时间窗口算法：将时间段分为更小的切片，然后没过切片时间整个窗口就滑动一个切片的距离，这样假如遇到两个峰值聚集在一起时，也就是聚集在两个临近的分片中时，在整个窗口看来已经超过限定了，这样就起到了限流的目的</p>
<p><a href="https://my.oschina.net/loubobooo/blog/1796752" target="_blank" rel="noopener">Spring Boot的接口限流应用</a></p>
<h3 id="123-线程池"><a href="#123-线程池" class="headerlink" title="#123 线程池"></a>#123 线程池</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NDg3MjAwMQ==&mid=2457103451&idx=1&sn=ba3024ee4b4a298da4f14d6b4a3da2b9&chksm=87c8c4f5b0bf4de3dc065d0b0b899ebc295cbf8f538728ba7b44ee459f30054466d22bf9a44d&mpshare=1&scene=1&srcid=&sharer_sharetime=1570595277656&sharer_shareid=5549e44ad88a51bc740c6fdae62c8748#rd" target="_blank" rel="noopener">小问题大智慧 ：线程池是怎样工作的</a></p>
<h3 id="124-循环提升"><a href="#124-循环提升" class="headerlink" title="#124 循环提升"></a>#124 循环提升</h3><p>将多次循环中的操作提取到循环外部的一次性操作</p>
<p><img src="/notes/index/124-1.jpg" alt="图124-1"></p>
<p><img src="/notes/index/124-2.jpg" alt="图124-2"></p>
<p>循环提升前提是假定了无竞争，可能影响到多线程执行的语义</p>
<p>volatile可阻止JIT进行循环提升</p>
<h3 id="125-volatile可见性保证"><a href="#125-volatile可见性保证" class="headerlink" title="#125 volatile可见性保证"></a>#125 volatile可见性保证</h3><p>volatile可见性保证读取到当前相对新值 而非最新值，因为volatile并不阻塞其他线程的写操作 有可能读到后其他线程就该了该值 因此依旧会得不到预期结果</p>
<p>原子性保证能够产生相对新值，而不保证能读到，因此 原子性+可见性才能保证并发语义</p>
<p>volatile不保证互斥 读改写场景中 读后不保证其他线程不能改，也就是做不到隔离 或者说完全的原子性</p>
<p><img src="/notes/index/125-1.jpg" alt="图125-1"></p>
<p>volatile 不仅仅对被修饰的变量起作用，还会对被修饰变量之前的（源代码顺序）的变量产生作用</p>
<p>volatile写操作前的任何读 写操作都会确保被先提交</p>
<p><img src="/notes/index/125-2.jpg" alt="图125-2"></p>
<p><img src="/notes/index/125-3.jpg" alt="图125-3"></p>
<p>如果volatile修饰数组变量，那么它只对数组变量本身起作用，对数组内元素并不起作用，如果volatile修饰引用类型的变量，那么它只对变量本身起作用，对变量对应的引用类型实例内部的属性并不起作用</p>
<h3 id="126-join-可见性保证"><a href="#126-join-可见性保证" class="headerlink" title="#126 join() 可见性保证"></a>#126 join() 可见性保证</h3><p>join()之前的更改对于join()之后的操作可见</p>
<h3 id="127-貌似串行语义"><a href="#127-貌似串行语义" class="headerlink" title="#127 貌似串行语义"></a>#127 貌似串行语义</h3><p>貌似串行语义 as-if-serial 只保证单线程程序冲排序后结果和未超排序一致而不保证多线程下的</p>
<h3 id="128-线程安全"><a href="#128-线程安全" class="headerlink" title="#128 线程安全"></a>#128 线程安全</h3><p>多线程保证线程安全需要满足的：原子性(完全的原子性还要包含互斥，volatile的原子性不包含互斥并不完整) 可见性 有序性 </p>
<p>原子性 保证不产生中间状态同时不交错</p>
<h3 id="129-start-可见性保证"><a href="#129-start-可见性保证" class="headerlink" title="#129 start() 可见性保证"></a>#129 start() 可见性保证</h3><p>start()之前的写操作对之后启动的线程可见</p>
<h3 id="130-临界区"><a href="#130-临界区" class="headerlink" title="#130 临界区"></a>#130 临界区</h3><p>临界区：加锁和释放锁之间的执行区</p>
<h3 id="131-ConcurrentHashMap-锁的粒度细"><a href="#131-ConcurrentHashMap-锁的粒度细" class="headerlink" title="#131 ConcurrentHashMap 锁的粒度细"></a>#131 ConcurrentHashMap 锁的粒度细</h3><p>1.7的ConcurrentHashMap 相当于快递柜 各锁各的</p>
<p>HashTable 相当于库房的锁，一把锁锁所有</p>
<h3 id="132-锁句柄要用final修饰"><a href="#132-锁句柄要用final修饰" class="headerlink" title="#132 锁句柄要用final修饰"></a>#132 锁句柄要用final修饰</h3><p>锁句柄要用final修饰，因为如果是可变的就会造成锁在了不同的锁上导致语义丢失</p>
<h3 id="133-入口集"><a href="#133-入口集" class="headerlink" title="#133 入口集"></a>#133 入口集</h3><p>被从入口集（也就是同步队列）中唤醒的线程不一定就必然能获得到锁，因为他有可能要与没在入口集中的线程争抢锁</p>
<h3 id="134-用于线程操作的一些工具方法"><a href="#134-用于线程操作的一些工具方法" class="headerlink" title="#134 用于线程操作的一些工具方法"></a>#134 用于线程操作的一些工具方法</h3><p>Thread#holdsLock(Object) 可检测当前线程是否持有指定内部锁</p>
<p>ReentrantLock#isLocked() Queries if this lock is held by any thread.</p>
<p>ReentrantLock#getQueueLength() 可以检查等待锁的线程数量（同步队列长度？）</p>
<h3 id="135-读写锁"><a href="#135-读写锁" class="headerlink" title="#135 读写锁"></a>#135 读写锁</h3><p>读写锁是有单独接口的</p>
<p>读写锁：写读、读写、写写 互斥而 读读共享</p>
<p>读写锁支持获得了写锁后在释放写锁前获得读锁或者说是将锁转换为读锁，也就是锁降级</p>
<p>读写锁内并不是有两个锁 而是一个锁有读锁和写锁两种角色 并可支持写锁转换为读锁角色的操作</p>
<p><img src="/notes/index/135-1.jpg" alt="图135-1"></p>
<h3 id="136-synchronized"><a href="#136-synchronized" class="headerlink" title="#136 synchronized"></a>#136 synchronized</h3><p><code>synchronized</code>在虚拟机层面实现是插入了<code>MonitorEnter</code> 和 <code>MonitorExit</code> 这两个字节码指令</p>
<p>而到了机器码层面后会在<code>MonitorEnter</code>对应的机器码指令前插入<code>LoadBarrier</code>（加载屏障 作用是将内存中数据同步到缓存，也就是刷新缓存）而在<code>MonitorExit</code>对应的机器指令后边会插入<code>StoreBarrier</code>（存储屏障 作用是将缓存中数据同步到主存也就是<code>flush</code>）</p>
<h3 id="137-类初始化是惰性的"><a href="#137-类初始化是惰性的" class="headerlink" title="#137 类初始化是惰性的"></a>#137 类初始化是惰性的</h3><p>类初始化是懒惰型的，类加载后静态变量全是默认值，只有被第一个线程访问静态变量时才会执行<cinit>  static 关键字保证线程能够看到 <cinit>后的静态变量值 这一点不需加锁即可保证</cinit></cinit></p>
<h3 id="138-final-可见性保证"><a href="#138-final-可见性保证" class="headerlink" title="#138 final 可见性保证"></a>#138 final 可见性保证</h3><p>final关键字保证其修饰的变量能够完成初始化，也就是线程能够看到最终的值</p>
<p>如果其修饰的是引用类型那么能保证该引用类型完全初始化完毕 也就是线程看到的引用类型是完全初始化完毕的</p>
<p><img src="/notes/index/138-1.jpg" alt="图138-1"></p>
<p><img src="/notes/index/138-2.jpg" alt="图138-2"></p>
<h3 id="139-CAS-与可见性"><a href="#139-CAS-与可见性" class="headerlink" title="#139 CAS 与可见性"></a>#139 CAS 与可见性</h3><p>CAS不保证可见性</p>
<h3 id="140-CAS-怎么实现"><a href="#140-CAS-怎么实现" class="headerlink" title="#140 CAS 怎么实现"></a>#140 CAS 怎么实现</h3><p>CAS通过CPU指令实现 </p>
<h3 id="141-两类内存屏障"><a href="#141-两类内存屏障" class="headerlink" title="#141 两类内存屏障"></a>#141 两类内存屏障</h3><p>加载屏障和存储屏障用于保证可见性也就是内存和缓存的同步</p>
<p>获取屏障和释放屏障用于保证有序性 也就是禁止重排序</p>
<p>加载屏障的作用是在屏障处强行将内存值同步到缓存而存储屏障则是在其位置强制触发缓存值同步到内存</p>
<p>获取屏障需要插在某个读操作后，获取屏障用于禁止此处的读操作和其后的任意写操作冲排序而释放屏障需要插在某个写操作前，释放屏障用于禁止当前位置写操作和其之前的任何读操作进行冲排序</p>
<h3 id="142-透彻理解Java并发编程"><a href="#142-透彻理解Java并发编程" class="headerlink" title="#142 透彻理解Java并发编程"></a>#142 透彻理解Java并发编程</h3><p><a href="https://segmentfault.com/blog/ressmix_multithread" target="_blank" rel="noopener">透彻理解Java并发编程</a></p>
<h3 id="143-B-树多个字段复合索引"><a href="#143-B-树多个字段复合索引" class="headerlink" title="#143 B+树多个字段复合索引"></a>#143 B+树多个字段复合索引</h3><p>复合索引用 concat 确定顺序</p>
<p><a href="https://www.freecodecamp.org/news/database-indexing-at-a-glance-bb50809d48bd/" target="_blank" rel="noopener">An in-depth look at Database Indexing</a></p>
<h3 id="144-jvisualvm"><a href="#144-jvisualvm" class="headerlink" title="#144 jvisualvm"></a>#144 jvisualvm</h3><p>jvisualvm可做线程运行时间等待时间的采样分析</p>
<p><img src="/notes/index/144-1.jpg" alt="图144-1"></p>
<h3 id="145"><a href="#145" class="headerlink" title="#145"></a>#145</h3><p>wait和notify内部怎样实现？在JVM内部有入口集和等待集 想当于JDK中Lock的同步队列和等待队列</p>
<h3 id="146"><a href="#146" class="headerlink" title="#146"></a>#146</h3><p>wait方法在线程真正等待后并不会返回，直到线程被唤醒后获得到了锁从等待集中删除掉后才会返回也就说wait会跨越一个很长的周期</p>
<p><img src="/notes/index/146-1.jpg" alt="图146-1"></p>
<p><img src="/notes/index/146-2.jpg" alt="图146-2"></p>
<h3 id="147-CyclicBarrier-和-CountdownLatch-对比"><a href="#147-CyclicBarrier-和-CountdownLatch-对比" class="headerlink" title="#147 CyclicBarrier 和 CountdownLatch 对比"></a>#147 CyclicBarrier 和 CountdownLatch 对比</h3><p>CyclicBarrier 多个线程都准备好了再一块做某事</p>
<p>除了最后一个到达的线程外 其他线程调用CyclicBarrier#await都会变为WAITING 最后一个调用await的会先执行barieAction然后调用signalAll来唤醒之前所有线程开始干活</p>
<p>CountdownLatch 是一来了就干活 然后有一个监工等着这些人都干完活了验收，CyclicBarrier是r一来了，如果最后一个人没到就先等着，最后一个人到了，他负责通知大家开始干活，并且在通知之前可选择自己先干些额外的事</p>
<h3 id="148-如何结束线程"><a href="#148-如何结束线程" class="headerlink" title="#148 如何结束线程"></a>#148 如何结束线程</h3><p>waiting的线程可被中断唤醒，需要终止线程时，可以用一个boolean属性作为标识，用于退出run方法，同时还需要配合Thread.interrupt 保证已经等待的线程能被唤醒（若不唤醒的话，run里即便有控制退出run的逻辑也会因为线程处于等待状态而无法运行到）</p>
<h3 id="149-同步、异步，阻塞、非阻塞"><a href="#149-同步、异步，阻塞、非阻塞" class="headerlink" title="#149 同步、异步，阻塞、非阻塞"></a>#149 同步、异步，阻塞、非阻塞</h3><p>同步和异步是从返回结果这个视角来看的，同步意味着调用后收到的结果就是想要的结果而异步是调用后不会收到想要的结果而是结果由通知机制另行通知</p>
<p>阻塞和非阻塞是从执行的视角来看的，阻塞意味着调用者发起调用后线程需要一直等待，不能执行别的任务，直到返回结果。或者发起调用后先收到一个确认（而非结果）然后在被通知真正结果之前要线程一直等待，不能执行别的任务</p>
<h3 id="150-用枚举做单例好吗？"><a href="#150-用枚举做单例好吗？" class="headerlink" title="#150 用枚举做单例好吗？"></a>#150 用枚举做单例好吗？</h3><p>不好，干扰语义，应极力避免。</p>
<p>推荐 InstanceHolder 机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &lt;cinit&gt; 由 JVM 内部的锁保证线程安全，并且是懒加载，只有第一个线程用到时才会触发执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="151-ThreadLocalMap-的-key-是-WeakReference"><a href="#151-ThreadLocalMap-的-key-是-WeakReference" class="headerlink" title="#151 ThreadLocalMap 的 key 是 WeakReference"></a>#151 ThreadLocalMap 的 key 是 WeakReference</h3><p>ThreadLocalMap 的 Entry 中 key是WeakReference<threadlocal> value是普通引用（强引用）弱引用在没有普通引用引用的情况下会被下次垃圾回收清除也就是key置为null，而value不会被立刻清除，他会在下次执行put时被清除（懒清除）如果线程长期不处于运行状态，一直不调用put，那么一直触发不了 value的清除就可能会造成内存泄漏</threadlocal></p>
<p>tomcat 每个应用都有独立的WebAppLoader加载，而各个应用的执行是共享了一套线程池的，也就意味着ThreadLocal也是在多个应用间共享的，当一个应用停止后，其WebAppLoader加载的类（以及静态字段等）元信息并不会卸载（当然tomcat内部的泄漏检测时可以处理这个情况的）也就是没有把ThreadLocal对应的静态变量卸妆（一般ThreadLocal都会定义为静态变量，要是定义为实例变量的画会导致ThreadLocal引用反复创建，语义是不对的），那么就意味着有强引用引用了TreadLocalMap的key 那么就意味着不会被回收，这样就有可能内存泄漏</p>
<h3 id="152-装饰器模式下生成的同步集合的迭代器需要额外加锁才能保证线程安全"><a href="#152-装饰器模式下生成的同步集合的迭代器需要额外加锁才能保证线程安全" class="headerlink" title="#152 装饰器模式下生成的同步集合的迭代器需要额外加锁才能保证线程安全"></a>#152 装饰器模式下生成的同步集合的迭代器需要额外加锁才能保证线程安全</h3><p>装饰器模式下生成的同步集合（Collections.synchronizedMap等）的迭代器（iterator）需要额外加锁才能保证线程安全，而且这个锁需要选取同步集合实例作为锁对象（目的是保证和内部的写操作同步在同一个锁上）</p>
<p>这个实际上违背了最少知识原则</p>
<h3 id="153-双重检查锁定"><a href="#153-双重检查锁定" class="headerlink" title="#153 双重检查锁定"></a>#153 双重检查锁定</h3><p>双重检查锁定如果实例不加volatile可能存在 一个线程将对象实例赋值到引用先于 new 对象实例发生（也就说编译器汇编指令冲排序）导致另一个线程判断对象不为null成立直接返回了未填充值的全是初始值的对象</p>
<h3 id="154-Java内存模式是硬件内存模型的高层抽象"><a href="#154-Java内存模式是硬件内存模型的高层抽象" class="headerlink" title="#154 Java内存模式是硬件内存模型的高层抽象"></a>#154 Java内存模式是硬件内存模型的高层抽象</h3><p><img src="/notes/index/154-1.jpg" alt="图154-1"></p>
<p><img src="/notes/index/154-2.jpg" alt="图154-2"></p>
<h3 id="155-flip"><a href="#155-flip" class="headerlink" title="#155 flip()"></a>#155 flip()</h3><p><img src="/notes/index/155-1.jpg" alt="图155-1"></p>
<p>ByteBuffer 有两种模式：写模式和读模式。在写模式下调用 flip() 之后，ByteBuffer 从写模式变成读模式。</p>
<p>那么 limit 就设置成了 position 当前的值(即当前写了多少数据)，position 会被置为 0，以表示读操作从缓存的头开始读，mark 置为-1。</p>
<p>也就是说调用 flip() 之后，读/写指针 position 指到缓冲区头部，并且设置了最多只能读出之前写入的数据长度(而不是整个缓存的容量大小)。</p>
<h3 id="156-TCP-长连接"><a href="#156-TCP-长连接" class="headerlink" title="#156 TCP 长连接"></a>#156 TCP 长连接</h3><p>TCP 长连接简单的讲就是应用层实现一个心跳机制来维持 TCP 连接，不能指望 TCP 内置的 keep alive</p>
<p><a href="https://mp.weixin.qq.com/s/035SiIDhmbHzbtI1fF4h1g" target="_blank" rel="noopener">手把手教你写 Socket 长连接</a></p>
<h3 id="157-happens-before"><a href="#157-happens-before" class="headerlink" title="#157 happens-before"></a>#157 happens-before</h3><p>happens-before：有两组操作  每组操作包含若干字操作，每个字操作会产生子结果。A｛a1，a2，a3｝ B｛b1，b2，b3｝ 如果 A happens-before B 那么，从可见性来看，A的所有字操作产生的字结果对于B都是可见的，从有序性来看，从Ｂ的角度来观察A中所有操作都是按程序顺序执行的，尽管实际上A的各个字操作可能存在冲排序，但是对于Ｂ来说它认定A内部就像是没有冲排序一样</p>
<p>happens-before规则又可分为若干细则：</p>
<ul>
<li>程序顺序规则</li>
<li>内部锁规则</li>
<li>volatile变量规则</li>
<li>线程启动规则</li>
<li>线程终止规则</li>
</ul>
<p><img src="/notes/index/157-1.jpg" alt="图157-1"></p>
<p>happens-before 是一套标准，它只提出目标而不关心怎么实现，具体实现是由 JVM（包含JIT）来操作的，JVM会通过一系列手段（比如在合适的位置插入内存屏障）来确保自己能够达到目标</p>
<p>DLC单例中给实例变量加volatile后就利用了happens-before规则中的volatile变量细则</p>
<p><img src="/notes/index/157-2.jpg" alt="图157-2"></p>
<p><code>instance = new Instance()</code> 这个volatile变量写操作 happens-before 了 <code>if(null == instance)</code> 这个volatile变量的读操作 因此JVM保证（通过禁止冲排序）在后面的读操作读到的一定是写操作执行完的（也就是new完了然后再赋值完的）这样就不会出现读到一个没有完成构造的里面都是初始值的对象这样的情况了</p>
<h3 id="158-Java内存布局"><a href="#158-Java内存布局" class="headerlink" title="#158 Java内存布局"></a>#158 Java内存布局</h3><p>Java内存布局中存在8字节对齐规则，对其意味着有填充，而填充是在浪费空间的，为了减少填充发生的频率，JVM不会按照程序顺序存储对象中的共享变量，而是按照能够优化存储空间的顺序来存放</p>
<p>这就像小学教室里排座位，老师不会因为某两个学生关系好而把他们排成连坐，而是按照个体大小排因为他的诉求是更高效的利用空间</p>
<p>也就是一个Context有一个Context的规则</p>
<h3 id="159-伪共享"><a href="#159-伪共享" class="headerlink" title="#159 伪共享"></a>#159 伪共享</h3><p>伪共享 不同的实例的共享变量被安排在了同一个缓存行中，当一个变量应用保证线程安全的手段导致其所在的缓存行失效会牵连到同一缓存行中的其他人</p>
<p>解决办法，使用@Contented等填充手段在某个共享变量后边填充上数据从而让另一个共享变量无法再放入这个缓存行</p>
<p>也就是一个变量独占缓存行</p>
<h3 id="160-NIO"><a href="#160-NIO" class="headerlink" title="#160 NIO"></a>#160 NIO</h3><p>NIO中的主要概念：Channel和Buffer，Channel是和操作系统层面打交道的 类似于厨房的水池和水管，水管和底层公共下水系统（操作系统）相连接，而Buffer则连在Channel上层 或者类似于抽水机水管和蓄水池，抽水机水管和底层地下室系统打交道，而蓄水池则连接在抽水机水管上层</p>
<p>Buffer是与上层系统（应用代码）进行交换的门径</p>
<p>FileChannel可以从其他Channel转移数据到自己</p>
<p>Selector和FileChannel不能联合用，因为FileChannel不支持非阻塞模式</p>
<p><img src="/notes/index/160-1.jpg" alt="图160-1"></p>
<h3 id="161-一次CPU-100"><a href="#161-一次CPU-100" class="headerlink" title="#161 一次CPU 100%"></a>#161 一次CPU 100%</h3><p>观察 GC 情况，1小时发生了 40 次 FullGC ，并且看GC曲线，每次GC后内存并未下降，同时 jstack 可看到 CPU 全跑在 <code>VM THREAD</code> 这个线程上，因此可大致认定，CPU 100% 是频繁而无效得 FullGC 导致的</p>
<p><img src="/notes/index/161-1.png" alt="图161-1"></p>
<p>上图中呈上升趋势的是有异常的docker实例，呈下降趋势的是正常的docker实例</p>
<h3 id="162-操作系统内置的计算器可轻松处理程序上的计算"><a href="#162-操作系统内置的计算器可轻松处理程序上的计算" class="headerlink" title="#162 操作系统内置的计算器可轻松处理程序上的计算"></a>#162 操作系统内置的计算器可轻松处理程序上的计算</h3><p><img src="/notes/index/162-1.png" alt="图162-1"></p>

        
      </div>
      
      
      
    </div>
    



    
    
    
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar215x215.png" alt="since1986">
            
              <p class="site-author-name" itemprop="name">since1986</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">161</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/since1986" title="GitHub &rarr; https://github.com/since1986" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:385741668@qq.com" title="E-Mail &rarr; mailto:385741668@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://twitter.com/_since1986_" title="Twitter &rarr; https://twitter.com/_since1986_" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.linkedin.com/in/fan-zhang-since1986" title="Linkedin &rarr; https://www.linkedin.com/in/fan-zhang-since1986" rel="noopener" target="_blank"><i class="fa fa-fw fa-linkedin"></i>Linkedin</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://since1986.github.io/" title="https://since1986.github.io/">我的主站</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://since1986.coding.me/" title="https://since1986.coding.me/" rel="noopener" target="_blank">我的高速镜像站</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.720ui.com/" title="http://blog.720ui.com/" rel="noopener" target="_blank">梁桂钊的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://chenyongjun.vip/" title="http://chenyongjun.vip/" rel="noopener" target="_blank">码代码的陈同学</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://qixiaobo.site/" title="https://qixiaobo.site/" rel="noopener" target="_blank">后端之路</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xilidou.com/" title="https://xilidou.com/" rel="noopener" target="_blank">犀利豆的博客</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正文"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-等待通知机制"><span class="nav-number">2.1.</span> <span class="nav-text">#1 等待通知机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-多态、虚方法表"><span class="nav-number">2.2.</span> <span class="nav-text">#2 多态、虚方法表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-类初始化锁"><span class="nav-number">2.3.</span> <span class="nav-text">#3 类初始化锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-记录一次JVM-old过高的排查"><span class="nav-number">2.4.</span> <span class="nav-text">#4 记录一次JVM old过高的排查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-实现一个小顶堆"><span class="nav-number">2.5.</span> <span class="nav-text">#5 实现一个小顶堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-JMM对64位数据类型有特殊规范"><span class="nav-number">2.6.</span> <span class="nav-text">#6 JMM对64位数据类型有特殊规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-new-都做了什么操作"><span class="nav-number">2.7.</span> <span class="nav-text">#7 new 都做了什么操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-随机数"><span class="nav-number">2.8.</span> <span class="nav-text">#8 随机数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-annotation-类型的切入点只在有接口方法声明的前提下生效，为什么"><span class="nav-number">2.9.</span> <span class="nav-text">#9 @annotation 类型的切入点只在有接口方法声明的前提下生效，为什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-责任链模式尝试"><span class="nav-number">2.10.</span> <span class="nav-text">#10 责任链模式尝试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-spring配置方式的变更与DRY"><span class="nav-number">2.11.</span> <span class="nav-text">#11 spring配置方式的变更与DRY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-容器管理实例的模式"><span class="nav-number">2.12.</span> <span class="nav-text">#12 容器管理实例的模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-编程本质"><span class="nav-number">2.13.</span> <span class="nav-text">#13 编程本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-分析Java线程CPU占用率高的步骤"><span class="nav-number">2.14.</span> <span class="nav-text">#14 分析Java线程CPU占用率高的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-对于Spring-IoC的理解"><span class="nav-number">2.15.</span> <span class="nav-text">#15 对于Spring IoC的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-Spring的设计哲学"><span class="nav-number">2.16.</span> <span class="nav-text">#16 Spring的设计哲学</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-对象的本质是-状态-行为"><span class="nav-number">2.17.</span> <span class="nav-text">#17 对象的本质是 状态 + 行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-Spring-兼容循环依赖的做法"><span class="nav-number">2.18.</span> <span class="nav-text">#18 Spring 兼容循环依赖的做法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-Spring-Bean-Scope"><span class="nav-number">2.19.</span> <span class="nav-text">#19 Spring Bean Scope</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-RootBeanDefinition"><span class="nav-number">2.20.</span> <span class="nav-text">#20 RootBeanDefinition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-IoC-的两种实现方式-DF-和-DI"><span class="nav-number">2.21.</span> <span class="nav-text">#21 IoC 的两种实现方式 DF 和 DI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-对于-IoC-的理解"><span class="nav-number">2.22.</span> <span class="nav-text">#22 对于 IoC 的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-ApplicationContext"><span class="nav-number">2.23.</span> <span class="nav-text">#23 ApplicationContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-ProxyFactoryBean"><span class="nav-number">2.24.</span> <span class="nav-text">#24 ProxyFactoryBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-Spring事务处理的顶层设计"><span class="nav-number">2.25.</span> <span class="nav-text">#25 Spring事务处理的顶层设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-持续重构"><span class="nav-number">2.26.</span> <span class="nav-text">#26 持续重构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-SpringBoot"><span class="nav-number">2.27.</span> <span class="nav-text">#27 SpringBoot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-spring-mvc请求处理过程"><span class="nav-number">2.28.</span> <span class="nav-text">#28 spring-mvc请求处理过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-Bean"><span class="nav-number">2.29.</span> <span class="nav-text">#29 @Bean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-spring-boot-自动配置实现的重要的点"><span class="nav-number">2.30.</span> <span class="nav-text">#30 spring-boot 自动配置实现的重要的点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-Controller-注解"><span class="nav-number">2.31.</span> <span class="nav-text">#31 @Controller 注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-AbstractHandlerMethodMapping"><span class="nav-number">2.32.</span> <span class="nav-text">#32 AbstractHandlerMethodMapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-RequestMappingHandlerMapping"><span class="nav-number">2.33.</span> <span class="nav-text">#33 RequestMappingHandlerMapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-ExecutionChain"><span class="nav-number">2.34.</span> <span class="nav-text">#34 ExecutionChain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-原型方式的Bean是否支持依赖注入？"><span class="nav-number">2.35.</span> <span class="nav-text">#35 原型方式的Bean是否支持依赖注入？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-Lookup"><span class="nav-number">2.36.</span> <span class="nav-text">#36 @Lookup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-生命周期"><span class="nav-number">2.37.</span> <span class="nav-text">#37 生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-ServletContextListener"><span class="nav-number">2.38.</span> <span class="nav-text">#38 ServletContextListener</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-Configuration"><span class="nav-number">2.39.</span> <span class="nav-text">#39 @Configuration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-什么是语法？"><span class="nav-number">2.40.</span> <span class="nav-text">#40 什么是语法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41-GC日志释意"><span class="nav-number">2.41.</span> <span class="nav-text">#41 GC日志释意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42"><span class="nav-number">2.42.</span> <span class="nav-text">#42</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43"><span class="nav-number">2.43.</span> <span class="nav-text">#43</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-JVM内存划分"><span class="nav-number">2.44.</span> <span class="nav-text">#44 JVM内存划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45-栈上分配"><span class="nav-number">2.45.</span> <span class="nav-text">#45 栈上分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-HashMap"><span class="nav-number">2.46.</span> <span class="nav-text">#46 HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-HashMap-是扩容成2倍"><span class="nav-number">2.47.</span> <span class="nav-text">#47 HashMap 是扩容成2倍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48-自学英语"><span class="nav-number">2.48.</span> <span class="nav-text">#48 自学英语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49-ConcurrentHashMap"><span class="nav-number">2.49.</span> <span class="nav-text">#49 ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#50-CAS"><span class="nav-number">2.50.</span> <span class="nav-text">#50 CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51-hash索引"><span class="nav-number">2.51.</span> <span class="nav-text">#51 hash索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52-覆盖索引"><span class="nav-number">2.52.</span> <span class="nav-text">#52 覆盖索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-mysql复合索引"><span class="nav-number">2.53.</span> <span class="nav-text">#53 mysql复合索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54-UUID"><span class="nav-number">2.54.</span> <span class="nav-text">#54 UUID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-redolog、undolog"><span class="nav-number">2.55.</span> <span class="nav-text">#55 redolog、undolog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56-通过间隙锁解决幻读"><span class="nav-number">2.56.</span> <span class="nav-text">#56 通过间隙锁解决幻读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#57-ObjectId"><span class="nav-number">2.57.</span> <span class="nav-text">#57 ObjectId</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#58-Redis删除策略"><span class="nav-number">2.58.</span> <span class="nav-text">#58 Redis删除策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#59-Redis高性能"><span class="nav-number">2.59.</span> <span class="nav-text">#59 Redis高性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#60-io多路复用"><span class="nav-number">2.60.</span> <span class="nav-text">#60 io多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#61-Redis哨兵"><span class="nav-number">2.61.</span> <span class="nav-text">#61 Redis哨兵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-Redis-分布式锁-setNX"><span class="nav-number">2.62.</span> <span class="nav-text">#62 Redis 分布式锁 setNX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-synchronized-锁升级"><span class="nav-number">2.63.</span> <span class="nav-text">#63 synchronized 锁升级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-Kafka"><span class="nav-number">2.64.</span> <span class="nav-text">#64 Kafka</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#65-Xmn"><span class="nav-number">2.65.</span> <span class="nav-text">#65 Xmn</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#66-模拟内存分配"><span class="nav-number">2.66.</span> <span class="nav-text">#66 模拟内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#67-CardTable"><span class="nav-number">2.67.</span> <span class="nav-text">#67 CardTable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#68-水平分表"><span class="nav-number">2.68.</span> <span class="nav-text">#68 水平分表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#69-spring-Bean-生命周期"><span class="nav-number">2.69.</span> <span class="nav-text">#69 spring Bean 生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#70-zset"><span class="nav-number">2.70.</span> <span class="nav-text">#70 zset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#71-mvcc"><span class="nav-number">2.71.</span> <span class="nav-text">#71 mvcc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72-MySQL事务隔离级别"><span class="nav-number">2.72.</span> <span class="nav-text">#72 MySQL事务隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#73"><span class="nav-number">2.73.</span> <span class="nav-text">#73</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#74-mvcc原理"><span class="nav-number">2.74.</span> <span class="nav-text">#74 mvcc原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#75-CountDownLatch"><span class="nav-number">2.75.</span> <span class="nav-text">#75 CountDownLatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#76-TCP三次握手"><span class="nav-number">2.76.</span> <span class="nav-text">#76 TCP三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#77-TCP四次挥手"><span class="nav-number">2.77.</span> <span class="nav-text">#77 TCP四次挥手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#78-滑动窗口"><span class="nav-number">2.78.</span> <span class="nav-text">#78 滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#79-netty线程模型"><span class="nav-number">2.79.</span> <span class="nav-text">#79 netty线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#80-Reactor-模型"><span class="nav-number">2.80.</span> <span class="nav-text">#80 Reactor 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#81-netty-handler无锁设计"><span class="nav-number">2.81.</span> <span class="nav-text">#81 netty handler无锁设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#82-粘包拆包"><span class="nav-number">2.82.</span> <span class="nav-text">#82 粘包拆包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#83-Linux-io模型"><span class="nav-number">2.83.</span> <span class="nav-text">#83 Linux io模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#84-netty零拷贝"><span class="nav-number">2.84.</span> <span class="nav-text">#84 netty零拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#85-一致性Hash"><span class="nav-number">2.85.</span> <span class="nav-text">#85 一致性Hash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#86-mvcc-ReadView"><span class="nav-number">2.86.</span> <span class="nav-text">#86 mvcc ReadView</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#87-旁路缓存解决数据库和缓存双写一致性"><span class="nav-number">2.87.</span> <span class="nav-text">#87 旁路缓存解决数据库和缓存双写一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#88-主线程"><span class="nav-number">2.88.</span> <span class="nav-text">#88 主线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#89-线程状态转换"><span class="nav-number">2.89.</span> <span class="nav-text">#89 线程状态转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#90-Thread-sleep"><span class="nav-number">2.90.</span> <span class="nav-text">#90 Thread.sleep</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#91"><span class="nav-number">2.91.</span> <span class="nav-text">#91</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#92-线程同步原语"><span class="nav-number">2.92.</span> <span class="nav-text">#92 线程同步原语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#93-ArrayList的remove"><span class="nav-number">2.93.</span> <span class="nav-text">#93 ArrayList的remove</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#94-ConcurrentHashMap"><span class="nav-number">2.94.</span> <span class="nav-text">#94 ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#95-MySQL主从同步"><span class="nav-number">2.95.</span> <span class="nav-text">#95 MySQL主从同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#96-线程池"><span class="nav-number">2.96.</span> <span class="nav-text">#96 线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#97-spring-boot自动配置实现"><span class="nav-number">2.97.</span> <span class="nav-text">#97 spring-boot自动配置实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#98-G1-收集可能有4个阶段"><span class="nav-number">2.98.</span> <span class="nav-text">#98 G1 收集可能有4个阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#99-CMS的步骤"><span class="nav-number">2.99.</span> <span class="nav-text">#99 CMS的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#100-内在逻辑共性"><span class="nav-number">2.100.</span> <span class="nav-text">#100 内在逻辑共性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#101-什么是线程安全"><span class="nav-number">2.101.</span> <span class="nav-text">#101 什么是线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#102-竞态条件"><span class="nav-number">2.102.</span> <span class="nav-text">#102 竞态条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#103-任务的抽象"><span class="nav-number">2.103.</span> <span class="nav-text">#103 任务的抽象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-netty的线程模型"><span class="nav-number">2.104.</span> <span class="nav-text">#104 netty的线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#105-netty的组件"><span class="nav-number">2.105.</span> <span class="nav-text">#105 netty的组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#106-Selector"><span class="nav-number">2.106.</span> <span class="nav-text">#106 Selector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#107-netty使用引用计数"><span class="nav-number">2.107.</span> <span class="nav-text">#107 netty使用引用计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#108-布隆过滤器"><span class="nav-number">2.108.</span> <span class="nav-text">#108 布隆过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#109-HyperLogLog"><span class="nav-number">2.109.</span> <span class="nav-text">#109 HyperLogLog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110-Paxos协议"><span class="nav-number">2.110.</span> <span class="nav-text">#110 Paxos协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#111-ZooKeeper所有数据都在内存中"><span class="nav-number">2.111.</span> <span class="nav-text">#111 ZooKeeper所有数据都在内存中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#112-ZAB协议"><span class="nav-number">2.112.</span> <span class="nav-text">#112 ZAB协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#113-ZooKeeper实现分布式锁"><span class="nav-number">2.113.</span> <span class="nav-text">#113 ZooKeeper实现分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#114-零拷贝"><span class="nav-number">2.114.</span> <span class="nav-text">#114 零拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#115-StringBuilder-为什么线程不安全"><span class="nav-number">2.115.</span> <span class="nav-text">#115 StringBuilder 为什么线程不安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#116-CAP"><span class="nav-number">2.116.</span> <span class="nav-text">#116 CAP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#117-Redis内存回收"><span class="nav-number">2.117.</span> <span class="nav-text">#117 Redis内存回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#118-Radix-Sort"><span class="nav-number">2.118.</span> <span class="nav-text">#118 Radix Sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#119-happens-before"><span class="nav-number">2.119.</span> <span class="nav-text">#119 happens-before</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#120-ConcurrentHashMap在1-7和1-8的不同实现"><span class="nav-number">2.120.</span> <span class="nav-text">#120 ConcurrentHashMap在1.7和1.8的不同实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#121-到底什么是线程"><span class="nav-number">2.121.</span> <span class="nav-text">#121 到底什么是线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#122-限流算法"><span class="nav-number">2.122.</span> <span class="nav-text">#122 限流算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#123-线程池"><span class="nav-number">2.123.</span> <span class="nav-text">#123 线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#124-循环提升"><span class="nav-number">2.124.</span> <span class="nav-text">#124 循环提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#125-volatile可见性保证"><span class="nav-number">2.125.</span> <span class="nav-text">#125 volatile可见性保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#126-join-可见性保证"><span class="nav-number">2.126.</span> <span class="nav-text">#126 join() 可见性保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#127-貌似串行语义"><span class="nav-number">2.127.</span> <span class="nav-text">#127 貌似串行语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#128-线程安全"><span class="nav-number">2.128.</span> <span class="nav-text">#128 线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#129-start-可见性保证"><span class="nav-number">2.129.</span> <span class="nav-text">#129 start() 可见性保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#130-临界区"><span class="nav-number">2.130.</span> <span class="nav-text">#130 临界区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#131-ConcurrentHashMap-锁的粒度细"><span class="nav-number">2.131.</span> <span class="nav-text">#131 ConcurrentHashMap 锁的粒度细</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#132-锁句柄要用final修饰"><span class="nav-number">2.132.</span> <span class="nav-text">#132 锁句柄要用final修饰</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#133-入口集"><span class="nav-number">2.133.</span> <span class="nav-text">#133 入口集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#134-用于线程操作的一些工具方法"><span class="nav-number">2.134.</span> <span class="nav-text">#134 用于线程操作的一些工具方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#135-读写锁"><span class="nav-number">2.135.</span> <span class="nav-text">#135 读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#136-synchronized"><span class="nav-number">2.136.</span> <span class="nav-text">#136 synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#137-类初始化是惰性的"><span class="nav-number">2.137.</span> <span class="nav-text">#137 类初始化是惰性的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#138-final-可见性保证"><span class="nav-number">2.138.</span> <span class="nav-text">#138 final 可见性保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#139-CAS-与可见性"><span class="nav-number">2.139.</span> <span class="nav-text">#139 CAS 与可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#140-CAS-怎么实现"><span class="nav-number">2.140.</span> <span class="nav-text">#140 CAS 怎么实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#141-两类内存屏障"><span class="nav-number">2.141.</span> <span class="nav-text">#141 两类内存屏障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#142-透彻理解Java并发编程"><span class="nav-number">2.142.</span> <span class="nav-text">#142 透彻理解Java并发编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#143-B-树多个字段复合索引"><span class="nav-number">2.143.</span> <span class="nav-text">#143 B+树多个字段复合索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#144-jvisualvm"><span class="nav-number">2.144.</span> <span class="nav-text">#144 jvisualvm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#145"><span class="nav-number">2.145.</span> <span class="nav-text">#145</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#146"><span class="nav-number">2.146.</span> <span class="nav-text">#146</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#147-CyclicBarrier-和-CountdownLatch-对比"><span class="nav-number">2.147.</span> <span class="nav-text">#147 CyclicBarrier 和 CountdownLatch 对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#148-如何结束线程"><span class="nav-number">2.148.</span> <span class="nav-text">#148 如何结束线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#149-同步、异步，阻塞、非阻塞"><span class="nav-number">2.149.</span> <span class="nav-text">#149 同步、异步，阻塞、非阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#150-用枚举做单例好吗？"><span class="nav-number">2.150.</span> <span class="nav-text">#150 用枚举做单例好吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#151-ThreadLocalMap-的-key-是-WeakReference"><span class="nav-number">2.151.</span> <span class="nav-text">#151 ThreadLocalMap 的 key 是 WeakReference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#152-装饰器模式下生成的同步集合的迭代器需要额外加锁才能保证线程安全"><span class="nav-number">2.152.</span> <span class="nav-text">#152 装饰器模式下生成的同步集合的迭代器需要额外加锁才能保证线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#153-双重检查锁定"><span class="nav-number">2.153.</span> <span class="nav-text">#153 双重检查锁定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#154-Java内存模式是硬件内存模型的高层抽象"><span class="nav-number">2.154.</span> <span class="nav-text">#154 Java内存模式是硬件内存模型的高层抽象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#155-flip"><span class="nav-number">2.155.</span> <span class="nav-text">#155 flip()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#156-TCP-长连接"><span class="nav-number">2.156.</span> <span class="nav-text">#156 TCP 长连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#157-happens-before"><span class="nav-number">2.157.</span> <span class="nav-text">#157 happens-before</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#158-Java内存布局"><span class="nav-number">2.158.</span> <span class="nav-text">#158 Java内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#159-伪共享"><span class="nav-number">2.159.</span> <span class="nav-text">#159 伪共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#160-NIO"><span class="nav-number">2.160.</span> <span class="nav-text">#160 NIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#161-一次CPU-100"><span class="nav-number">2.161.</span> <span class="nav-text">#161 一次CPU 100%</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#162-操作系统内置的计算器可轻松处理程序上的计算"><span class="nav-number">2.162.</span> <span class="nav-text">#162 操作系统内置的计算器可轻松处理程序上的计算</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2011 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">since1986</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">585k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">8:52</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.2</div>




        








        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>



  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  
  <script src="/js/js.cookie.js?v=7.1.2"></script>
  <script src="/js/scroll-cookie.js?v=7.1.2"></script>


  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
