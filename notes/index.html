<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


















  
  
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">







<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.2',
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="前言这里记录一些笔记 正文#1 等待通知机制123456789101112131415161718192021222324252627282930313233343536373839// JVM 实现public class Test2 &amp;#123;    private static final Object LOCK = new Object(); // 注意当作锁的对象一定要是final的，">
<meta property="og:type" content="website">
<meta property="og:title" content="notes">
<meta property="og:url" content="https://since1986.github.io/notes/index.html">
<meta property="og:site_name" content="Since1986">
<meta property="og:description" content="前言这里记录一些笔记 正文#1 等待通知机制123456789101112131415161718192021222324252627282930313233343536373839// JVM 实现public class Test2 &amp;#123;    private static final Object LOCK = new Object(); // 注意当作锁的对象一定要是final的，">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://since1986.github.io/notes/index/1-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/2-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/2-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/7-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/9-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/10-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/11-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/12-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/18-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/18-2.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/18-3.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/18-4.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/20-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/28-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/29-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/39-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/41-1.jpg">
<meta property="og:image" content="https://since1986.github.io/notes/index/47-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/47-2.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/49-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/69-1.png">
<meta property="og:image" content="https://since1986.github.io/notes/index/79-1.jpg">
<meta property="og:updated_time" content="2019-09-30T09:15:08.695Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="notes">
<meta name="twitter:description" content="前言这里记录一些笔记 正文#1 等待通知机制123456789101112131415161718192021222324252627282930313233343536373839// JVM 实现public class Test2 &amp;#123;    private static final Object LOCK = new Object(); // 注意当作锁的对象一定要是final的，">
<meta name="twitter:image" content="https://since1986.github.io/notes/index/1-1.png">





  
  
  <link rel="canonical" href="https://since1986.github.io/notes/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>notes | Since1986</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Since1986</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-notes menu-item-active">

    
    
    
      
    

    

    <a href="/notes/" rel="section"><i class="menu-item-icon fa fa-fw fa-sticky-note-o"></i> <br>notes</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  

  

  <a href="https://github.com/since1986" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

    
    
      
      
    
      
      
    
      
      
    
      
      
    
      
      
    
    

  


          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">notes

</h1>

<div class="post-meta">
  
  



</div>

</header>

      
      
      
      <div class="post-body">
        
        
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里记录一些笔记</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-等待通知机制"><a href="#1-等待通知机制" class="headerlink" title="#1 等待通知机制"></a>#1 等待通知机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JVM 实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object(); <span class="comment">// 注意当作锁的对象一定要是final的，加入不是final的，一个线程用此对象加锁后，这个对象变了，另一个线程再用这个对象加锁就已经是另一把锁了，那么锁就失去语义了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread0 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"即将等待"</span>);</span><br><span class="line">                        LOCK.wait(); <span class="comment">// 释放锁并进入等待</span></span><br><span class="line">                        System.out.println(<span class="string">"等待结束"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK) &#123; <span class="comment">// 注意 synchronized 块，进入代表 lock 也就是 monitorenter</span></span><br><span class="line">                    LOCK.notifyAll(); <span class="comment">// 通知等待的其他人</span></span><br><span class="line">                &#125; <span class="comment">// 注意 synchronized 块，退出代表 unlock 也就是 monitorexit，退出了才释放锁，只有这里释放锁，上边等着的人才能获得锁，这不放，上边永远都进不到 synchronized 块里</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意顺序，等待的先启动，发通知的后启动，要发通知的先启动了，通知空放，等待的空等</span></span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        thread0.join();</span><br><span class="line">        thread1.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// JDK 实现</span><br><span class="line"></span><br><span class="line">public class Test5 &#123;</span><br><span class="line"></span><br><span class="line">    private static Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    private static Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread0 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock(); // 先获得锁</span><br><span class="line">                    condition.await(); // 进入阻塞等待</span><br><span class="line">                    System.out.println(&quot;已被唤醒&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock(); // 释放锁</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock(); // 先获得锁</span><br><span class="line">                    System.out.println(&quot;通知正在阻塞等待的其他人&quot;);</span><br><span class="line">                    condition.signalAll(); // 通知正在阻塞等待的其他人</span><br><span class="line">                    System.out.println(&quot;先不释放锁，停2秒再释放&quot;);</span><br><span class="line">                    Thread.sleep(2000L);</span><br><span class="line">                    System.out.println(&quot;停2秒已到时间了&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock(); // 释放锁</span><br><span class="line">                    System.out.println(&quot;锁已经释放了&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>synchronized</code> 关键字内在的逻辑可以以一个通俗易懂的场景解释，想象一下这个场景：一个只有一个坑位的厕所，一次只能有一个人使用（<code>synchronized (LOCK)</code> ，获得锁的线程可以运行，未获得锁的线程，不能运行），这个人（某个线程）进去关上门插上门闩（也就是获得了锁）该干嘛干嘛，其他人需要在外面排队等待（也就是形成一个名为<code>同步队列</code>的队列），排队的规则是后来的人插入到队尾，然后里面的人解决完了，会打开门闩开开门（释放锁，也就是线程执行已经出了<code>synchronized</code>块）然后告诉队列排在最前面的那一个人（<code>同步队列</code> 头节点），让他进去；而对于 <code>LOCK.wait()</code> 和 <code>LOCK.notifyAll()</code> ,里面涉及到 <code>等待队列</code> 的概念，<code>等待队列</code>的理解可以想象这个场景：还是刚才那个厕所排队，除了厕所里边正在工作的（获得锁的线程），以及门口等待进去的（同步队列中的线程），还有一批（或者多批）人（也就是执行了<code>LOCK.wait()</code>的线程）排成一队打盹，这些人是由原来在坑位门里的人（已经获得了锁的线程）因为某些原因，自己放弃了此次的“工作”，主动形成另一个队伍（<code>等待队列</code>）打盹，这些人不参与排队等着进门（也就是排队获得锁），只有被当前在坑位门里的人（已经获得锁的线程）唤醒时，他们才会重新排到等待进坑位门的队列里（也就是已获得锁的线程执行了 <code>notifyAll()</code> ，就会让<code>等待队列</code>里的线程从<code>等待队列</code>移到<code>同步队列</code>）</p>
<p><code>Lock</code> + <code>Condition</code> 实现等待通知机制，实际上和<code>synchronized</code> 关键字在逻辑上差不太多，都是<code>同步队列</code>和<code>等待队列</code>（但是<code>Condition</code>这个API是可以多个等待队列的），套路还是一个，只是实现的层面不同了，<code>synchronized</code>关键字是JVM层面实现的，<code>Lock</code> + <code>Condition</code>是JDK库层面实现的</p>
<p>另外等待通知有个比较特殊的例子就是<code>Thread</code>的<code>join()</code>，<code>join()</code>内部仍是<code>wait</code>和<code>notify</code>，但是锁对象变成了<code>Thread</code>对象实例，当在上边的代码中执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        thread0.join();</span><br><span class="line">        thread1.join();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>时，可以不严谨的理解为实际上执行者也就是<code>main</code>线程隐式调用了<code>thread0.wait()</code> 和 <code>thread1.wait()</code> 这时<code>main</code>线程就等待了，然后在<code>thread0</code>线程执行结束后，会隐式调用<code>thread0.notifyAll()</code>，在<code>thread1</code>线程执行结束后，会隐式调用<code>thread1.notifyAll()</code>，这样在等待的<code>main</code>线程就被唤醒了。</p>
<p>一张及不严谨的图，大概描述个意思：</p>
<p><img src="/notes/index/1-1.png" alt="图1-1"></p>
<h3 id="2-多态、虚方法表"><a href="#2-多态、虚方法表" class="headerlink" title="#2 多态、虚方法表"></a>#2 多态、虚方法表</h3><p>刚刚看书发现了一个有意思的点，在Java里多态背后的实现是：调用方法的实例在本身存储了自身的类型信息的引用，通过在类型信息引用中查找想要调用方法如果找不到则会去找父类信息，看看那里面有没有定义想要调用的方法，这个过程会一直持续到找不到父类为止，如果父类链路比较深的话则开销会很大，Java的做法是用“虚方法表”这个虚方法表其实就是把一个子类能拥有的所有方法的定义信息（包括从父类继承的）全都事先拽过来存储到自己的类信息里，这样再查找就不要去父类找了（等于用冗余的手段把层次结构扁平花了），我感觉这个和咱们平常业务量做表的冗余字段加速查询是一个套路，套路还是那个套路，只是用的地方不一样了。</p>
<p><img src="/notes/index/2-1.jpg" alt="图2-1"></p>
<p><img src="/notes/index/2-1.jpg" alt="图2-2"></p>
<h3 id="3-类初始化锁"><a href="#3-类初始化锁" class="headerlink" title="#3 类初始化锁"></a>#3 类初始化锁</h3><blockquote>
<p>当多个线程需要初始化一个类,仅有一个线程会进⾏,其他线程需要等待。当活动的线程完成初始化之后, 它必须通知其他等待线程</p>
</blockquote>
<h3 id="4-记录一次JVM-old过高的排查"><a href="#4-记录一次JVM-old过高的排查" class="headerlink" title="#4 记录一次JVM old过高的排查"></a>#4 记录一次JVM old过高的排查</h3><p>今天收到一条报警，有个实例JVM old过高，于是登录上去看了一下。</p>
<ol>
<li><p>首先，<code>jps -l</code> 查到程序进程号为 1161</p>
</li>
<li><p>然后 <code>jstat -gccause 1185 1000 5</code></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                 </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure  </span><br><span class="line">100.00   0.00 100.00 100.00  94.11  87.48     74    9.622   296 2855.880 2865.502 Allocation Failure   Allocation Failure</span><br></pre></td></tr></table></figure>

<p><a href="https://serverfault.com/questions/923717/what-does-gc-allocation-failure-mean-in-my-elasticsearch-5-6-logs" target="_blank" rel="noopener">What does “GC (Allocation Failure)” mean in my ElasticSearch 5.6 logs?</a></p>
<blockquote>
<p>GC (Allocation Failure) is a JVM message (not an Elasticsearch-specific one) that can be a sign that there’s memory pressure, but it’s not catastropic to the JVM (that would cause a OutOfMemoryError log line). It can also be completely innocuous.<br>GC (Allocation Failure) means that the Java garbage collector tried to run, ran out of space in the heap, then tried to allocate more memory. It’s not a bad sign, necessarily. If you’re receiving OutOfMemoryError errors and the JVM is crashing, then you know you’re in trouble.<br>Side note / disclaimer / full disclosure / whatever the heck you want: I work for a DBaaS company that hosts Elasticsearch clusters.</p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/28342736/java-gc-allocation-failure" target="_blank" rel="noopener">Java GC (Allocation Failure)</a></p>
<blockquote>
<p>“Allocation Failure” is a cause of GC cycle to kick in.<br>“Allocation Failure” means that no more space left in Eden to allocate object. So, it is normal cause of young GC.<br>Older JVM were not printing GC cause for minor GC cycles.<br>“Allocation Failure” is almost only possible cause for minor GC. Another reason for minor GC to kick could be CMS remark phase (if +XX:+ScavengeBeforeRemark is enabled).</p>
</blockquote>
<ol start="3">
<li><code>jinfo 1161</code> 可以确认一下应用的JVM参数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Command line:  -Djava.util.logging.config.file=/opt/web/xxx/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Xms4g -Xmx4g -Xmn1024m -Xss1024K -XX:PermSize=256m -XX:MaxPermSize=512m -XX:ParallelGCThreads=8 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+UseCMSCompactAtFullCollection -XX:SurvivorRatio=4 -XX:MaxTenuringThreshold=10 -XX:CMSInitiatingOccupancyFraction=80 -Djava.security.egd=file:/dev/./urandom -DWF.uspcluster= -DWF.uspcluster=xxx -Djava.endorsed.dirs= -Dcatalina.base=/opt/web/xxx -Dcatalina.home=/opt/soft/tomcat8 -Djava.io.tmpdir=/opt/web/xxx/temp</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>jmap -heap 1161</code> 可以看一下堆的整体情况，可以看到，新生代、老年代都已满</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID 1161, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.65-b01</span><br><span class="line"></span><br><span class="line">using parallel threads in the new generation.</span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Concurrent Mark-Sweep GC</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 40</span><br><span class="line">   MaxHeapFreeRatio         = 70</span><br><span class="line">   MaxHeapSize              = 4294967296 (4096.0MB)</span><br><span class="line">   NewSize                  = 1073741824 (1024.0MB)</span><br><span class="line">   MaxNewSize               = 1073741824 (1024.0MB)</span><br><span class="line">   OldSize                  = 3221225472 (3072.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 4</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">New Generation (Eden + 1 Survivor Space):</span><br><span class="line">   capacity = 894828544 (853.375MB)</span><br><span class="line">   used     = 894828536 (853.3749923706055MB)</span><br><span class="line">   free     = 8 (7.62939453125E-6MB)</span><br><span class="line">   99.99999910597398% used</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 715915264 (682.75MB)</span><br><span class="line">   used     = 715915264 (682.75MB)</span><br><span class="line">   free     = 0 (0.0MB)</span><br><span class="line">   100.0% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 178913280 (170.625MB)</span><br><span class="line">   used     = 178913272 (170.62499237060547MB)</span><br><span class="line">   free     = 8 (7.62939453125E-6MB)</span><br><span class="line">   99.99999552855998% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 178913280 (170.625MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 178913280 (170.625MB)</span><br><span class="line">   0.0% used</span><br><span class="line">concurrent mark-sweep generation:</span><br><span class="line">   capacity = 3221225472 (3072.0MB)</span><br><span class="line">   used     = 3221225472 (3072.0MB)</span><br><span class="line">   free     = 0 (0.0MB)</span><br><span class="line">   100.0% used</span><br><span class="line"></span><br><span class="line">62273 interned Strings occupying 7047888 bytes.</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>既然内存被占满了，那么我们需要看看是什么占了内存，使用 <code>jmap -histo 1161</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:      82597943     3245691336  [B</span><br><span class="line">   2:       6768948      541514920  [[B</span><br><span class="line">   3:       6768814      162451536  com.mysql.jdbc.ByteArrayRow</span><br><span class="line">   4:        347621       42931968  [C</span><br><span class="line">   5:         79883       41219352  [Ljava.lang.Object;</span><br><span class="line">   6:        104039        9155432  java.lang.reflect.Method</span><br><span class="line">   7:        343375        8241000  java.lang.String</span><br><span class="line">   8:        220766        7064512  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">   9:         93615        3744600  java.util.LinkedHashMap$Entry</span><br><span class="line">  10:         56944        2733312  org.aspectj.weaver.reflect.ShadowMatchImpl</span><br><span class="line">  </span><br><span class="line">  ...省略</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>com.mysql.jdbc.ByteArrayRow</code> 很可疑，有6768814个实例占了154M多，在他前边的 <code>[B</code> 代表字节数组，有82597943个实例占了3.24G多，<code>[[B</code>代表二位字节数组，他有6768948个实例，占了541M多，基本上这三个货基本把整个堆（从前面jinfo打出的JVM参数可知最大4G）占满了，同时我们找一台正常的实例（与这个实例完全相同的工程、完全相同的配置）看一下他的jmap -histo，对比一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:        190913      105464840  [B</span><br><span class="line">   2:        886653       84314088  [C</span><br><span class="line">   3:        270310       55553000  [I</span><br><span class="line">   4:        191697       16869336  java.lang.reflect.Method</span><br><span class="line">   5:        659489       15827736  java.lang.String</span><br><span class="line">   6:        460922       14749504  java.util.concurrent.locks.AbstractQueuedSynchronizer$Node</span><br><span class="line">   7:        220887        7068384  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">   8:        129368        6858776  [Ljava.lang.Object;</span><br><span class="line">   9:        151208        6048320  java.util.LinkedHashMap$Entry</span><br><span class="line">  10:         77036        5630744  [Ljava.util.HashMap$Node;</span><br></pre></td></tr></table></figure>

<p>经过对比可知，前面排在第三名的 <code>com.mysql.jdbc.ByteArrayRow</code> 基本上可以确定为疑犯了，那么我们就大致确定了排查的方向。</p>
<ol start="6">
<li>来看 <code>com.mysql.jdbc.ByteArrayRow</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A RowHolder implementation that is for cached results (a-la mysql_store_result()).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteArrayRow</span> <span class="keyword">extends</span> <span class="title">ResultSetRow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[][] internalRowData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，这个类里包含了一个二维字节数组，这基本上符合了 <code>[B</code>  <code>[[B</code> <code>com.mysql.jdbc.ByteArrayRow</code> 这三个实例都很多的现象。再往下我们可以结合搜索引擎以及大胆的假设来继续排查下去了。</p>
<ol start="7">
<li>总结一下</li>
</ol>
<p>通过这个实例我们可以得出 <strong>JVM问题排查的一般步骤</strong>：通过工具（调优三大件：jstat jstack jmap 以及其他工具：jps、jinfo、jcmd）观察现象，通过现象加以猜测和对比得出方向，通过方向进一步白盒排查外加猜测尝试得出结论</p>
<h3 id="5-实现一个小顶堆"><a href="#5-实现一个小顶堆" class="headerlink" title="#5 实现一个小顶堆"></a>#5 实现一个小顶堆</h3><p>再写数据结构题时，我们先要搞明白数据结构的定义，以及要写的数据结构有哪些特性，有什么样的行为，有了这些特性、行为的理解，我们才可能写出代码，空中楼阁是造不出来的</p>
<p>可以把数据结构的特性1，2，3，4的列出来再写，另外一开始可以先把次要的元素用简单的东西实现出来（比如我这个小顶堆一开始并没有“节点Node的概念”只是先用一个整形代替了，一开始先关注实现堆的行为，节点是不是对象并不影响堆的行为，可先忽略），实现完主流程然后再回过头来改成更复杂的实现，这样循序渐进，早期把关注点集中在主流程上更容易成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.since1986.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         堆的性质</span></span><br><span class="line"><span class="comment">         1. 父节点比左子节点和右子节点都大或比左子节点和右子节点都小</span></span><br><span class="line"><span class="comment">         2. 节点和兄弟节点之间的大小无所谓(也就是左右子节点之间大小与位置无关)</span></span><br><span class="line"><span class="comment">         3. 每个节点都有编号，根节点编号为1，自根节点向下，从左至右依次顺序编号(也就是编号+1)</span></span><br><span class="line"><span class="comment">         4. 每个节点的编号有这样的规律：某个节点N的有左子节点L和右子节点R，L.number = N.number * 2,  R.number = N.number * 2 + 1,  L.number = R.number + 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         基于堆的上述性质，可以将堆在物理上使用数组存储(编号即是数组索引)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        SmallTopHeap smallTopHeap = <span class="keyword">new</span> SmallTopHeap();</span><br><span class="line">        smallTopHeap.add(<span class="number">10</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">7</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">8</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">5</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">9</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">6</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">4</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">3</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">1</span>);</span><br><span class="line">        smallTopHeap.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(smallTopHeap);</span><br><span class="line"></span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">        System.out.println(smallTopHeap.delete());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小顶堆</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallTopHeap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点索引恒定为1</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ROOT_NODE_INDEX = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正的堆的承载数组是需要扩容的，但是我这个只是演示用的堆，写的简单一点，不支持承载数组扩容</span></span><br><span class="line">        <span class="keyword">private</span> Node[] nodes = <span class="keyword">new</span> Node[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> largestNodeIndex = ROOT_NODE_INDEX;</span><br><span class="line"></span><br><span class="line">        SmallTopHeap() &#123;</span><br><span class="line">            <span class="comment">// 注意数组的索引是从0开始的，但是我为了方便起见，承载数组索引0位置空着不用了，因为概念上堆的索引从要从1开始</span></span><br><span class="line">            nodes[<span class="number">0</span>] = <span class="keyword">new</span> Node(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer nodeValue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (largestNodeIndex &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"这个只是演示用的堆，不支持承载数组扩容"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Node currentNode = <span class="keyword">new</span> Node(nodeValue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入时总是将要插入的节点放在整个堆的最后</span></span><br><span class="line">            <span class="keyword">int</span> currentIndex = largestNodeIndex;</span><br><span class="line">            nodes[currentIndex] = currentNode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入节点以后需要更新最大节点的索引+1(加了一个元素因此最大的索引要 + 1)</span></span><br><span class="line">            <span class="keyword">if</span> (largestNodeIndex &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                largestNodeIndex++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前承载数组中还没有存储根节点，那么当前插入的节点就是根节点，插入完成直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (currentIndex == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前承载数组中已经存储了根节点，那么插入完成后就需要进行校验，检查当前堆是否还符合堆的特性</span></span><br><span class="line">            <span class="comment">// 也就是从新插入节点的父节点开始一直循环比较大小是关系否合规，直到合规或者已经到根节点为止(根节点是编号最小的节点)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到刚刚插入的节点的父节点 parentElementIndex = currentIndex / 2 这里不用考虑当前是右节点还是左节点，不管是哪个节点，得到父节点编号都是简单的除以2即可，我们可以想一下：</span></span><br><span class="line">            <span class="comment">// 假如左子节点索引为 6 那么他的兄弟节点(也就是右节点)索引就是 6 + 1 = 7 父节点索引为 6 / 2 = 3 ，用右节点 7 来推算父节点索引： 7 / 2 = 3，这里 7 除以 2 等于 3 是因为整形除法会丢弃小数点，索引必然都是整形，因此不管是用左子节点还是右子节点来计算父节点的索引，公式都是除以2就可以了</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> parentNodeIndex = currentIndex / <span class="number">2</span>;</span><br><span class="line">                Node parentNode = nodes[parentNodeIndex];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 我们这里是小顶堆(也就是父节点的值小于子节点的值)</span></span><br><span class="line">                <span class="keyword">if</span> (parentNode.value.compareTo(currentNode.value) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果父节点的值小于当前节点的值，是符合小顶堆的特性的，那么循环就可以结束了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 要是父节点的值大于当前节点的值，那么就交换父节点与当前节点</span></span><br><span class="line">                nodes[parentNodeIndex] = currentNode;</span><br><span class="line">                nodes[currentIndex] = parentNode;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将当前索引设置为父节点索引，并且将当前节点设置为父节点这样就可以进行下次循环了</span></span><br><span class="line">                currentIndex = parentNodeIndex;</span><br><span class="line">                currentNode = nodes[currentIndex];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环到了根节点(也就是索引为1的节点)就退出</span></span><br><span class="line">                <span class="keyword">if</span> (currentIndex == ROOT_NODE_INDEX) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Integer <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (largestNodeIndex &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果只剩一个了，直接置空并返回</span></span><br><span class="line">            <span class="keyword">if</span> (largestNodeIndex == <span class="number">1</span>) &#123;</span><br><span class="line">                Node firstNode = nodes[<span class="number">1</span>];</span><br><span class="line">                nodes[<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> firstNode.value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 堆删除节点一般是删除承载数组第一个元素，然后将承载数组最后一个元素填到第一个元素的位置上，然后将最后一个元素置为null，将最后一个元素放到第一个后会破坏原来堆的性质，需要重新调整让整个承载数组重新符合堆的性质</span></span><br><span class="line">            Node nodeThatBeenDeleted = nodes[<span class="number">1</span>];</span><br><span class="line">            Integer result = nodeThatBeenDeleted.value;</span><br><span class="line"></span><br><span class="line">            Node largestIndexNode = nodes[largestNodeIndex];</span><br><span class="line">            nodes[<span class="number">1</span>] = largestIndexNode;</span><br><span class="line">            nodes[largestNodeIndex] = <span class="keyword">null</span>;</span><br><span class="line">            largestNodeIndex--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新调整结构，让承载数组重新符合堆的特性</span></span><br><span class="line">            <span class="comment">// 找到左子节点和右子节点，比较一下它们的值大小，将当前节点的值大小与他们两个之中小的那个进行比较，如果值大于就置换(置换后能保证上边的比下边的小，举个例子 假设当前节点值为 10 它的左子节点值为 5，右子节点值为 6，置换后5变为当前节点，比10和6都小，这样是符合小顶堆的性质的)，如果小于就返回</span></span><br><span class="line">            <span class="keyword">int</span> currentIndex = <span class="number">1</span>;</span><br><span class="line">            Node currentNode = nodes[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> leftChildNodeIndex = currentIndex * <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> rightChildNodeIndex = currentIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 特殊流程1：如果左子节点的索引已经大于最大索引了，那直接跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (leftChildNodeIndex &gt; largestNodeIndex) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 特殊流程2：如果左子节点已经是最后一个了，那么直接比较交换并结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (leftChildNodeIndex == largestNodeIndex) &#123;</span><br><span class="line">                    Node leftChildNode = nodes[leftChildNodeIndex];</span><br><span class="line">                    <span class="keyword">if</span> (leftChildNode.value.compareTo(currentNode.value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    nodes[currentIndex] = leftChildNode;</span><br><span class="line">                    nodes[leftChildNodeIndex] = currentNode;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 普通流程：左子节点没有到最大索引(此时右子节点有可能是最大索引也有可能不是，倒无所谓，不影响流程，走普通流程就好)</span></span><br><span class="line">                    Node leftChildNode = nodes[leftChildNodeIndex];</span><br><span class="line">                    Node rightChildNode = nodes[rightChildNodeIndex];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到左子节点右子节点中小的那个</span></span><br><span class="line">                    Node smallerChild = leftChildNode.value.compareTo(rightChildNode.value) &lt; <span class="number">0</span> ? leftChildNode : rightChildNode;</span><br><span class="line">                    <span class="keyword">int</span> smallerChildIndex = leftChildNode.value.compareTo(rightChildNode.value) &lt; <span class="number">0</span> ? leftChildNodeIndex : rightChildNodeIndex;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 并于当前节点比较，如果小于就返回(父节点比两个子节点小是符合小顶堆性质的，就不用再置换处理了)</span></span><br><span class="line">                    <span class="keyword">if</span> (smallerChild.value.compareTo(currentNode.value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前节点的值大小与他们两个之中小的那个进行比较，如果值大于就置换处理</span></span><br><span class="line">                    nodes[currentIndex] = smallerChild;</span><br><span class="line">                    nodes[smallerChildIndex] = currentNode;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 并将当前索引置为较小子节点的索引，将当前节点置为较小节点，以便进行下一轮循环</span></span><br><span class="line">                    currentIndex = smallerChildIndex;</span><br><span class="line">                    currentNode = nodes[currentIndex];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果已经到了最大索引，就退出循环</span></span><br><span class="line">                    <span class="keyword">if</span> (currentIndex == largestNodeIndex) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StringJoiner(<span class="string">","</span>, <span class="string">"&#123;"</span>, <span class="string">"&#125;"</span>)</span><br><span class="line">                    .add(<span class="string">"\"nodes\":"</span> + Arrays.toString(nodes))</span><br><span class="line">                    .add(<span class="string">"\"largestNodeIndex\":"</span> + largestNodeIndex)</span><br><span class="line">                    .toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> Integer value;</span><br><span class="line"></span><br><span class="line">            Node(Integer value) &#123;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> StringJoiner(<span class="string">":"</span>, <span class="string">"&#123;"</span>, <span class="string">"&#125;"</span>)</span><br><span class="line">                        .add(<span class="string">"\"value\""</span>)</span><br><span class="line">                        .add(String.valueOf(value))</span><br><span class="line">                        .toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;nodes&quot;:[&#123;&quot;value&quot;:null&#125;, &#123;&quot;value&quot;:1&#125;, &#123;&quot;value&quot;:2&#125;, &#123;&quot;value&quot;:5&#125;, &#123;&quot;value&quot;:4&#125;, &#123;&quot;value&quot;:3&#125;, &#123;&quot;value&quot;:8&#125;, &#123;&quot;value&quot;:6&#125;, &#123;&quot;value&quot;:10&#125;, &#123;&quot;value&quot;:7&#125;, &#123;&quot;value&quot;:9&#125;],&quot;largestNodeIndex&quot;:10&#125;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h3 id="6-JMM对64位数据类型有特殊规范"><a href="#6-JMM对64位数据类型有特殊规范" class="headerlink" title="#6 JMM对64位数据类型有特殊规范"></a>#6 JMM对64位数据类型有特殊规范</h3><p>第一点：JMM 规范定义了8种操作（逻辑上的定义）lock、unlock、read、load、use、assign、store、write ，并且有规定：“不允许read和load、store和write操作单一出现”，也就是 read必然伴随load 、store必然伴随write，也就是主内存中的变量同步至工作内存（read和load）这个操作是原子的，同时工作内存中的值同步到主内存这个操作（store和write）也是原子的 我不知道你问题里“原子的”是不是指的这个范畴</p>
<p>第二：以上那两个操作，JMM的设计是：对于64为数据类型，不要求完全遵守，但是强烈建议遵守，商业虚拟机在实现上也一般听从了JMM的建议，将64位类型的那两种操作也实现成了原子的</p>
<h3 id="7-new-都做了什么操作"><a href="#7-new-都做了什么操作" class="headerlink" title="#7 new 都做了什么操作"></a>#7 <code>new</code> 都做了什么操作</h3><p>一个 new 语句分为4步 第一步NEW是创建并默认初始化 然后放到栈顶 然后复制一份栈顶再放到栈顶 然后用栈顶传入 <init> 最后再哪栈顶放到局部变量</init></p>
<p>参考 <a href="https://www.zhihu.com/question/52749416" target="_blank" rel="noopener">关于JVM字节码中dup指令的问题？</a></p>
<p><img src="/notes/index/7-1.png" alt="图7-1"></p>
<h3 id="8-随机数"><a href="#8-随机数" class="headerlink" title="#8 随机数"></a>#8 随机数</h3><p>Java的随机数生成的大致逻辑是：用户提供（或Random类内部自行生成）一个初始的数，然后通过一个公式（名字叫线性同余公式）把这个初始数作为输入给你算出另一个数，用这个过程模拟随机性，构造器里有值就是使用者给初识数，没值就是Random类自己给生成一个初识数（初始数叫做种子）</p>
<h3 id="9-annotation-类型的切入点只在有接口方法声明的前提下生效，为什么"><a href="#9-annotation-类型的切入点只在有接口方法声明的前提下生效，为什么" class="headerlink" title="#9 @annotation 类型的切入点只在有接口方法声明的前提下生效，为什么"></a>#9 @annotation 类型的切入点只在有接口方法声明的前提下生效，为什么</h3><p>昨天那个问题我基本上已经串起来了，我灵机一动看了一下 idea 的调用栈视图（这个方法在整个流程的什么位置已经直观的在调用栈里显示出来了，很清晰，想知道流程就沿着调用栈倒推即可）</p>
<p><img src="/notes/index/9-1.png" alt="图9-1"></p>
<p>大致的是：</p>
<ol>
<li><p>在Spring创建我那个被切入的Service的Bean的时候，也就是 doCreateBean 的时候会执行一个初始化流程，也就是执行这个方法： org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(java.lang.String, java.lang.Object, org.springframework.beans.factory.support.RootBeanDefinition)</p>
</li>
<li><p>在上面这个方法里有一个应用后处理器（BeanPostProcessor）的调用 ，也就是 执行applyBeanPostProcessorsAfterInitialization </p>
</li>
<li><p>在上面那个方法里会调用 BeanPostProcessor的postProcessAfterInitialization，而执行的对象是AbstractAutoProxyCreator，也就是执行这个方法： org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessAfterInitialization</p>
</li>
<li><p>上边那个方法会调用 wrapIfNecessary （Wrap the given bean if necessary, i.e. if it is eligible for being proxied.）</p>
</li>
<li><p>上边那个方法会调用 getAdvicesAndAdvisorsForBean （ Return whether the given bean is to be proxied, what additional advices (e.g. AOP Alliance interceptors) and advisors to apply.）</p>
</li>
<li><p>上边方法会调用 findEligibleAdvisors （Find all eligible Advisors for auto-proxying this class.）也就是找到所有合格的 Advisor （Advisor 是增强器，对应了我们自己写的标注了@Aspect的类中具体对原需要增强方法的增强操作）</p>
</li>
<li><p>然后上边方法调用 findAdvisorsThatCanApply （Search the given candidate Advisors to find all Advisors that）</p>
</li>
<li><p>然后上边调用 findAdvisorsThatCanApply （Determine the sublist of the {@code candidateAdvisors} list that is applicable to the given class.）</p>
</li>
<li><p>然后调用 canApply （Can the given advisor apply at all on the given class?）</p>
</li>
<li><p>然后调用 org.springframework.aop.support.AopUtils#canApply(org.springframework.aop.Pointcut, java.lang.Class<?>, boolean)
这个也就是昨天我加断点的方法，在这个方法里通过切入点定义 Pointcut 以及通过 ClassUtils.getAllInterfacesForClassAsSet(targetClass) 找到的切入目标类的接口（重点是*接口*）然后循环此接口的所有方法来判断是不是能被切入（具体调用 org.springframework.aop.aspectj.AspectJExpressionPointcut#matches(java.lang.reflect.Method, java.lang.Class<?>, boolean) 来判断） 关键就在于是找的是接口而不是实现</p>
</li>
</ol>
<p>切面（Aspect） = 切入点（Pointcut） + 通知（Advice）</p>
<p><em>spring 中 AOP 是通过 BeanPostProcessor 插入到 IoC 流程里的</em></p>
<p><a href="https://www.cnblogs.com/leeSmall/p/10236553.html" target="_blank" rel="noopener">框架源码系列十：Spring AOP（AOP的核心概念回顾、Spring中AOP的用法、Spring AOP 源码学习）</a></p>
<h3 id="10-责任链模式尝试"><a href="#10-责任链模式尝试" class="headerlink" title="#10 责任链模式尝试"></a>#10 责任链模式尝试</h3><p><img src="/notes/index/10-1.png" alt="图10-1"></p>
<h3 id="11-spring配置方式的变更与DRY"><a href="#11-spring配置方式的变更与DRY" class="headerlink" title="#11 spring配置方式的变更与DRY"></a>#11 spring配置方式的变更与DRY</h3><p>Spring的配置信息由外部配置xml的方式改为内部注解配置的方式正是DRY原则的一种体现，原有的xml配置方式你需要将类的完全限定名等元信息重复的在XML里再写一份，而注解则不需要，因为类自己就是对象的元信息，自描述了，当然不需要外部描述了，这正是DRY的一种体现。</p>
<p><img src="/notes/index/11-1.jpg" alt="图11-1"></p>
<h3 id="12-容器管理实例的模式"><a href="#12-容器管理实例的模式" class="headerlink" title="#12 容器管理实例的模式"></a>#12 容器管理实例的模式</h3><p>Spring对于Java中标准的new逻辑的增强，与hibernate中的实体的概念有着异曲同工之妙，都是是用外部容器管理实例，这样可以给整个实例的生命周期中插入很多扩展点，通过扩展点就能玩出很多new玩不出来的新花样</p>
<p><img src="/notes/index/12-1.jpg" alt="图12-1"></p>
<h3 id="13-变成本质的一个方面"><a href="#13-变成本质的一个方面" class="headerlink" title="#13 变成本质的一个方面"></a>#13 变成本质的一个方面</h3><p>编程本质的一个方面：将人类的逻辑转化为机器逻辑。</p>
<p>人类逻辑 -&gt; 自然语言<br>自然语言 -&gt; 高级编程语言<br>高级编程语言 -&gt; 底层编程语言<br>底层编程语言 -&gt; 机器语言<br>机器语言 -&gt; 机器逻辑</p>
<h3 id="14-分析Java线程CPU占用率高的步骤"><a href="#14-分析Java线程CPU占用率高的步骤" class="headerlink" title="#14 分析Java线程CPU占用率高的步骤"></a>#14 分析Java线程CPU占用率高的步骤</h3><ol>
<li><code>jps -l</code> 找到Java进程pid</li>
<li><code>echo &quot;obase=16;&lt;pid&gt;&quot; | bc</code> 得到pid的十六进制值（也可使用在线转换工具）</li>
<li><code>jstack &lt;pid&gt; | grep &lt;pid_hex&gt;</code> 按上一步得到的十六进制pid搜素jstack的输出结果，从而定位到具体的栈信息</li>
<li>根据得到的栈信息进行推测</li>
</ol>
<h3 id="15-对于Spring-IoC的理解"><a href="#15-对于Spring-IoC的理解" class="headerlink" title="#15 对于Spring IoC的理解"></a>#15 对于Spring IoC的理解</h3><p>对于Spring IoC的理解 ：自动化车间。给定原材料（原始类定义）和规格说明书（元数据，包括注解和xml等），就会生产出产品（Bean），在这个期间不需过多干预，但是提供了扩展点可以进行必要的干预（BeanFactoryPostProcessor 和 BeanPostProcessor）</p>
<h3 id="16-Spring的设计哲学"><a href="#16-Spring的设计哲学" class="headerlink" title="#16 Spring的设计哲学"></a>#16 Spring的设计哲学</h3><p>核心功能 + 扩展点</p>
<p>spring的轻量是轻量在设计上 他的微内核设计思想 核心功能BeanFactory很小 很多功能比如自动装配Autoware均是通过扩展点PostProcessor实现的</p>
<p>比如各种Awre如ApplicationContextAware也是通过PostProcessor实现的？<br>AOP也是通过BeanPostProcessor这个扩展点插入的IoC这个主逻辑中的</p>
<h3 id="17-对象的本质是-状态-行为"><a href="#17-对象的本质是-状态-行为" class="headerlink" title="#17 对象的本质是 状态 + 行为"></a>#17 对象的本质是 状态 + 行为</h3><blockquote>
<p>A Class is a software bundle of related states(properties, or variables) and behavior(methods)</p>
</blockquote>
<h3 id="18-Spring-兼容循环依赖的做法"><a href="#18-Spring-兼容循环依赖的做法" class="headerlink" title="#18 Spring 兼容循环依赖的做法"></a>#18 Spring 兼容循环依赖的做法</h3><p><img src="/notes/index/18-1.png" alt="图18-1"></p>
<p><img src="/notes/index/18-2.png" alt="图18-2"></p>
<p><img src="/notes/index/18-3.png" alt="图18-3"></p>
<p><img src="/notes/index/18-4.png" alt="图18-4"></p>
<p>这样加一下断点调一下试试，所有断点都是条件断点 然后两个Bean的无参构造器上加方法断点</p>
<p>先通过 getBean -&gt; createBean 流程创建Bean3实例，然后通过 InstantiationAwareBeanPostProcessorBean3 在其中解析依赖，解析依赖又会触发创建流程创建，创建Bean4实例，然后又会通过 InstantiationAwareBeanPostProcessorBean4  在其中进行Bean4解析依赖拿出来Bean3设置到自己的属性，然后将已经设置了Bean3 的 Bean4 设置到一开始的 Bean3上，这样Bean3和Bean4就实现了循环依赖</p>
<p>这个过程大概通俗一点就是  (A -&gt; (B -&gt; BA)) -&gt; ABA</p>
<p>整个流程应该就是先各自生成一个没依赖的光棍对象Bean，然后把前一个光棍设置后一个光棍当依赖，然后再把已经有依赖的后一个光棍（其实现在已经不是光棍了）设置给前一个光棍当依赖，这样就成了一个环状依赖了</p>
<h3 id="19-Spring-Bean-Scope"><a href="#19-Spring-Bean-Scope" class="headerlink" title="#19 Spring Bean Scope"></a>#19 Spring Bean Scope</h3><p>Spring bean的两种scope的区别在于对待状态的态度 一个是共享状态 一个是状态独立</p>
<h3 id="20-RootBeanDefinition"><a href="#20-RootBeanDefinition" class="headerlink" title="#20 RootBeanDefinition"></a>#20 RootBeanDefinition</h3><p>RootBeanDefinition 是对于容器内实例的定义</p>
<p><img src="/notes/index/20-1.jpg" alt="图20-1"></p>
<h3 id="21-IoC-的两种实现方式-DF-和-DI"><a href="#21-IoC-的两种实现方式-DF-和-DI" class="headerlink" title="#21 IoC 的两种实现方式 DF 和 DI"></a>#21 IoC 的两种实现方式 DF 和 DI</h3><p>通过容器提供的回调Api而非Java语言级别的Api（setter 、构造器）完成控制，这种方式叫做DF也就是依赖查找 是IoC的另一种实现方式</p>
<h3 id="22-对于-IoC-的理解"><a href="#22-对于-IoC-的理解" class="headerlink" title="#22 对于 IoC 的理解"></a>#22 对于 IoC 的理解</h3><p>对于IoC的理解：怎样对待依赖：是自己创建依赖，也就是new还是从外部获取依赖，从外部获取依赖分为DF和DI也就是依赖查找和依赖注入</p>
<h3 id="23-ApplicationContext"><a href="#23-ApplicationContext" class="headerlink" title="#23 ApplicationContext"></a>#23 ApplicationContext</h3><p>ApplicationContext 比 BeanFactory 多了 事件监听机制、MessageSource和统一的资源加载Api（ResourceLoader）,另外比普通BeanFactory 多了 BeanFactoryPostProcessor 可以在ApplicationContext启动时修改Bean声明,比如内置的后处理器PropertyOverrideConfigure就可以用于覆盖Bean中的属性</p>
<h3 id="24-ProxyFactoryBean"><a href="#24-ProxyFactoryBean" class="headerlink" title="#24 ProxyFactoryBean"></a>#24 ProxyFactoryBean</h3><p>ProxyFactoryBean 也是一个重要的扩展点，事物AOP通过这个实现，FactoryBean是个重要的扩展点，</p>
<h3 id="25-Spring事务处理的顶层设计"><a href="#25-Spring事务处理的顶层设计" class="headerlink" title="#25 Spring事务处理的顶层设计"></a>#25 Spring事务处理的顶层设计</h3><p>Spring事务处理的顶层设计：面对事物资源（数据库）用PlatformTransactionManager去对接，而面向客户端代码（业务逻辑）使用AOP来对接（细粒度的实现：ProxyFactoryBean 和 Interceptor 或 粗粒度的实现；TransactionProxyFactoryBean）</p>
<p>事物定义：TransactionDefinition 这个可类比 BeanDefinition</p>
<p>事物属性需TransactionAttribute要事物定义</p>
<p>事物管理器（面向事物资源的顶层接口）需要事物定义 然后返回事物状态，事物状态是面向客户端的接口</p>
<p>Spring允许客户端通过两种方式使用事物支持：编程式（直接使用TransactionManager或用TransactionTemplate）和声明式（用AOP来接入TransactionManager）</p>
<h3 id="26-持续重构"><a href="#26-持续重构" class="headerlink" title="#26 持续重构"></a>#26 持续重构</h3><p>持续重构 说白了其实就是当看到自己之前写的代码有可以改进的地方，比如可以提出方法的逻辑块，就着手改进，而不是放任不管，追求卓越是重构的精髓</p>
<h3 id="27-SpringBoot"><a href="#27-SpringBoot" class="headerlink" title="#27 SpringBoot"></a>#27 SpringBoot</h3><p>SpringBoot 不再像传统 Spring 需要从外部容器的回掉中启动 应用上下文，而是反过来将容器纳入了应用上下文</p>
<h3 id="28-spring-mvc请求处理过程"><a href="#28-spring-mvc请求处理过程" class="headerlink" title="#28 spring-mvc请求处理过程"></a>#28 spring-mvc请求处理过程</h3><p>在某一 Controller 方法上加断点，走到断点处，在调试视图中通过调用栈视图可看到 spring-mvc 的入口点为 FrameworkServlet 的 doService，我们可在此加断点，从新来一遍进行分析</p>
<p><img src="/notes/index/28-1.png" alt="图28-1"></p>
<p><em>整体概念</em></p>
<p>DispatcherServlet 做请求分发</p>
<p>分发是根据 HandlerMapping 获得 Handler 然后封装成 HandlerExecutionChain </p>
<p>HandlerExecutionChain中包含两部分，一部分是标识执行主体的HandlerMethod，另一部分是其拦截器集合，拦截器分别在其执行handle前、后执行。</p>
<p>HandlerMethod 会再封装为 HandlerAdapter 在其中用反射调用真正的 Controller中的方法逻辑</p>
<p><em>大流程</em></p>
<ul>
<li><p>入口 FrameworkServlet 模板方法 doService</p>
</li>
<li><p>DispatcherServlet 实现 doService</p>
</li>
</ul>
<p>org.springframework.web.servlet.DispatcherServlet#doService</p>
<ul>
<li>doDispatch 做请求分发</li>
</ul>
<p>org.springframework.web.servlet.DispatcherServlet#doDispatch</p>
<ul>
<li>getHandler 获得 HandlerExecutionChain，HandlerExecutionChain是Handler（也就是Controller）和一组HandlerInterceptor的聚合 org.springframework.web.servlet.DispatcherServlet#getHandler 其内部处理流程：<ul>
<li>循环 this.handlerMappings 调用每一个 mapping 的 getHandler ：org.springframework.web.servlet.HandlerMapping#getHandler 其内部处理流程：<ul>
<li>org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandlerInternal 获得HandlerMethod（实际上也就是我们写的Controller中各种标记了@RequestMapping的方法包装后的结果）</li>
<li>如果上一步获得的是null那么就获得默认的handler org.springframework.web.servlet.handler.AbstractHandlerMapping#getDefaultHandler</li>
<li>如果上一步默认handler也为null那么直接返回null退出方法</li>
<li>如果 handler instanceof String 那么证明handler是需要通过Bean名字从ApplicationContext里拿，如果是那么就去拿出来</li>
<li>org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandlerExecutionChain 获得 HandlerExecutionChain 并返回，其内部处理流程：<ul>
<li>如果handler不是HandlerExecutionChain类型的，那么将handler套入new HandlerExecutionChain（） 创建成 HandlerExecutionChain</li>
<li>获得Handler的lookupPath，也就是我们自己写的Controller的RequestMapping中的URI</li>
<li>循环所有MappedInterceptor看起是否match到lookupPath，如果match到则此拦截器放到第一步生成的HandlerExecutionChain中然后返回</li>
</ul>
</li>
</ul>
</li>
<li>遇到第一个不为null的HandlerExecutionChain 立刻（跳出循环）返回</li>
</ul>
</li>
</ul>
<ul>
<li><p>将上一步产生的HandlerExecutionChain中的HandlerMethod拿出来当作参数传入getHandlerAdapter获得HandlerAdapter ，HandlerAdapter 是一个SPI，用于外部扩展干预spring-mvc内部流程用的，其内部流程：</p>
<ul>
<li>循环handlerAdapters找到第一个supports的就返回</li>
</ul>
</li>
<li><p>Process last-modified header 处理 last-modified</p>
</li>
<li><p>org.springframework.web.servlet.HandlerExecutionChain#applyPreHandle 进行handle前处理</p>
</li>
<li><p>org.springframework.web.servlet.HandlerAdapter#handle 进行真正的Handler的handle（也就是 Controller 中对应的我们自己实现的逻辑）并返回 ModelAndView 其内部处理流程：</p>
<ul>
<li>调用 checkRequest 校验是否支持当前请求方法类别</li>
<li>将HandlerMethod 封装为 InvocableHandlerMethod 并执行其 invokeAndHandle，在其内部流程中最终会通过反射（ java.lang.reflect.Method#invoke）执行HandlerMethod中对应的我们自己定义的Controller中的方法</li>
<li>调用 getModelAndView 完成并返回</li>
</ul>
</li>
<li><p>org.springframework.web.servlet.DispatcherServlet#applyDefaultViewName 为上一步返回的 ModelAndView 应用DefaultViewName 其内部流程：</p>
</li>
<li><p>org.springframework.web.servlet.HandlerExecutionChain#applyPostHandle 进行handle后处理</p>
</li>
<li><p>org.springframework.web.servlet.DispatcherServlet#processDispatchResult 完成处理</p>
</li>
</ul>
<h3 id="29-Bean"><a href="#29-Bean" class="headerlink" title="#29 @Bean"></a>#29 @Bean</h3><p>@Bean 在 @Componet 和 @Configuration 中语义不同，在 @Configuration 中会被 cglib 增强而在 @Componet 中则不会</p>
<p><img src="/notes/index/29-1.jpg" alt="图29-1"></p>
<h3 id="30-spring-boot-自动配置实现的重要的点"><a href="#30-spring-boot-自动配置实现的重要的点" class="headerlink" title="#30 spring-boot 自动配置实现的重要的点"></a>#30 spring-boot 自动配置实现的重要的点</h3><p>META-INF/spring.factories</p>
<h3 id="31-Controller-注解"><a href="#31-Controller-注解" class="headerlink" title="#31 @Controller 注解"></a>#31 @Controller 注解</h3><p>主要用于标识当前Bean是否是spring-mvc中的 “Handler” 概念</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Expects a handler to have either a type-level @&#123;<span class="doctag">@link</span> Controller&#125;</span></span><br><span class="line"><span class="comment"> * annotation or a type-level @&#123;<span class="doctag">@link</span> RequestMapping&#125; annotation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHandler</span><span class="params">(Class&lt;?&gt; beanType)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||</span><br><span class="line">			AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="32-AbstractHandlerMethodMapping"><a href="#32-AbstractHandlerMethodMapping" class="headerlink" title="#32 AbstractHandlerMethodMapping"></a>#32 AbstractHandlerMethodMapping</h3><p>spring-mvc 注册 Controller与请求映射路径的对应关系的入口在 <code>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#initHandlerMethods</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scan beans in the ApplicationContext, detect and register handler methods.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getCandidateBeanNames()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #processCandidateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #handlerMethodsInitialized</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">			processCandidateBean(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="33-RequestMappingHandlerMapping"><a href="#33-RequestMappingHandlerMapping" class="headerlink" title="#33 RequestMappingHandlerMapping"></a>#33 RequestMappingHandlerMapping</h3><p>RequestMappingHandlerMapping 这个类型的 Bean 是通过 @EnableWebMvc 中的 @Import(DelegatingWebMvcConfiguration.class) 进入容器的</p>
<p>具体的通过：</p>
<p><code>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#requestMappingHandlerMapping</code><br> 注册到容器的</p>
<h3 id="34-ExecutionChain"><a href="#34-ExecutionChain" class="headerlink" title="#34 ExecutionChain"></a>#34 ExecutionChain</h3><p>Spring mvc 的 Handler （也就是Controller）会被链接上若干拦截器然后包装成 ExecutionChain</p>
<h3 id="35-原型方式的Bean是否支持依赖注入？"><a href="#35-原型方式的Bean是否支持依赖注入？" class="headerlink" title="#35 原型方式的Bean是否支持依赖注入？"></a>#35 原型方式的Bean是否支持依赖注入？</h3><p>Spring 本身能够支持 prototype 类型 Bean 的依赖注入，无需特殊处理</p>
<h3 id="36-Lookup"><a href="#36-Lookup" class="headerlink" title="#36 @Lookup"></a>#36 @Lookup</h3><p>@Lookup 用于单例引用另一个单例而另一单例引用原型的场景，如不做处理，这种场景每回得到的原型Bean都是同一实例，因为单例引用单例时不会触发另一个单例中原型的重新创建实例操作，@Lookup 内部的解决方法是将被引用的单例也就是@Lookup所在的单例用cglib每次都生成一个子类实例，每次实例不同这样就可触发引用的原型的实例化了</p>
<p>（如果不用Lookup则那个原型不回生成新实例 那么原型的语义就丢失了）</p>
<h3 id="37-生命周期"><a href="#37-生命周期" class="headerlink" title="#37 生命周期"></a>#37 生命周期</h3><p>关于生命周期：没有容器管理 生命周期只有 new 和 被垃圾回收，有容器管理 容器会给它安排一系列回调比如 PostConstruct</p>
<p>所谓生命周期是容器内部的状态转换，但是一般对外提供回调从而可以进行干预</p>
<h3 id="38-ServletContextListener"><a href="#38-ServletContextListener" class="headerlink" title="#38 ServletContextListener"></a>#38 ServletContextListener</h3><p>ServletContextListener 是Servlet容器提供的扩展点，spring的ContextLoaderListener实现了这个扩展点，是传统 spring-mvc 的入口点</p>
<h3 id="39-Configuration"><a href="#39-Configuration" class="headerlink" title="#39 @Configuration"></a>#39 @Configuration</h3><p>@Configuration 是通过 ConfigurationClassPostProcessor 这个 BeanFactoryPostProcessor 接入的</p>
<p><img src="/notes/index/39-1.jpg" alt="图39-1"></p>
<h3 id="40-什么是语法？"><a href="#40-什么是语法？" class="headerlink" title="#40 什么是语法？"></a>#40 什么是语法？</h3><p>在编程中，语法意味着一个调用命令，输入参数去让应用执行程序的文法结构。这些语法被规则或明或暗的约束。程序员遵循语法规范以和计算机交互。如果一段程序语法不正确，计算机将无法识别。这些语法可以自我释义，支持注释。</p>
<h3 id="41-GC日志释意"><a href="#41-GC日志释意" class="headerlink" title="#41 GC日志释意"></a>#41 GC日志释意</h3><p><img src="/notes/index/41-1.jpg" alt="图41-1"></p>
<h3 id="42"><a href="#42" class="headerlink" title="#42"></a>#42</h3><p>把自己对于一个话题的扩展理解说出来 而不是局限于具有话题本身</p>
<h3 id="43"><a href="#43" class="headerlink" title="#43"></a>#43</h3><p>ServletContainerInitializer 是一种 SPI</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface which allows a library/runtime to be notified of a web</span></span><br><span class="line"><span class="comment"> * application's startup phase and perform any required programmatic</span></span><br><span class="line"><span class="comment"> * registration of servlets, filters, and listeners in response to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementations of this interface may be annotated with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> javax.servlet.annotation.HandlesTypes HandlesTypes&#125;, in order to</span></span><br><span class="line"><span class="comment"> * receive (at their &#123;<span class="doctag">@link</span> #onStartup&#125; method) the Set of application</span></span><br><span class="line"><span class="comment"> * classes that implement, extend, or have been annotated with the class</span></span><br><span class="line"><span class="comment"> * types specified by the annotation.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If an implementation of this interface does not use &lt;tt&gt;HandlesTypes&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * annotation, or none of the application classes match the ones specified</span></span><br><span class="line"><span class="comment"> * by the annotation, the container must pass a &lt;tt&gt;null&lt;/tt&gt; Set of classes</span></span><br><span class="line"><span class="comment"> * to &#123;<span class="doctag">@link</span> #onStartup&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;When examining the classes of an application to see if they match</span></span><br><span class="line"><span class="comment"> * any of the criteria specified by the &lt;tt&gt;HandlesTypes&lt;/tt&gt; annotation</span></span><br><span class="line"><span class="comment"> * of a &lt;tt&gt;ServletContainerInitializer&lt;/tt&gt;, the container may run into</span></span><br><span class="line"><span class="comment"> * classloading problems if any of the application's optional JAR</span></span><br><span class="line"><span class="comment"> * files are missing. Because the container is not in a position to decide</span></span><br><span class="line"><span class="comment"> * whether these types of classloading failures will prevent</span></span><br><span class="line"><span class="comment"> * the application from working correctly, it must ignore them,</span></span><br><span class="line"><span class="comment"> * while at the same time providing a configuration option that would</span></span><br><span class="line"><span class="comment"> * log them. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementations of this interface must be declared by a JAR file</span></span><br><span class="line"><span class="comment"> * resource located inside the &lt;tt&gt;META-INF/services&lt;/tt&gt; directory and</span></span><br><span class="line"><span class="comment"> * named for the fully qualified class name of this interface, and will be </span></span><br><span class="line"><span class="comment"> * discovered using the runtime's service provider lookup mechanism</span></span><br><span class="line"><span class="comment"> * or a container specific mechanism that is semantically equivalent to</span></span><br><span class="line"><span class="comment"> * it. In either case, &lt;tt&gt;ServletContainerInitializer&lt;/tt&gt; services from web</span></span><br><span class="line"><span class="comment"> * fragment JAR files excluded from an absolute ordering must be ignored,</span></span><br><span class="line"><span class="comment"> * and the order in which these services are discovered must follow the</span></span><br><span class="line"><span class="comment"> * application's classloading delegation model.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> javax.servlet.annotation.HandlesTypes</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> Servlet 3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletContainerInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notifies this &lt;tt&gt;ServletContainerInitializer&lt;/tt&gt; of the startup</span></span><br><span class="line"><span class="comment">     * of the application represented by the given &lt;tt&gt;ServletContext&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If this &lt;tt&gt;ServletContainerInitializer&lt;/tt&gt; is bundled in a JAR</span></span><br><span class="line"><span class="comment">     * file inside the &lt;tt&gt;WEB-INF/lib&lt;/tt&gt; directory of an application,</span></span><br><span class="line"><span class="comment">     * its &lt;tt&gt;onStartup&lt;/tt&gt; method will be invoked only once during the</span></span><br><span class="line"><span class="comment">     * startup of the bundling application. If this</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;ServletContainerInitializer&lt;/tt&gt; is bundled inside a JAR file</span></span><br><span class="line"><span class="comment">     * outside of any &lt;tt&gt;WEB-INF/lib&lt;/tt&gt; directory, but still</span></span><br><span class="line"><span class="comment">     * discoverable as described above, its &lt;tt&gt;onStartup&lt;/tt&gt; method</span></span><br><span class="line"><span class="comment">     * will be invoked every time an application is started.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the Set of application classes that extend, implement, or</span></span><br><span class="line"><span class="comment">     * have been annotated with the class types specified by the </span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> javax.servlet.annotation.HandlesTypes HandlesTypes&#125; annotation,</span></span><br><span class="line"><span class="comment">     * or &lt;tt&gt;null&lt;/tt&gt; if there are no matches, or this</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;ServletContainerInitializer&lt;/tt&gt; has not been annotated with</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;HandlesTypes&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx the &lt;tt&gt;ServletContext&lt;/tt&gt; of the web application that</span></span><br><span class="line"><span class="comment">     * is being started and in which the classes contained in &lt;tt&gt;c&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * were found</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException if an error has occurred</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="44-JVM内存划分"><a href="#44-JVM内存划分" class="headerlink" title="#44 JVM内存划分"></a>#44 JVM内存划分</h3><p>JVM 分为 堆 Java栈 native栈 方法区 PC</p>
<p>Java栈 中是 帧</p>
<p>桢中包含 本地变量表 异常处理表 操作数栈 常量池指针</p>
<p>调用方法时帧入栈 return或exception时帧出栈</p>
<h3 id="45-栈上分配"><a href="#45-栈上分配" class="headerlink" title="#45 栈上分配"></a>#45 栈上分配</h3><p>栈上分配：经逃逸分析后发现未逃逸（也就是没有其他引用到的地方）那么会分配到栈上，标量替换 将对象的属性拆出来各自分配到栈 <a href="http://blueskykong.com/2019/07/13/kong1/" target="_blank" rel="noopener">http://blueskykong.com/2019/07/13/kong1/</a></p>
<h3 id="46-HashMap"><a href="#46-HashMap" class="headerlink" title="#46 HashMap"></a>#46 HashMap</h3><p>HashMap 获得节点的逻辑 ： 入参为 key 的 hash 值和 key 的值<br>先用 key的hash值 &amp; (桶数组长度 - 1)也就是对于桶长度取模，也就是掩码操作得出key在桶中index由此index拿出元素，若此元素和key的hash值相同并且此元素的key和给定的key相同 那么直接返回此元素</p>
<p>如果不满足上边条件，同时此元素有后继，则一路看其后继的 hash、key是否与传入值相等（这里分为两种情况，如果当前元素为树节点，则走树检索，若不是树节点则走普通的链表检索）</p>
<h3 id="47-HashMap-是扩容成2倍"><a href="#47-HashMap-是扩容成2倍" class="headerlink" title="#47 HashMap 是扩容成2倍"></a>#47 HashMap 是扩容成2倍</h3><p>HashMap 是扩容成2倍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">         oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">    newThr = oldThr &lt;&lt; 1; // double threshold</span><br></pre></td></tr></table></figure>

<p>左移1位等效于 *2</p>
<p>HashMap 扩容时 如果节点是普通的节点 则用新的容量作为掩码从新计算原来元素的的索引<br>newTab[e.hash &amp; (newCap - 1)] = e;</p>
<p>注意：是不需要计算索引下标，节点的Hash值是不会发生变化的！！！<br>&amp;运算的定义：两位同时为”1”，结果才为”1”，否则为0<br>首先，我们先根据下标计算公式得出扩容前后索引的变化</p>
<p><img src="/notes/index/47-1.png" alt="图47-1"></p>
<p>根据图片可知，扩容后的21的索引下标比扩容前的索引下标多了一个1，且这个1位于newCap-1的掩码最高位<br>结论：元素在重新计算hash后，因为n变为2倍，那么n-1的mask范围在高位多1bit，即多了个原容量的距离<br>优化：无需重新计算Hash，节省了时间，新索引=原索引+原容量</p>
<p><a href="https://www.zybuluo.com/kiraSally/note/836217" target="_blank" rel="noopener">集合番@HashMap一文通（1.8版）</a></p>
<p>(e.hash &amp; bit) 实际上是为了达到一个布尔值的效果 (e.hash &amp; bit) == 0 相当于 true 否则为 false</p>
<p><img src="/notes/index/47-2.png" alt="图47-2"></p>
<h3 id="48-自学英语"><a href="#48-自学英语" class="headerlink" title="#48 自学英语"></a>#48 自学英语</h3><p><a href="https://www.jianshu.com/p/f90f35ab32cb" target="_blank" rel="noopener">自学英语阶段记录二</a></p>
<h3 id="49-ConcurrentHashMap"><a href="#49-ConcurrentHashMap" class="headerlink" title="#49 ConcurrentHashMap"></a>#49 ConcurrentHashMap</h3><p>ConcurrentHashMap 的 update操作 happen-before retrieval操作 </p>
<p>More formally, an update operation for a given key bears a<br><em>happens-before</em> relation with any (non-null) retrieval for<br>that key reporting the updated value.</p>
<p>ConcurrentHashMap 的 update操作 happen-before retrieval操作 </p>
<p>ConcurrentHashMap 的 size 当没有并非更新时才有用 它返回的是个近似值 或者说是个不能保证完全准确的值</p>
<p>ConcurrentHashMap 不能允许 null 键 HashMap可有有null键</p>
<p>不能为null的一点原因:</p>
<p>Conversely, because keys<br>and values in the map are never null, null serves as a reliable<br>atomic indicator of the current lack of any result. </p>
<p>ConcurrentHashMap取消了segment分段锁，而采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。<br>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。<br>JDK1.8的ConcurrentHashMap的结构图如下：</p>
<p><img src="/notes/index/49-1.png" alt="图49-1"></p>
<p> JDK8中的实现也是锁分离的思想，它把锁分的比segment（JDK1.5）更细一些，只要hash不冲突，就不会出现并发获得锁的情况。它首先使用无锁操作CAS插入头结点，如果插入失败，说明已经有别的线程插入头结点了，再次循环进行操作。如果头结点已经存在，则通过synchronized获得头结点锁，进行后续的操作。性能比segment分段锁又再次提升。</p>
<p>也就是乐观的思想：大部分插入由于hash值并不冲突（hash冲突毕竟是少数）因此并不需要加锁，少部分有hash冲突的插入</p>
<h3 id="50-CAS"><a href="#50-CAS" class="headerlink" title="#50 CAS"></a>#50 CAS</h3><p>Java CAS 通过 unsafe调用底层 cmpxchgl 指令的支持实现 用记数量比对来避免ABA</p>
<h3 id="51-hash索引"><a href="#51-hash索引" class="headerlink" title="#51 hash索引"></a>#51 hash索引</h3><p>hash索引存储上无序无法应对区间查询 只能用于等值查询 B+树索引存储有序 hash索引不支持复合索引左匹配 B+树索引叶节点可能存储整行数据或主键值</p>
<h3 id="52-覆盖索引"><a href="#52-覆盖索引" class="headerlink" title="#52 覆盖索引"></a>#52 覆盖索引</h3><p>覆盖索引就是从索引就能直接拿到想要的值不用回表</p>
<h3 id="53-mysql复合索引"><a href="#53-mysql复合索引" class="headerlink" title="#53 mysql复合索引"></a>#53 mysql复合索引</h3><p>mysql复合索引 前边的字段是定值那就只需要考虑后边的字段顺序就可以了 因为复合索引是将 所有字段 concat 以后排序的 前边是定值就不需要考虑他的顺序了</p>
<p>左匹配原则是 查询条件中包含的字段能从复合索引最左侧开始的字段匹配上 就一直能用到这个索引 直到中间断档了或者是不等值查询了 后边字段就用不到索引了</p>
<p>从某个字段断档或者不是等值查询就意味着无法在树节点上确定前部分的顺序 前部分无序则后边是有序还是无序整体上都是无序的 而无序就无法使用二分查找 因此也就是无法使用索引带来的查询时间复杂度降低了</p>
<p>最左匹配：查询条件中必须存在复合索引中最左边那个字段</p>
<blockquote>
<p>全值匹配我最爱，最左前缀要遵守；</p>
<p>带头大哥不能死，中间兄弟不能断；</p>
<p>索引列上少计算，范围之后全失效；</p>
<p>LIKE百分写最右，覆盖索引不写星；</p>
<p>不等空值还有or，索引失效要少用。</p>
</blockquote>
<p><a href="https://chenjiabing666.github.io/2018/09/07/mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">mysql索引优化详解</a></p>
<p>带头大哥不能死并且中间兄弟不能断</p>
<p>abc这个索引 where a= and c= 这种中间少了b 也就是中间兄弟断了不能用索引</p>
<p>where b= and c= 这种没有开头的a 带头大哥死了也不能用索引</p>
<h3 id="54-UUID"><a href="#54-UUID" class="headerlink" title="#54 UUID"></a>#54 UUID</h3><p>uuid作为主键的话由于uuid任意两个实体间本身无序 在构建索引时回造成页频繁分裂和调整 从而导致插入效率变低</p>
<p>而顺序主键则依次插入 到插入不下时才会页分裂 而由于是顺序插入因此其插入不下的情况较少 因此页分裂不频繁 插入效率高</p>
<h3 id="55-redolog、undolog"><a href="#55-redolog、undolog" class="headerlink" title="#55 redolog、undolog"></a>#55 redolog、undolog</h3><p>redolog永远灾后重新提交 undolog用于回滚</p>
<p>redolog记录物理页修改 undolog记录回滚逻辑</p>
<h3 id="56-通过间隙锁解决幻读"><a href="#56-通过间隙锁解决幻读" class="headerlink" title="#56 通过间隙锁解决幻读"></a>#56 通过间隙锁解决幻读</h3><p>行级锁分为 记录锁 间隙锁 临间锁</p>
<p>select for update 会在行上加排他锁</p>
<h3 id="57-ObjectId"><a href="#57-ObjectId" class="headerlink" title="#57 ObjectId"></a>#57 ObjectId</h3><p>时间戳 + 主机名hash + pid + 自增</p>
<h3 id="58-Redis删除策略"><a href="#58-Redis删除策略" class="headerlink" title="#58 Redis删除策略"></a>#58 Redis删除策略</h3><p>redis使用定期删除+惰性删除（也就是触发式删除）</p>
<h3 id="59-Redis高性能"><a href="#59-Redis高性能" class="headerlink" title="#59 Redis高性能"></a>#59 Redis高性能</h3><p>redis通过io多路复用实现高性能</p>
<h3 id="60-io多路复用"><a href="#60-io多路复用" class="headerlink" title="#60 io多路复用"></a>#60 io多路复用</h3><p>io多路复用模块监听多个FD当事件来临回调FD绑定处理器处理</p>
<p>epoll 比 select的优势在于不用遍历fd数组，。</p>
<p>在 epoll_wait 函数返回时会提供一个 epoll_event 数组：其中保存了事件以及发生事件的fd </p>
<h3 id="61-Redis哨兵"><a href="#61-Redis哨兵" class="headerlink" title="#61 Redis哨兵"></a>#61 Redis哨兵</h3><p>redis通过哨兵模式实现高可用</p>
<h3 id="62-setNX"><a href="#62-setNX" class="headerlink" title="#62 setNX"></a>#62 setNX</h3><p>setNX指令可实现分布式锁</p>
<h3 id="63-synchronized-锁升级"><a href="#63-synchronized-锁升级" class="headerlink" title="#63 synchronized 锁升级"></a>#63 synchronized 锁升级</h3><p>synchronized 偏向锁 在对象头中用CAS记录线程ID 若有竞争升级为轻量锁 轻量锁自旋获得锁 自旋次数到阈值或又多了一个线程竞争那么升级为重量锁</p>
<h3 id="64-Kafka"><a href="#64-Kafka" class="headerlink" title="#64 Kafka"></a>#64 Kafka</h3><p>Kafka单分区有序</p>
<h3 id="65-Xmn"><a href="#65-Xmn" class="headerlink" title="#65 Xmn"></a>#65 Xmn</h3><p>Xmn一般设置为整个堆空间的1/3或1/4</p>
<h3 id="66-模拟内存分配"><a href="#66-模拟内存分配" class="headerlink" title="#66 模拟内存分配"></a>#66 模拟内存分配</h3><p>可用新建byte数组的方式模拟内存分配</p>
<h3 id="67-CardTable"><a href="#67-CardTable" class="headerlink" title="#67 CardTable"></a>#67 CardTable</h3><p>CardTable用来记录老年代某个区域是否持有新生代引用，这样新生代在GC时不必遍历老年代查看是否持有引用而只需先看卡表中是否为1，是才需要扫描对应的老年代</p>
<p>卡表里实际上就是存的一堆flag</p>
<h3 id="68-水平分表"><a href="#68-水平分表" class="headerlink" title="#68 水平分表"></a>#68 水平分表</h3><p>水平分表用字段作为依据分 如取模</p>
<h3 id="69-spring-Bean-生命周期"><a href="#69-spring-Bean-生命周期" class="headerlink" title="#69 spring Bean 生命周期"></a>#69 spring Bean 生命周期</h3><p><img src="/notes/index/69-1.png" alt="图69-1"></p>
<h3 id="70-zset"><a href="#70-zset" class="headerlink" title="#70 zset"></a>#70 zset</h3><p>zset计算排行排</p>
<h3 id="71-mvcc"><a href="#71-mvcc" class="headerlink" title="#71 mvcc"></a>#71 mvcc</h3><p>mvcc 读不加锁 读写不冲突</p>
<h3 id="72-MySQL事务隔离级别"><a href="#72-MySQL事务隔离级别" class="headerlink" title="#72 MySQL事务隔离级别"></a>#72 MySQL事务隔离级别</h3><p>脏读：一个事务读到了另一个事务还未提交的数据 见于read uncommited</p>
<p>不可重复读：一个事务中两次相同的查询得到不同的结果（另一个事务在两次读之间提交事务修改了数据） 见于 read commited</p>
<p>幻读：见于 用读来确认是否已存在，不存在才能插入然后再执行插入 的情况 事务1查询是否能插入后事务2完成了插入然后事务1插入时发现已存在了就不能插入了，但实际上事务上一步时得到的结果是能插入的 这样就造成了事物第一步得到的结论是幻像的结果 也就是所谓幻读</p>
<p>理论上 repeatable read 不能防止幻读 但是？</p>
<h3 id="73"><a href="#73" class="headerlink" title="#73"></a>#73</h3><p><a href="https://juejin.im/post/5d905039e51d45782d053ca3" target="_blank" rel="noopener">https://juejin.im/post/5d905039e51d45782d053ca3</a> 极为靠后的分页 大量数据后的分页 可用 定位偏移位置的 id，然后往后查询的办法解决</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> orders_history <span class="keyword">where</span> <span class="keyword">type</span>=<span class="number">8</span> <span class="keyword">limit</span> <span class="number">100000</span>,<span class="number">1</span>; <span class="keyword">select</span> * <span class="keyword">from</span> orders_history <span class="keyword">where</span> <span class="keyword">type</span>=<span class="number">8</span> <span class="keyword">and</span> <span class="keyword">id</span>&gt;=(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> orders_history <span class="keyword">where</span> <span class="keyword">type</span>=<span class="number">8</span> <span class="keyword">limit</span> <span class="number">100000</span>,<span class="number">1</span>) <span class="keyword">limit</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>或者从业务上优化 避免掉这种情况</p>
<h3 id="74-mvcc原理"><a href="#74-mvcc原理" class="headerlink" title="#74 mvcc原理"></a>#74 mvcc原理</h3><p>mvcc ：聚簇索引包含两个隐藏列 trx_id 每次对聚簇索引修改都会将事务id赋给trx_id，roll_pointer 每次聚簇索引改动后都会将 undo日志中对应内容的指针赋给roll_pointer</p>
<p>ReadView 包含了当前所有事务的id的列表m_ids 然后如果trx_id 小于m_ids中最小值则说明对应事务在生成ReadView之前已经提交 那么该版本就可以被当前的m_ids对应对事物们可见</p>
<p>如果trx_id大于m_ids最大值 则说明 trx_id对应的事物在 ReadView创建之后 那么m_ids对应的事物们不能访问此版本</p>
<p>如果trx_id大小介于m_ids的最小值和最大值之间同时不与m_ids中任何一个数相等则说明生成ReadView时事物已提交则可以访问</p>
<p>如果大小介于之间并且存在等值则说明此事物还活跃则不可访问</p>
<p>某个trx_id对m_ids不可访问就依次沿版本链找下一版本的trx_id重复以上过程直到找不到trx_id为止</p>
<p><a href="https://juejin.im/post/5c9b1b7df265da60e21c0b57#heading-10" target="_blank" rel="noopener">MySQL事务隔离级别和MVCC</a></p>
<h3 id="75-CountDownLatch"><a href="#75-CountDownLatch" class="headerlink" title="#75 CountDownLatch"></a>#75 CountDownLatch</h3><p>new CountDownLatch(10) 设置 AQS state 为 10</p>
<p>count() ：</p>
<ol>
<li>用 CAS 给 state进行 state-1 操作，减完后判断如果为 0 返回true</li>
<li>如果上一步返回了 true 那么就调用 AQS 的doReleaseShared()流程 也就是唤醒等待队列头节点的流程</li>
</ol>
<p>在需要等待的线程中await() 这个会调用 AQS 的 doAcquireSharedInterruptibly()<br>AQS 的 doAcquireSharedInterruptibly() 会判断tryAcquireShared(1) 的返回值，如果大于0就让等待的出队 如果小于0则让其入等待队列队 </p>
<p>而 CountDownLatch 的tryAcquireShared(1)返回的是 -1 是小于0的，也就是上一步中会进入等待的的分支，因此当前调用的线程会等待</p>
<h3 id="76-TCP三次握手"><a href="#76-TCP三次握手" class="headerlink" title="#76 TCP三次握手"></a>#76 TCP三次握手</h3><p>三次握手：<br>1 客户端 sync<br>2 服务端 ack + sync<br>3 客户端 ack</p>
<h3 id="77-TCP四次挥手"><a href="#77-TCP四次挥手" class="headerlink" title="#77 TCP四次挥手"></a>#77 TCP四次挥手</h3><p>四次挥手：客户端和服务端均可为主动方</p>
<p>1 主动方 fin + ack<br>2 被动方 ack<br>3 被动方 fin<br>4 主动方 ack</p>
<p>主动方最后收到被动方的fin后需要time_wait一下（一般4分种）然后才close</p>
<h3 id="78-滑动窗口"><a href="#78-滑动窗口" class="headerlink" title="#78 滑动窗口"></a>#78 滑动窗口</h3><p>滑动窗口：<br>要是一个包一个包的发送-确认 发送-确认 效率太低，因此需要一次性发多个包</p>
<p>缓存大小就是窗口 一次性发出去多个包 收到第一个 ack 就将缓存第一个值赶出去，同时最后一个值后面的值进来一个 一点一点往后滑动着重复这个过程：走一个来一个 走一个来一个。。。 就像是拉链一样 拉链能容纳的拉齿数量就是窗口大小 拉链拉过去就是出一个进一个</p>
<p>如果拉链头那个没收到ack（也就是超时）那么就需要重传，只有他收到ack才能继续往后拉</p>
<p>也就近似类似于拉拉链卡在某个齿了那么就再试一下（超时重传）</p>
<p><a href="https://juejin.im/post/5c9f1dd651882567b4339bce" target="_blank" rel="noopener">一篇带你读懂TCP之“滑动窗口”协议</a></p>
<h3 id="79-netty线程模型"><a href="#79-netty线程模型" class="headerlink" title="#79 netty线程模型"></a>#79 netty线程模型</h3><p>netty线程模型：同时支持 Reactor单线程 Reactor多线程 主从Reactor多线程</p>
<p><img src="/notes/index/79-1.jpg" alt="图79-1"></p>
<p>client -&gt; Reactor Thread(内部含有Dispatcher Acceptor接收TCP连接请求 链路建成后通过Dispatcher把ByteBuffer派发到Handler</p>
<h3 id="80-Reactor-模型"><a href="#80-Reactor-模型" class="headerlink" title="#80 Reactor 模型"></a>#80 Reactor 模型</h3><p>Acceptor相当于店小二招呼客人建立好菜单 然后发给厨师让他们处理菜单上的请求</p>
<p>Reactor单线程：一个店小二一个厨师</p>
<p>Reactor多线程：一个店小二多个厨师</p>
<p>Reactor主从多线程：一个总店小二发派多个店小二，然后店小二们发派多个厨师</p>
<h3 id="81-netty-handler无锁设计"><a href="#81-netty-handler无锁设计" class="headerlink" title="#81 netty handler无锁设计"></a>#81 netty handler无锁设计</h3><p>netty handler处理时不切换线程 这样不需要加锁 不存在切换成本 类似于一道菜从头到尾只有一个厨师负责做</p>
<h3 id="82-粘包拆包"><a href="#82-粘包拆包" class="headerlink" title="#82 粘包拆包"></a>#82 粘包拆包</h3><p>TCP粘包：收到多个包黏在一起</p>
<p>TCP拆包：一个包被分为两部分 一次收到一部分</p>
<p>解决方案：在上层协议栈解决</p>
<p>1 消息定长</p>
<p>2 包尾分隔符</p>
<p>3 分为消息头和消息体 在消息头中包含消息总长度</p>
<p>netty使用编/解码器解决拆包黏包</p>
<h3 id="83-Linux-io模型"><a href="#83-Linux-io模型" class="headerlink" title="#83 Linux io模型"></a>#83 Linux io模型</h3><p>Linux io模型：</p>
<p>阻塞io： 进程调用recvfrom后一直等待数据包到达应用进程缓冲区或返回错误后再执行</p>
<p>非阻塞io：recvfrom没数据返回的话之间返回错误让进程继续 然后轮询看看是否有数据到来</p>
<p>io多路复用：select或epoll 进程将fd传给select或poll系统调用阻塞在select/poll上select/poll替进程（也就是不用像普通非阻塞io那样进程自己轮询了 而是让帮手轮询）轮询看看是否有数据来</p>
<p>epoll：比select队列基于事件的处理 不必每次完整轮询一遍 而是有就绪的就会入一个数组 然后回调告知有数据</p>
<p>类比：</p>
<p>阻塞io：客人自己点完菜只能傻等着菜来别的什么也不能做</p>
<p>非阻塞io：客人点完菜需要不断询问厨师做好了没有直到菜来</p>
<p>select：客人点完菜自己干点别的事，店小二不断问厨师菜好了没有，好了就端过来给客人</p>
<p>epoll：客人点完菜自己干点别的事，厨师做好菜了会放到一个固定的取菜窗口并按铃告诉店小二过来拿菜，店小二拿了菜给客人</p>
<p>epoll通过mmap加速了内存从内核空间到用户空间的拷贝</p>
<p>epoll不受fd数量限制</p>
<p>epoll不会因为fd数量增加而效率线性下降</p>
<h3 id="84-netty零拷贝"><a href="#84-netty零拷贝" class="headerlink" title="#84 netty零拷贝"></a>#84 netty零拷贝</h3><p>netty零拷贝：通过CompositeByteBuf等机制实现数据不需频繁的复制粘贴</p>
<h3 id="85-一致性Hash"><a href="#85-一致性Hash" class="headerlink" title="#85 一致性Hash"></a>#85 一致性Hash</h3><p>负载均衡时用普通的 hash 算法比如 对集群节点数取模 当集群大小发生变化时，hash需要重新计算，否则原hash可能无法命中</p>
<p>一致性 hash 做法是将 hash 范围定位一个有上限的范围区间</p>
<p>然后将节点进行 hash 到这个区间内</p>
<p>数据的位置也是做 hash 然后看看数据的hash离哪个节点的hash近，就归属于哪个节点（小蝌蚪找妈妈）当某个节点掉线从范围内摘除，其影响到的是hash值比起小的最接近的又比另一个比其小节点大的这一批数据，而不是全部数据，这样就降低了rehash的成本</p>
<p>一致性hash如果节点少的可能造成数据倾斜 解决办法是一个节点生成多个hash 也就是一个节点当作n个节点</p>

        
      </div>
      
      
      
    </div>
    



    
    
    
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar215x215.png" alt="since1986">
            
              <p class="site-author-name" itemprop="name">since1986</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">149</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/since1986" title="GitHub &rarr; https://github.com/since1986" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:385741668@qq.com" title="E-Mail &rarr; mailto:385741668@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://twitter.com/_since1986_" title="Twitter &rarr; https://twitter.com/_since1986_" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.linkedin.com/in/fan-zhang-since1986" title="Linkedin &rarr; https://www.linkedin.com/in/fan-zhang-since1986" rel="noopener" target="_blank"><i class="fa fa-fw fa-linkedin"></i>Linkedin</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://since1986.github.io/" title="https://since1986.github.io/">我的主站</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://since1986.coding.me/" title="https://since1986.coding.me/" rel="noopener" target="_blank">我的高速镜像站</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.720ui.com/" title="http://blog.720ui.com/" rel="noopener" target="_blank">梁桂钊的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://chenyongjun.vip/" title="http://chenyongjun.vip/" rel="noopener" target="_blank">码代码的陈同学</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://qixiaobo.site/" title="https://qixiaobo.site/" rel="noopener" target="_blank">后端之路</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xilidou.com/" title="https://xilidou.com/" rel="noopener" target="_blank">犀利豆的博客</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正文"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-等待通知机制"><span class="nav-number">2.1.</span> <span class="nav-text">#1 等待通知机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-多态、虚方法表"><span class="nav-number">2.2.</span> <span class="nav-text">#2 多态、虚方法表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-类初始化锁"><span class="nav-number">2.3.</span> <span class="nav-text">#3 类初始化锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-记录一次JVM-old过高的排查"><span class="nav-number">2.4.</span> <span class="nav-text">#4 记录一次JVM old过高的排查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-实现一个小顶堆"><span class="nav-number">2.5.</span> <span class="nav-text">#5 实现一个小顶堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-JMM对64位数据类型有特殊规范"><span class="nav-number">2.6.</span> <span class="nav-text">#6 JMM对64位数据类型有特殊规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-new-都做了什么操作"><span class="nav-number">2.7.</span> <span class="nav-text">#7 new 都做了什么操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-随机数"><span class="nav-number">2.8.</span> <span class="nav-text">#8 随机数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-annotation-类型的切入点只在有接口方法声明的前提下生效，为什么"><span class="nav-number">2.9.</span> <span class="nav-text">#9 @annotation 类型的切入点只在有接口方法声明的前提下生效，为什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-责任链模式尝试"><span class="nav-number">2.10.</span> <span class="nav-text">#10 责任链模式尝试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-spring配置方式的变更与DRY"><span class="nav-number">2.11.</span> <span class="nav-text">#11 spring配置方式的变更与DRY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-容器管理实例的模式"><span class="nav-number">2.12.</span> <span class="nav-text">#12 容器管理实例的模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-变成本质的一个方面"><span class="nav-number">2.13.</span> <span class="nav-text">#13 变成本质的一个方面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-分析Java线程CPU占用率高的步骤"><span class="nav-number">2.14.</span> <span class="nav-text">#14 分析Java线程CPU占用率高的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-对于Spring-IoC的理解"><span class="nav-number">2.15.</span> <span class="nav-text">#15 对于Spring IoC的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-Spring的设计哲学"><span class="nav-number">2.16.</span> <span class="nav-text">#16 Spring的设计哲学</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-对象的本质是-状态-行为"><span class="nav-number">2.17.</span> <span class="nav-text">#17 对象的本质是 状态 + 行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-Spring-兼容循环依赖的做法"><span class="nav-number">2.18.</span> <span class="nav-text">#18 Spring 兼容循环依赖的做法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-Spring-Bean-Scope"><span class="nav-number">2.19.</span> <span class="nav-text">#19 Spring Bean Scope</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-RootBeanDefinition"><span class="nav-number">2.20.</span> <span class="nav-text">#20 RootBeanDefinition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-IoC-的两种实现方式-DF-和-DI"><span class="nav-number">2.21.</span> <span class="nav-text">#21 IoC 的两种实现方式 DF 和 DI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-对于-IoC-的理解"><span class="nav-number">2.22.</span> <span class="nav-text">#22 对于 IoC 的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-ApplicationContext"><span class="nav-number">2.23.</span> <span class="nav-text">#23 ApplicationContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-ProxyFactoryBean"><span class="nav-number">2.24.</span> <span class="nav-text">#24 ProxyFactoryBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-Spring事务处理的顶层设计"><span class="nav-number">2.25.</span> <span class="nav-text">#25 Spring事务处理的顶层设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-持续重构"><span class="nav-number">2.26.</span> <span class="nav-text">#26 持续重构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-SpringBoot"><span class="nav-number">2.27.</span> <span class="nav-text">#27 SpringBoot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-spring-mvc请求处理过程"><span class="nav-number">2.28.</span> <span class="nav-text">#28 spring-mvc请求处理过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-Bean"><span class="nav-number">2.29.</span> <span class="nav-text">#29 @Bean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-spring-boot-自动配置实现的重要的点"><span class="nav-number">2.30.</span> <span class="nav-text">#30 spring-boot 自动配置实现的重要的点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-Controller-注解"><span class="nav-number">2.31.</span> <span class="nav-text">#31 @Controller 注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-AbstractHandlerMethodMapping"><span class="nav-number">2.32.</span> <span class="nav-text">#32 AbstractHandlerMethodMapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-RequestMappingHandlerMapping"><span class="nav-number">2.33.</span> <span class="nav-text">#33 RequestMappingHandlerMapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-ExecutionChain"><span class="nav-number">2.34.</span> <span class="nav-text">#34 ExecutionChain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-原型方式的Bean是否支持依赖注入？"><span class="nav-number">2.35.</span> <span class="nav-text">#35 原型方式的Bean是否支持依赖注入？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-Lookup"><span class="nav-number">2.36.</span> <span class="nav-text">#36 @Lookup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-生命周期"><span class="nav-number">2.37.</span> <span class="nav-text">#37 生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-ServletContextListener"><span class="nav-number">2.38.</span> <span class="nav-text">#38 ServletContextListener</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-Configuration"><span class="nav-number">2.39.</span> <span class="nav-text">#39 @Configuration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-什么是语法？"><span class="nav-number">2.40.</span> <span class="nav-text">#40 什么是语法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41-GC日志释意"><span class="nav-number">2.41.</span> <span class="nav-text">#41 GC日志释意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42"><span class="nav-number">2.42.</span> <span class="nav-text">#42</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43"><span class="nav-number">2.43.</span> <span class="nav-text">#43</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-JVM内存划分"><span class="nav-number">2.44.</span> <span class="nav-text">#44 JVM内存划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45-栈上分配"><span class="nav-number">2.45.</span> <span class="nav-text">#45 栈上分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-HashMap"><span class="nav-number">2.46.</span> <span class="nav-text">#46 HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-HashMap-是扩容成2倍"><span class="nav-number">2.47.</span> <span class="nav-text">#47 HashMap 是扩容成2倍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48-自学英语"><span class="nav-number">2.48.</span> <span class="nav-text">#48 自学英语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49-ConcurrentHashMap"><span class="nav-number">2.49.</span> <span class="nav-text">#49 ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#50-CAS"><span class="nav-number">2.50.</span> <span class="nav-text">#50 CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51-hash索引"><span class="nav-number">2.51.</span> <span class="nav-text">#51 hash索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52-覆盖索引"><span class="nav-number">2.52.</span> <span class="nav-text">#52 覆盖索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-mysql复合索引"><span class="nav-number">2.53.</span> <span class="nav-text">#53 mysql复合索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54-UUID"><span class="nav-number">2.54.</span> <span class="nav-text">#54 UUID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-redolog、undolog"><span class="nav-number">2.55.</span> <span class="nav-text">#55 redolog、undolog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56-通过间隙锁解决幻读"><span class="nav-number">2.56.</span> <span class="nav-text">#56 通过间隙锁解决幻读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#57-ObjectId"><span class="nav-number">2.57.</span> <span class="nav-text">#57 ObjectId</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#58-Redis删除策略"><span class="nav-number">2.58.</span> <span class="nav-text">#58 Redis删除策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#59-Redis高性能"><span class="nav-number">2.59.</span> <span class="nav-text">#59 Redis高性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#60-io多路复用"><span class="nav-number">2.60.</span> <span class="nav-text">#60 io多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#61-Redis哨兵"><span class="nav-number">2.61.</span> <span class="nav-text">#61 Redis哨兵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-setNX"><span class="nav-number">2.62.</span> <span class="nav-text">#62 setNX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-synchronized-锁升级"><span class="nav-number">2.63.</span> <span class="nav-text">#63 synchronized 锁升级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-Kafka"><span class="nav-number">2.64.</span> <span class="nav-text">#64 Kafka</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#65-Xmn"><span class="nav-number">2.65.</span> <span class="nav-text">#65 Xmn</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#66-模拟内存分配"><span class="nav-number">2.66.</span> <span class="nav-text">#66 模拟内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#67-CardTable"><span class="nav-number">2.67.</span> <span class="nav-text">#67 CardTable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#68-水平分表"><span class="nav-number">2.68.</span> <span class="nav-text">#68 水平分表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#69-spring-Bean-生命周期"><span class="nav-number">2.69.</span> <span class="nav-text">#69 spring Bean 生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#70-zset"><span class="nav-number">2.70.</span> <span class="nav-text">#70 zset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#71-mvcc"><span class="nav-number">2.71.</span> <span class="nav-text">#71 mvcc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72-MySQL事务隔离级别"><span class="nav-number">2.72.</span> <span class="nav-text">#72 MySQL事务隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#73"><span class="nav-number">2.73.</span> <span class="nav-text">#73</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#74-mvcc原理"><span class="nav-number">2.74.</span> <span class="nav-text">#74 mvcc原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#75-CountDownLatch"><span class="nav-number">2.75.</span> <span class="nav-text">#75 CountDownLatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#76-TCP三次握手"><span class="nav-number">2.76.</span> <span class="nav-text">#76 TCP三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#77-TCP四次挥手"><span class="nav-number">2.77.</span> <span class="nav-text">#77 TCP四次挥手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#78-滑动窗口"><span class="nav-number">2.78.</span> <span class="nav-text">#78 滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#79-netty线程模型"><span class="nav-number">2.79.</span> <span class="nav-text">#79 netty线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#80-Reactor-模型"><span class="nav-number">2.80.</span> <span class="nav-text">#80 Reactor 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#81-netty-handler无锁设计"><span class="nav-number">2.81.</span> <span class="nav-text">#81 netty handler无锁设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#82-粘包拆包"><span class="nav-number">2.82.</span> <span class="nav-text">#82 粘包拆包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#83-Linux-io模型"><span class="nav-number">2.83.</span> <span class="nav-text">#83 Linux io模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#84-netty零拷贝"><span class="nav-number">2.84.</span> <span class="nav-text">#84 netty零拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#85-一致性Hash"><span class="nav-number">2.85.</span> <span class="nav-text">#85 一致性Hash</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2011 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">since1986</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">432k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">6:32</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.2</div>




        








        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>



  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  
  <script src="/js/js.cookie.js?v=7.1.2"></script>
  <script src="/js/scroll-cookie.js?v=7.1.2"></script>


  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
