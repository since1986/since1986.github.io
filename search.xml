<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[实现一个红黑树]]></title>
    <url>%2F25c279dc.html</url>
    <content type="text"><![CDATA[前言感受一下红黑树的死亡旋转。 正文红黑树的特性： 根节点为黑色 叶子节点(也就是 null)为黑色 如果某个节点为红色，那么他的两个子节点必须都是黑色的 从某个结点出发，经历任何一种路径，其中经历的黑色节点数量是相同的 这几个特性保证了红黑树不会像普通的二叉查找树那样产生退化成链表的情况。另外，后两个特性保证了从红黑树的任意节点到其每个叶子节点的路径最长不会超过最短路径的 2 倍。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323package io.since1986.demo;import static io.since1986.demo.BlackRedTree.Node.Color.BLACK;import static io.since1986.demo.BlackRedTree.Node.Color.RED;/** * 首先红黑树要满足二叉查找树的性质，也就是某个节点的左子节点的值比其值小，右子节点的值比其值大 * &lt;p&gt; * 然后红黑树有四条特殊性质需要满足： * 1. 根节点为黑色 * 2. 叶子节点为黑色 * 3. 如果某个节点为红色，那么他的两个子节点必须都是黑色的 * 4. 从某个结点出发，经历任何一种路径，其中经历的黑色节点数量是相同的 */public class BlackRedTree &#123; public static void main(String[] args) &#123; BlackRedTree blackRedTree = new BlackRedTree(); blackRedTree.add(1); blackRedTree.add(3); blackRedTree.add(2); blackRedTree.add(4); blackRedTree.add(5); blackRedTree.add(6); &#125; private Node root; static class Node &#123; enum Color &#123; BLACK, RED &#125; Color color; int value; Node leftChild; Node rightChild; Node parent; Node(Color color, int value, Node leftChild, Node rightChild, Node parent) &#123; this.color = color; this.value = value; this.leftChild = leftChild; this.rightChild = rightChild; this.parent = parent; &#125; public void setColor(Color color) &#123; this.color = color; &#125; public void setValue(int value) &#123; this.value = value; &#125; public void setLeftChild(Node leftChild) &#123; this.leftChild = leftChild; &#125; public void setRightChild(Node rightChild) &#123; this.rightChild = rightChild; &#125; public void setParent(Node parent) &#123; this.parent = parent; &#125; @Override public String toString() &#123; return color.name() + String.format("(%s)", value); &#125; &#125; /** * 新插入节点均要是红色的，这样处理起来比较容易 */ public void add(int value) &#123; if (root == null) &#123; // 如果当前根节点不存在，那么新节点就是根节点，根节点恒定为黑色节点 root = new Node(BLACK, value, null, null, null); &#125; else &#123; // 如果当前根节点已经存在（注意此时树中不一定只有根节点，还可能有若干根节点的子节点） // 二分查找当前添加的值 value 在当前树中的位置，如果某个结点的值与value相等，那么这个value就不能再插入为新的节点了，如果没找到相等的，则最后找到的节点即为要插入节点的父节点 Node _current = root; Node parent; do &#123; parent = _current; if (value == _current.value) &#123; return; // 二叉查找树中不允许出现重复值 &#125; if (value &lt; _current.value) &#123; _current = _current.leftChild; &#125; else &#123; _current = _current.rightChild; &#125; &#125; while (_current != null); // currentNode 要是 null 的话就意味着当前已经到了叶子节点了（叶子节点就是空节点）就不需要再找下去了 // 将value和上一步找到的父节点的值相比较，如果大于则新插入节点为父节点的右子节点，反之为左子节点（二叉查找树的性质） Node newNode = new Node(RED, value, null, null, parent); // 新插入的节点一开始为红色 if (value &lt; parent.value) &#123; parent.leftChild = newNode; &#125; else &#123; parent.rightChild = newNode; &#125; // 然后需要根据四条特性进行修正 fix(newNode); &#125; &#125; /** * 二分查找（红黑树本身也是二叉查找树，因此当然可以二分查找） */ public Node binarySearch(int value) &#123; Node current = root; do &#123; if (value == current.value) &#123; return current; &#125; if (value &lt; current.value) &#123; current = current.leftChild; &#125; else &#123; current = current.rightChild; &#125; &#125; while (current != null); return null; &#125; private void fix(Node node) &#123; // 修正以满足四特性，注意当前插入的新节点 node 必是红色 node.color = RED; // 先分为两种情况 // 一. 当前节点的父节点为黑色时，无需修正 // 二. 当前节点的父节点为红色时，再分为两种情况： while (node != null &amp;&amp; node != root &amp;&amp; node.parent.color == RED) &#123; Node nodeParent = parentOf(node); Node grandpa = parentOf(nodeParent); // 1. 当前节点的父节点 parent 为当前节点爷爷节点 grandpa 的左子节点 if (nodeParent == leftChildOf(grandpa)) &#123; // 再分为两种情况： Node uncle = rightChildOf(grandpa); // 1.1 当前节点的叔叔节点 uncle 为红色 if (colorOf(uncle) == RED) &#123; // 将父节点设置为黑色 setColor(nodeParent, BLACK); // 将叔叔节点设置为黑色 setColor(uncle, BLACK); // 将爷爷节点设置为红色 setColor(grandpa, RED); // 将爷爷节点设置为当前节点(也就是带入下次循环) node = grandpa; &#125; // 1.2 当前节点的叔叔节点 uncle 为黑色 else &#123; // 如果当前节点是父节点的右子节点 if (node == rightChildOf(nodeParent)) &#123; // 将当前节点设置为父节点 node = nodeParent; // 左旋 rotateToLeft(node); &#125; // 设置当前节点的父节点为黑色(这里要重新获得一遍父节点，因为在前面有可能改变了当前节点) setColor(parentOf(node), BLACK); // 设置新的当前节点的爷爷节点为红色 setColor(parentOf(parentOf(node)), RED); // 将当前节点的爷爷节右旋 rotateToRight(parentOf(parentOf(node))); &#125; &#125; // 2. 当前节点的父节点 parent 为当前节点爷爷节点 grandpa 的右子节点 else &#123; Node uncle = leftChildOf(grandpa); // 2.1 当前节点的叔叔节点 uncle 为红色(和1.1其实是一样得流程) if (colorOf(uncle) == RED) &#123; // 将父节点设置为黑色 setColor(nodeParent, BLACK); // 将叔叔节点设置为黑色 setColor(uncle, BLACK); // 将爷爷节点设置为红色 setColor(grandpa, RED); // 将爷爷节点设置为当前节点(也就是带入下次循环) node = grandpa; &#125; // 2.2 当前节点的叔叔节点 uncle 为黑色(涉及旋转的操作和2.1流程中正好反向) // 如果当前节点是父节点的左节点 if (node == leftChildOf(nodeParent)) &#123; // 将当前节点设置为父节点 node = nodeParent; // 右旋 rotateToRight(node); &#125; // 设置当前节点的父节点为黑色(这里要重新获得一遍父节点，因为在前面有可能改变了当前节点) setColor(parentOf(node), BLACK); // 设置新的当前节点的爷爷节点为红色 setColor(parentOf(parentOf(node)), RED); // 将当前节点的爷爷节左旋 rotateToLeft(parentOf(parentOf(node))); &#125; &#125; // 最后无论如何要将根节点设置为黑色 setColor(root, BLACK); &#125; private void setColor(Node node, Node.Color color) &#123; if (node != null) &#123; node.color = color; &#125; &#125; private Node.Color colorOf(Node node) &#123; return node == null ? BLACK : node.color; &#125; private Node parentOf(Node node) &#123; return node == null ? null : node.parent; &#125; private Node leftChildOf(Node node) &#123; return node == null ? null : node.leftChild; &#125; private Node rightChildOf(Node node) &#123; return node == null ? null : node.rightChild; &#125; /** * 左旋 * * @param node 当前要操作的目标节点 */ private void rotateToLeft(Node node) &#123; if (node == null) &#123; return; &#125; // 对当前节点 node 进行左旋操作 Node rightChild = node.rightChild; // 当前节点的右子节点 Node leftChildOfRightChild = rightChild.leftChild; // 当前节点右子节点的左子节点 // 将当前节点的右子节点赋值为leftChildOfRightChild node.rightChild = leftChildOfRightChild; // 如果leftChildOfRightChild不为空，则将他的父节点赋值为当前节点 if (leftChildOfRightChild != null) &#123; leftChildOfRightChild.parent = node; &#125; // 将当前节点的右子节点的父节点赋值为当前节点的父节点 rightChild.parent = node.parent; // 如果当前节点的父节点为空则将根节点赋值为rightChild if (node.parent == null) &#123; root = rightChild; &#125; // 如果当前节点为其父节点的左节点则将当前节点父节点的左子节点赋值为rightChild else if (node == node.parent.leftChild) &#123; node.parent.leftChild = rightChild; &#125; // 否则将当前节点父节点的右子节点赋值为rightChild else &#123; node.parent.rightChild = rightChild; &#125; // 将rightChild的左子节点赋值为当前节点 rightChild.leftChild = node; // 将当前节点的父节点赋值为rightChild node.parent = rightChild; &#125; /** * 右旋 * * @param node 当前要操作的目标节点 */ private void rotateToRight(Node node) &#123; if (node == null) &#123; return; &#125; // 对当前节点 node 进行右旋操作 Node leftChild = node.leftChild; // 当前节点的左子节点 Node rightChildOfLeftChild = leftChild.rightChild; // 当前节点左子节点的右子节点 // 将当前节点的左子节点赋值为rightChildOfLeftChild node.leftChild = rightChildOfLeftChild; // 如果rightChildOfLeftChild不为空，则将他的父节点赋值为当前节点 if (rightChildOfLeftChild != null) &#123; rightChildOfLeftChild.parent = node; &#125; // 将当前节点的左子节点的父节点赋值为当前节点的父节点 leftChild.parent = node.parent; // 如果当前节点的父节点为空则将根节点赋值为leftChild if (node.parent == null) &#123; root = leftChild; &#125; // 如果当前节点为其父节点的右子节点则将当前节点父节点的右子节点赋值为leftChild else if (node == node.parent.rightChild) &#123; node.parent.rightChild = leftChild; &#125; // 否则将当前节点父节点的左子节点赋值为leftChild else &#123; node.parent.leftChild = leftChild; &#125; // 将leftChild的右子节点赋值为当前节点 leftChild.rightChild = node; // 将当前节点的父节点赋值为leftChild node.parent = leftChild; &#125;&#125; 上边代码会生成这样的树：]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从一个问题初步了解MyBatis的一部分插件执行机制]]></title>
    <url>%2F3f3ed56f.html</url>
    <content type="text"><![CDATA[前言今天一位朋友在后端圈群里提了一个关于MyBatis插件的问题，正好有时间，就看了一下。 正文问题大致是：我的工程里有两个MyBatis分页的插件，一个是PageHelper，另一个是自己写的一个分页插件，但是两个插件共存时，总是自己的插件不能执行到，是为什么？ PageHelper的插件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.github.pagehelper;import com.github.pagehelper.cache.Cache;import com.github.pagehelper.cache.CacheFactory;import com.github.pagehelper.util.ExecutorUtil;import com.github.pagehelper.util.MSUtils;import com.github.pagehelper.util.StringUtil;import org.apache.ibatis.cache.CacheKey;import org.apache.ibatis.executor.Executor;import org.apache.ibatis.mapping.BoundSql;import org.apache.ibatis.mapping.MappedStatement;import org.apache.ibatis.plugin.*;import org.apache.ibatis.session.ResultHandler;import org.apache.ibatis.session.RowBounds;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import java.util.Properties;/** * Mybatis - 通用分页拦截器 * &lt;p&gt; * GitHub: https://github.com/pagehelper/Mybatis-PageHelper * &lt;p&gt; * Gitee : https://gitee.com/free/Mybatis_PageHelper * * @author liuzh/abel533/isea533 * @version 5.0.0 */@SuppressWarnings(&#123;"rawtypes", "unchecked"&#125;)@Intercepts( &#123; @Signature(type = Executor.class, method = "query", args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;), @Signature(type = Executor.class, method = "query", args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;), &#125;)public class PageInterceptor implements Interceptor &#123; ... // 此处代码与本文无关省略 ... @Override public Object intercept(Invocation invocation) throws Throwable &#123; try &#123; Object[] args = invocation.getArgs(); MappedStatement ms = (MappedStatement) args[0]; Object parameter = args[1]; RowBounds rowBounds = (RowBounds) args[2]; ResultHandler resultHandler = (ResultHandler) args[3]; Executor executor = (Executor) invocation.getTarget(); CacheKey cacheKey; BoundSql boundSql; //由于逻辑关系，只会进入一次 if (args.length == 4) &#123; //4 个参数时 boundSql = ms.getBoundSql(parameter); cacheKey = executor.createCacheKey(ms, parameter, rowBounds, boundSql); &#125; else &#123; //6 个参数时 cacheKey = (CacheKey) args[4]; boundSql = (BoundSql) args[5]; &#125; checkDialectExists(); List resultList; //调用方法判断是否需要进行分页，如果不需要，直接返回结果 if (!dialect.skip(ms, parameter, rowBounds)) &#123; //判断是否需要进行 count 查询 if (dialect.beforeCount(ms, parameter, rowBounds)) &#123; //查询总数 Long count = count(executor, ms, parameter, rowBounds, resultHandler, boundSql); //处理查询总数，返回 true 时继续分页查询，false 时直接返回 if (!dialect.afterCount(count, parameter, rowBounds)) &#123; //当查询总数为 0 时，直接返回空的结果 return dialect.afterPage(new ArrayList(), parameter, rowBounds); &#125; &#125; resultList = ExecutorUtil.pageQuery(dialect, executor, ms, parameter, rowBounds, resultHandler, boundSql, cacheKey); &#125; else &#123; //rowBounds用参数值，不使用分页插件处理时，仍然支持默认的内存分页 resultList = executor.query(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql); &#125; return dialect.afterPage(resultList, parameter, rowBounds); &#125; finally &#123; if(dialect != null)&#123; dialect.afterAll(); &#125; &#125; &#125; @Override public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; ... // 此处代码与本文无关省略 ...&#125; 自己的插件: 1234567891011121314151617181920212223242526272829303132333435363738import org.apache.ibatis.executor.Executor;import org.apache.ibatis.mapping.MappedStatement;import org.apache.ibatis.plugin.*;import org.apache.ibatis.session.ResultHandler;import org.apache.ibatis.session.RowBounds;import org.springframework.stereotype.Component;import java.util.Properties;@Intercepts(&#123;@Signature(method = "query", type = Executor.class, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)@Componentpublic class MyPageInterceptor implements Interceptor &#123; ... // 此处代码与本文无关省略 ... /** * 拦截后要执行的方法 */ @Override public Object intercept(Invocation invocation) throws Throwable &#123; // 分页处理逻辑 return invocation.proceed(); &#125; /** * 拦截器对应的封装原始对象的方法 */ @Override public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; ... // 此处代码与本文无关省略 ...&#125; 关于这个问题我大致翻了一下MyBatis插件处的部分源码，最终大致明白了问题所在。 MyBatis插件Plugin的被应用的入口点在这个地方: 1org.apache.ibatis.plugin.InterceptorChain#pluginAll 可以看这个类完整的代码:(我加上了一点注释) 123456789101112131415161718192021222324252627282930package org.apache.ibatis.plugin;import java.util.ArrayList;import java.util.Collections;import java.util.List;/** * @author Clinton Begin */public class InterceptorChain &#123; // 这里面是所有的拦截器 private final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;Interceptor&gt;(); public Object pluginAll(Object target) &#123; for (Interceptor interceptor : interceptors) &#123; target = interceptor.plugin(target); &#125; return target; &#125; public void addInterceptor(Interceptor interceptor) &#123; interceptors.add(interceptor); &#125; public List&lt;Interceptor&gt; getInterceptors() &#123; return Collections.unmodifiableList(interceptors); &#125;&#125; 上边的应用MyBatis插件（也就是拦截器）的过程实际上是会产生嵌套代理（JDK动态代理）的123456// 以PageHelper为例，来看生成代理的部分逻辑：com.github.pagehelper.PageInterceptor#plugin@Overridepublic Object plugin(Object target) &#123; return Plugin.wrap(target, this);&#125; 123456789101112131415// 上边代码中的 Plugin.wrap(target, this);public static Object wrap(Object target, Interceptor interceptor) &#123; Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor); Class&lt;?&gt; type = target.getClass(); Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap); if (interfaces.length &gt; 0) &#123; // JDK动态代理的创建 return Proxy.newProxyInstance( type.getClassLoader(), interfaces, new Plugin(target, interceptor, signatureMap)); // 这里 Plugin 是 implements InvocationHandler 的 &#125; return target;&#125; 然后我们注意应用MyBatis插件逻辑中的这个循环 1234for (Interceptor interceptor : interceptors) &#123; target = interceptor.plugin(target);&#125;return target; 这个循环中 interceptor.plugin(target) 可能会返回 上边代码中生成代理逻辑处所生成的target的代理，而代理又被赋值到了 target 本身再进行循环进入生成代理逻辑，这样就成了代理的代理(有可能数层)这样就形成了嵌套代理。 在正常情况下，我们自己的插件在 private final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;Interceptor&gt;(); 这个 interceptors 中的位置考前，而到了下边的生成代理的流程都结束后，最终的target，我们的插件拦截器就成了里层的代理，而PageHelper的代理在外层 我们的拦截器排位靠前，PageHelper的拦截器排位靠后 我们的代理在内层，PageHelper的代理在外层 在执行代理时，外层代理先于内层代理执行（具体执行逻辑我没有跟，我是在拦截器的拦截方法上加了断点判断出来的） 在执行分页插件所生成的代理（外层代理）时，在其拦截器方法中没有调用让拦截器链继续执行下一链条的关键方法 return invocation.proceed(); 因此内层代理永远也没机会执行到，这也就是为什么没执行我们自己插件的原因。 关于代理执行的顺序我们可以做一个实验，在第1步中应用所有代理处，我们使用idea的调试视图运行时修改变量的能力，将private final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;Interceptor&gt;();拦截器列表反转一下，然后我们再观察，可以发现我们的插件先执行了，如果我们在插件的拦截方法中同样不写让拦截器链继续执行下一链条的关键方法 return invocation.proceed(); 那么PageHelper 的拦截器（此次为内层拦截器）就不会执行，而写了，则能执行。 手工调顺序 可以看到手工调序后我们的代理跑到了外层，而PageHelper的代理成了内层 PageHelper没有这一句代码，因此内层代理就都不执行了 到此问题基本解决，就着这个问题我大致了解了一部分MyBatis的内在逻辑，当然，代码看的比较仓促，很多细节尚不清晰，后续继续深入。 参考资料Mybatis插件原理]]></content>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis源码调试的几个入口点]]></title>
    <url>%2F221926f2.html</url>
    <content type="text"><![CDATA[前言记录几个入口点，备忘，方便以后调试用。 正文参数绑定流程的调用栈： 1234567891011121314151617181920212223242526272829303132333435363738394041424344getProperty:115, DynamicContext$ContextAccessor (org.apache.ibatis.scripting.xmltags)getProperty:2671, OgnlRuntime (org.apache.ibatis.ognl)getValueBody:114, ASTProperty (org.apache.ibatis.ognl)evaluateGetValueBody:212, SimpleNode (org.apache.ibatis.ognl)getValue:258, SimpleNode (org.apache.ibatis.ognl)getValueBody:50, ASTNotEq (org.apache.ibatis.ognl)evaluateGetValueBody:212, SimpleNode (org.apache.ibatis.ognl)getValue:258, SimpleNode (org.apache.ibatis.ognl)getValueBody:61, ASTAnd (org.apache.ibatis.ognl)evaluateGetValueBody:212, SimpleNode (org.apache.ibatis.ognl)getValue:258, SimpleNode (org.apache.ibatis.ognl)getValue:470, Ognl (org.apache.ibatis.ognl)getValue:434, Ognl (org.apache.ibatis.ognl)getValue:44, OgnlCache (org.apache.ibatis.scripting.xmltags)evaluateBoolean:32, ExpressionEvaluator (org.apache.ibatis.scripting.xmltags)apply:34, IfSqlNode (org.apache.ibatis.scripting.xmltags)apply:33, MixedSqlNode (org.apache.ibatis.scripting.xmltags)apply:55, TrimSqlNode (org.apache.ibatis.scripting.xmltags)apply:33, MixedSqlNode (org.apache.ibatis.scripting.xmltags)getBoundSql:41, DynamicSqlSource (org.apache.ibatis.scripting.xmltags)getBoundSql:292, MappedStatement (org.apache.ibatis.mapping)query:81, CachingExecutor (org.apache.ibatis.executor)invoke:-1, GeneratedMethodAccessor191 (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:498, Method (java.lang.reflect)invoke:63, Plugin (org.apache.ibatis.plugin)query:-1, $Proxy398 (com.sun.proxy)selectList:148, DefaultSqlSession (org.apache.ibatis.session.defaults)selectList:141, DefaultSqlSession (org.apache.ibatis.session.defaults)invoke:-1, GeneratedMethodAccessor199 (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:498, Method (java.lang.reflect)invoke:433, SqlSessionTemplate$SqlSessionInterceptor (org.mybatis.spring)selectList:-1, $Proxy121 (com.sun.proxy)selectList:230, SqlSessionTemplate (org.mybatis.spring)executeForMany:137, MapperMethod (org.apache.ibatis.binding)execute:75, MapperMethod (org.apache.ibatis.binding)invoke:59, MapperProxy (org.apache.ibatis.binding)// 这里进入MyBatis内部流程find:-1, $Proxy355 (com.sun.proxy)statics1:73, MyBusinessServiceImpl (com.xx.xx.service)invoke:-1, MyBusinessServiceImpl$$FastClassBySpringCGLIB$$7c756e36 (com.xx.xx.service)// 业务Service的代理 // 实际的数据库执行: org.apache.ibatis.executor.BaseExecutor#queryFromDatabase // 查看实际生成的SQL，也就是执行完了 &lt;if test=&quot;xxx&quot;&gt; 这样的过滤后最终的 SQL: org.apache.ibatis.scripting.xmltags.DynamicSqlSource#getBoundSql]]></content>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个小顶堆]]></title>
    <url>%2Fa2be36f4.html</url>
    <content type="text"><![CDATA[前言其实逻辑流程想通了，实现起来就没那么难了。 正文在写数据结构题时，我们先要搞明白数据结构的定义，以及要写的数据结构有哪些特性，有什么样的行为，有了这些特性、行为的理解，我们才可能写出代码，空中楼阁是造不出来的 可以把数据结构的特性1，2，3，4的列出来再写，另外一开始可以先把次要的元素用简单的东西实现出来（比如我这个小顶堆一开始并没有“节点Node的概念”只是先用一个整形代替了，一开始先关注实现堆的行为，节点是不是对象并不影响堆的行为，可先忽略），实现完主流程然后再回过头来改成更复杂的实现，这样循序渐进，早期把关注点集中在主流程上更容易成功。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213package io.since1986.demo;import java.util.Arrays;import java.util.StringJoiner;public class HeapTest &#123; public static void main(String[] args) &#123; /* 堆的性质 1. 父节点比左子节点和右子节点都大或比左子节点和右子节点都小 2. 节点和兄弟节点之间的大小无所谓(也就是左右子节点之间大小与位置无关) 3. 每个节点都有编号，根节点编号为1，自根节点向下，从左至右依次顺序编号(也就是编号+1) 4. 每个节点的编号有这样的规律：某个节点N的有左子节点L和右子节点R，L.number = N.number * 2, R.number = N.number * 2 + 1, L.number = R.number + 1 基于堆的上述性质，可以将堆在物理上使用数组存储(编号即是数组索引) */ SmallTopHeap smallTopHeap = new SmallTopHeap(); smallTopHeap.add(10); smallTopHeap.add(7); smallTopHeap.add(8); smallTopHeap.add(5); smallTopHeap.add(9); smallTopHeap.add(6); smallTopHeap.add(4); smallTopHeap.add(3); smallTopHeap.add(1); smallTopHeap.add(2); System.out.println(smallTopHeap); System.out.println(smallTopHeap.delete()); System.out.println(smallTopHeap.delete()); System.out.println(smallTopHeap.delete()); System.out.println(smallTopHeap.delete()); System.out.println(smallTopHeap.delete()); System.out.println(smallTopHeap.delete()); System.out.println(smallTopHeap.delete()); System.out.println(smallTopHeap.delete()); System.out.println(smallTopHeap.delete()); System.out.println(smallTopHeap.delete()); &#125; // 小顶堆 static class SmallTopHeap &#123; // 根节点索引恒定为1 private static final int ROOT_NODE_INDEX = 1; // 真正的堆的承载数组是需要扩容的，但是我这个只是演示用的堆，写的简单一点，不支持承载数组扩容 private Node[] nodes = new Node[11]; private int largestNodeIndex = ROOT_NODE_INDEX; SmallTopHeap() &#123; // 注意数组的索引是从0开始的，但是我为了方便起见，承载数组索引0位置空着不用了，因为概念上堆的索引从要从1开始 nodes[0] = new Node(null); &#125; void add(Integer nodeValue) &#123; if (largestNodeIndex &gt; 10) &#123; throw new UnsupportedOperationException("这个只是演示用的堆，不支持承载数组扩容"); &#125; Node currentNode = new Node(nodeValue); // 插入时总是将要插入的节点放在整个堆的最后 int currentIndex = largestNodeIndex; nodes[currentIndex] = currentNode; // 插入节点以后需要更新最大节点的索引+1(加了一个元素因此最大的索引要 + 1) if (largestNodeIndex &lt; 10) &#123; largestNodeIndex++; &#125; // 如果当前承载数组中还没有存储根节点，那么当前插入的节点就是根节点，插入完成直接返回 if (currentIndex == 1) &#123; return; &#125; // 如果当前承载数组中已经存储了根节点，那么插入完成后就需要进行校验，检查当前堆是否还符合堆的特性 // 也就是从新插入节点的父节点开始一直循环比较大小是关系否合规，直到合规或者已经到根节点为止(根节点是编号最小的节点) // 找到刚刚插入的节点的父节点 parentElementIndex = currentIndex / 2 这里不用考虑当前是右节点还是左节点，不管是哪个节点，得到父节点编号都是简单的除以2即可，我们可以想一下： // 假如左子节点索引为 6 那么他的兄弟节点(也就是右节点)索引就是 6 + 1 = 7 父节点索引为 6 / 2 = 3 ，用右节点 7 来推算父节点索引： 7 / 2 = 3，这里 7 除以 2 等于 3 是因为整形除法会丢弃小数点，索引必然都是整形，因此不管是用左子节点还是右子节点来计算父节点的索引，公式都是除以2就可以了 while (true) &#123; int parentNodeIndex = currentIndex / 2; Node parentNode = nodes[parentNodeIndex]; // 我们这里是小顶堆(也就是父节点的值小于子节点的值) if (parentNode.value.compareTo(currentNode.value) &lt; 0) &#123; // 如果父节点的值小于当前节点的值，是符合小顶堆的特性的，那么循环就可以结束了 break; &#125; // 要是父节点的值大于当前节点的值，那么就交换父节点与当前节点 nodes[parentNodeIndex] = currentNode; nodes[currentIndex] = parentNode; // 将当前索引设置为父节点索引，并且将当前节点设置为父节点这样就可以进行下次循环了 currentIndex = parentNodeIndex; currentNode = nodes[currentIndex]; // 循环到了根节点(也就是索引为1的节点)就退出 if (currentIndex == ROOT_NODE_INDEX) &#123; break; &#125; &#125; &#125; Integer delete() &#123; if (largestNodeIndex &lt; 1) &#123; return -1; &#125; // 如果只剩一个了，直接置空并返回 if (largestNodeIndex == 1) &#123; Node firstNode = nodes[1]; nodes[1] = null; return firstNode.value; &#125; // 堆删除节点一般是删除承载数组第一个元素，然后将承载数组最后一个元素填到第一个元素的位置上，然后将最后一个元素置为null，将最后一个元素放到第一个后会破坏原来堆的性质，需要重新调整让整个承载数组重新符合堆的性质 Node nodeThatBeenDeleted = nodes[1]; Integer result = nodeThatBeenDeleted.value; Node largestIndexNode = nodes[largestNodeIndex]; nodes[1] = largestIndexNode; nodes[largestNodeIndex] = null; largestNodeIndex--; // 重新调整结构，让承载数组重新符合堆的特性 // 找到左子节点和右子节点，比较一下它们的值大小，将当前节点的值大小与他们两个之中小的那个进行比较，如果值大于就置换(置换后能保证上边的比下边的小，举个例子 假设当前节点值为 10 它的左子节点值为 5，右子节点值为 6，置换后5变为当前节点，比10和6都小，这样是符合小顶堆的性质的)，如果小于就返回 int currentIndex = 1; Node currentNode = nodes[1]; while (true) &#123; int leftChildNodeIndex = currentIndex * 2; int rightChildNodeIndex = currentIndex * 2 + 1; // 特殊流程1：如果左子节点的索引已经大于最大索引了，那直接跳出循环 if (leftChildNodeIndex &gt; largestNodeIndex) &#123; break; &#125; // 特殊流程2：如果左子节点已经是最后一个了，那么直接比较交换并结束循环 if (leftChildNodeIndex == largestNodeIndex) &#123; Node leftChildNode = nodes[leftChildNodeIndex]; if (leftChildNode.value.compareTo(currentNode.value) &gt; 0) &#123; break; &#125; nodes[currentIndex] = leftChildNode; nodes[leftChildNodeIndex] = currentNode; break; &#125; else &#123; // 普通流程：左子节点没有到最大索引(此时右子节点有可能是最大索引也有可能不是，倒无所谓，不影响流程，走普通流程就好) Node leftChildNode = nodes[leftChildNodeIndex]; Node rightChildNode = nodes[rightChildNodeIndex]; // 找到左子节点右子节点中小的那个 Node smallerChild = leftChildNode.value.compareTo(rightChildNode.value) &lt; 0 ? leftChildNode : rightChildNode; int smallerChildIndex = leftChildNode.value.compareTo(rightChildNode.value) &lt; 0 ? leftChildNodeIndex : rightChildNodeIndex; // 并于当前节点比较，如果小于就返回(父节点比两个子节点小是符合小顶堆性质的，就不用再置换处理了) if (smallerChild.value.compareTo(currentNode.value) &gt; 0) &#123; break; &#125; // 当前节点的值大小与他们两个之中小的那个进行比较，如果值大于就置换处理 nodes[currentIndex] = smallerChild; nodes[smallerChildIndex] = currentNode; // 并将当前索引置为较小子节点的索引，将当前节点置为较小节点，以便进行下一轮循环 currentIndex = smallerChildIndex; currentNode = nodes[currentIndex]; // 如果已经到了最大索引，就退出循环 if (currentIndex == largestNodeIndex) &#123; break; &#125; &#125; &#125; return result; &#125; @Override public String toString() &#123; return new StringJoiner(",", "&#123;", "&#125;") .add("\"nodes\":" + Arrays.toString(nodes)) .add("\"largestNodeIndex\":" + largestNodeIndex) .toString(); &#125; static class Node &#123; private Integer value; Node(Integer value) &#123; this.value = value; &#125; @Override public String toString() &#123; return new StringJoiner(":", "&#123;", "&#125;") .add("\"value\"") .add(String.valueOf(value)) .toString(); &#125; &#125; &#125;&#125; 输出： 1234567891011&#123;&quot;nodes&quot;:[&#123;&quot;value&quot;:null&#125;, &#123;&quot;value&quot;:1&#125;, &#123;&quot;value&quot;:2&#125;, &#123;&quot;value&quot;:5&#125;, &#123;&quot;value&quot;:4&#125;, &#123;&quot;value&quot;:3&#125;, &#123;&quot;value&quot;:8&#125;, &#123;&quot;value&quot;:6&#125;, &#123;&quot;value&quot;:10&#125;, &#123;&quot;value&quot;:7&#125;, &#123;&quot;value&quot;:9&#125;],&quot;largestNodeIndex&quot;:10&#125;12345678910]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2Fff8068c0.html</url>
    <content type="text"><![CDATA[前言以前一直没搞明白快速排序，这两天抽时间捋了一下，搞明白了其逻辑流程，实现起来就顺利了。 正文123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package io.since1986.demo;import java.util.Arrays;public class QuickSortTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;3, 6, 4, 8, 9, 2, 1, 5, 7, 1, 2, 3&#125;; // 最初始的参考值Index 和 lowIndex、highIndex int initiallyLowIndex = 0; int initiallyHighIndex = array.length - 1; int initiallyPivotIndex = initiallyLowIndex; // 这里完全可以加上优化参考值选取的操作，本例中为了简单，未作优化 quickSort(initiallyLowIndex, initiallyHighIndex, initiallyPivotIndex, array); System.out.println(Arrays.asList(array)); &#125; private static void quickSort(int lowIndex, int highIndex, int pivotIndex, Integer[] array) &#123; // 先选取参考值，最简单的选法是选择首个元素为参考值（当然最简单的不一定最好，最好是随机选取一个元素作为参考值，然后将其与第一个元素对调） // 然后从数组两端开始（分别为 lowIndex 和 highIndex）推进，推进是交替进行的（也就是相向搜索），首先开动的是选取的参考值对向的值，比如说选择数组开头作为参考值，那么推进就让从尾到头的那个开始，这个交替的次序很重要 // 本例我们参考值选的数组开头，根据上面的规则，我们先从high开始向前找比参考值小或等于的元素，找到了就停下来，等待对侧推进 // 对侧推进是从low开始向后找比参考值大的元素 // 如果对侧找到了，那么将找到的两个Index对应的元素进行交换 // 当上述过程遇到条件lowIndex &gt;= highIndex时，结束查找(之所以是大于等于是因为先从high端找有可能找的过了汇合点) // 查找结束后将参考值与当前定位到的Index对应的元素进行交换，也即是参考值就位（也就是和汇合点进行交换，注意这个汇合点不一定是low和high的中心点，因为上边一条条件在于同时找到，因此有可能从low出发找的步数多，从high出发找的步数少） // 以上的过程称为 分区(或者说是“分区”的一种实现) // 一轮分区后参考值所处的位置左边都比其小，右边都比其大 // 但是左边的分区内部仍然无序，右边的分区内部仍然无序，只是整个数组相对于参考值来说有了大致的顺序 // // 这时，对左右两个分区再分别进行一轮排序，也就是对于左分区 lowIndex = 当前分区的lowIndex, highIndex = 当前参考值所在索引 - 1 // 对于右分区 lowIndex = 参考值所在索引 + 1, highIndex = 当前分区的highIndex // 用上边的两个分区的low、high值重新进行一轮排序操作，这样就会在左右分区里重复 分区 + 参考值归位的操作 // 上面的分区内排序递归进行，直到给定的lowIndex &gt;= highIndex这个退出条件被触发则结束 // 过程展开示例: // 第一轮 分区 + 参考值归位 // 3, 6, 4, 8, 9, 2, 1, 5, 7 // 3, 1, 4, 8, 9, 2, 6, 5, 7 // 3, 1, 2, 8, 9, 4, 6, 5, 7 // 2, 1, 3, 8, 9, 4, 6, 5, 7 注意此时参考值 3 已归位，可以观察到，3的左边都比3小，右边都比3大，但是3左右两边的分区（lowPartition 和 highPartition）本身分区内还是无序的，因此需要继续应用排序（也就是递归排序） // // lowPartition 的排序 // 2, 1 // 1, 2 // highPartition 的排序 // 8, 9, 4, 6, 5, 7 // 8, 7, 4, 6, 5, 9 // 5, 7, 4, 6, 8, 9 // ... 重复（递归）以上过程 if (lowIndex &gt;= highIndex) &#123; // 退出条件 return; &#125; int currentPivotIndex = partition(lowIndex, highIndex, pivotIndex, array); int nextLowIndexOfLowPartition = lowIndex; int nextHighIndexOfLowPartition = currentPivotIndex - 1; int nextPivotIndexOfLowPartition = nextLowIndexOfLowPartition; // 这里完全可以加上优化参考值选取的操作，本例中为了简单，未作优化 int nextLowIndexOfHighPartition = currentPivotIndex + 1; int nextHighIndexOfHighPartition = highIndex; int nextPivotIndexOfHighPartition = nextLowIndexOfHighPartition; quickSort(nextLowIndexOfLowPartition, nextHighIndexOfLowPartition, nextPivotIndexOfLowPartition, array); quickSort(nextLowIndexOfHighPartition, nextHighIndexOfHighPartition, nextPivotIndexOfHighPartition, array); &#125; // 分区 （以相向搜索并让参考值归位的方式实现） private static int partition(int lowIndex, int highIndex, int pivotIndex, Integer[] array) &#123; int pivot = array[pivotIndex]; // 1. 分区操作 // 参考值对向先开始找，直到找到比参考值小或等于的结束 oppositeSearchLoopLabel: while (true) &#123; int high = array[highIndex]; if (high &lt;= pivot) &#123; // 找到了比参考值小或等于的，此时轮到从左往右找开始，从左往右找比参考值大的 while (true) &#123; // 退出条件 if (lowIndex &gt;= highIndex) &#123; break oppositeSearchLoopLabel; // 直接退出查找循环（两层while循环） &#125; int low = array[lowIndex]; // 找到了比参考值大的就交换 if (low &gt; pivot) &#123; array[lowIndex] = high; array[highIndex] = low; lowIndex++; break; &#125; lowIndex++; &#125; &#125; highIndex--; &#125; // 2. 参考值归位操作 // 两向的查找结束后，要将基准元素与两向查找相遇时的索引（highIndex）的元素进行对调，也就是参考值就位操作 int high = array[highIndex]; array[highIndex] = pivot; array[pivotIndex] = high; int currentPivotIndex = highIndex; return currentPivotIndex; &#125;&#125; 一个更完善的版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177package io.since1986.demo;import java.util.Arrays;import java.util.Random;public class QuickSortDemo &#123; public static void main(String[] args) &#123; // 简单的快速排序 Integer[] array1 = new Integer[]&#123;3, 6, 4, 8, 9, 2, 1, 5, 7, 1, 2, 3&#125;; QuickSorter simpleQuickSorter = new SimpleQuickSorter(); simpleQuickSorter.sort(array1); System.out.println(Arrays.asList(array1)); // 随机选取Pivot的快速排序 Integer[] array2 = new Integer[]&#123;3, 6, 4, 8, 9, 2, 1, 5, 7, 1, 2, 3&#125;; QuickSorter randomPivotQuickSorter = new RandomPivotQuickSorter(); randomPivotQuickSorter.sort(array2); System.out.println(Arrays.asList(array2)); &#125; interface QuickSorter &#123; void sort(Integer[] array); &#125; static abstract class AbstractQuickSorter implements QuickSorter &#123; @Override public void sort(Integer[] array) &#123; int initiallyLowIndex = 0; int initiallyHighIndex = array.length - 1; int initiallyPivotIndex = initiallyLowIndex; // 这里为了容易明白语义，故意冗余了声明 optimizePivot(initiallyPivotIndex, initiallyLowIndex, initiallyHighIndex, array); doSort(initiallyLowIndex, initiallyHighIndex, initiallyPivotIndex, array); &#125; private void doSort(int lowIndex, int highIndex, int pivotIndex, Integer[] array) &#123; if (lowIndex &gt;= highIndex) &#123; // 退出条件 return; &#125; int currentPivotIndex = partition(lowIndex, highIndex, pivotIndex, array); int nextLowIndexOfLowPartition = lowIndex; // 这里为了容易明白语义，故意冗余了声明 int nextHighIndexOfLowPartition = currentPivotIndex - 1; int nextPivotIndexOfLowPartition = nextLowIndexOfLowPartition; // 这里为了容易明白语义，故意冗余了声明 optimizePivot(nextPivotIndexOfLowPartition, nextLowIndexOfLowPartition, nextHighIndexOfLowPartition, array); int nextLowIndexOfHighPartition = currentPivotIndex + 1; int nextHighIndexOfHighPartition = highIndex; // 这里为了容易明白语义，故意冗余了声明 int nextPivotIndexOfHighPartition = nextLowIndexOfHighPartition; // 这里为了容易明白语义，故意冗余了声明 optimizePivot(nextPivotIndexOfHighPartition, nextLowIndexOfHighPartition, nextHighIndexOfHighPartition, array); doSort(nextLowIndexOfLowPartition, nextHighIndexOfLowPartition, nextPivotIndexOfLowPartition, array); doSort(nextLowIndexOfHighPartition, nextHighIndexOfHighPartition, nextPivotIndexOfHighPartition, array); &#125; abstract void optimizePivot(int rawPivotIndex, int lowIndex, int highIndex, Integer[] array); abstract int partition(int lowIndex, int highIndex, int pivotIndex, Integer[] array); &#125; static class SimpleQuickSorter extends AbstractQuickSorter &#123; private final PartitionMethodProvider partitionMethodProvider; SimpleQuickSorter() &#123; partitionMethodProvider = new OppositeSearchLoopThenMakePivotInPositionPartitionMethodProvider(); &#125; // 优化参考值选取的操作，简单实现直接忽略优化 @Override void optimizePivot(int rawPivotIndex, int lowIndex, int highIndex, Integer[] array) &#123; // DO NOTHING &#125; @Override int partition(int lowIndex, int highIndex, int pivotIndex, Integer[] array) &#123; return partitionMethodProvider.doPartition(lowIndex, highIndex, pivotIndex, array); &#125; /** * 分区方法提供者 */ interface PartitionMethodProvider &#123; int doPartition(int lowIndex, int highIndex, int pivotIndex, Integer[] array); &#125; // 分区方法提供者的一种实现：相向搜索并让参考值归位 static class OppositeSearchLoopThenMakePivotInPositionPartitionMethodProvider implements PartitionMethodProvider &#123; @Override public int doPartition(int lowIndex, int highIndex, int pivotIndex, Integer[] array) &#123; int pivot = array[pivotIndex]; // 1. 分区操作 // 参考值对向先开始找，直到找到比参考值小或等于的结束 oppositeSearchLoopLabel: while (true) &#123; int high = array[highIndex]; if (high &lt;= pivot) &#123; // 找到了比参考值小或等于的，此时轮到从左往右找开始，从左往右找比参考值大的 while (true) &#123; // 退出条件 if (lowIndex &gt;= highIndex) &#123; break oppositeSearchLoopLabel; // 直接退出查找循环（两层while循环） &#125; int low = array[lowIndex]; // 找到了比参考值大的就交换 if (low &gt; pivot) &#123; Helper.swap(lowIndex, highIndex, array); lowIndex++; break; &#125; lowIndex++; &#125; &#125; highIndex--; &#125; // 2. 参考值归位操作 // 两向的查找结束后，要将基准元素与两向查找相遇时的索引（highIndex）的元素进行对调，也就是参考值就位操作 Helper.swap(highIndex, pivotIndex, array); int currentPivotIndex = highIndex; // 这里为了容易明白语义，故意冗余了声明 return currentPivotIndex; &#125; &#125; &#125; static class RandomPivotQuickSorter extends SimpleQuickSorter &#123; // 优化Pivot的一种实现：随机选取[lowIndex,highIndex]中的一个Index，拿到其值，与原始Pivot进行值护换（这样分区流程不需要动，实际内部等于随机选取了Pivot，但是在分区流程来看，PivotIndex没变） @Override void optimizePivot(int rawPivotIndex, int lowIndex, int highIndex, Integer[] array) &#123; if (lowIndex &gt;= highIndex) &#123; return; &#125; int randomIndex = random(lowIndex, highIndex); Helper.swap(rawPivotIndex, randomIndex, array); &#125; private int random(int low, int high) &#123; Random random = new Random(); int nextInt; do &#123; nextInt = random.nextInt(high + 1); &#125; while (nextInt &lt; low); return nextInt; &#125; &#125; static final class Helper &#123; static void swap(int oneIndex, int antherIndex, Integer[] array) &#123; Integer one = array[oneIndex]; Integer anther = array[antherIndex]; array[oneIndex] = anther; array[antherIndex] = one; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[故宫命名法]]></title>
    <url>%2Fed96544d.html</url>
    <content type="text"><![CDATA[前言不同事物间内在逻辑有很多相通之处。 正文如果你用 iPhone 的话，有可能会知道，有一款很精美的APP：“每日故宫”，我很喜欢这款APP，里面有很多精美的故宫文物的图片，以及关于文物背景知识的介绍。如果你仔细观察过的话，也许你会从APP中对于文物的介绍中注意到，故宫文物的命名是有规律的。比如这两个例子： 绿地粉彩蕉叶花卉纹瓶 青花红绿彩凤鹤灵芝纹提梁壶 不难看出来，这里面的规律是：直白、完备，也就是说，命名能够通过简单易懂的字词提取出大部分目标对象的关键特性，通过名字的辅导再对照图片，观察者能够轻松的将目标对象中的关键属性找出来，并在头脑中快速构建出来具象化的印象。这样对于传播文化知识是十分高效的。 同样的道理，在我们的工作中，对于一个变量或者方法或者类的命名，也需要做到直白、完备，能够通过变量命名，将当前这个变量、方法或者类的语义大致的传递给使用者(关于这一点的例子，请回想Jdk库中的命名方式，以及Spring中的命名方式)，使用者能够基于命名提供的语义，大致知道当前这个当前这个变量、方法或者类应当怎么用，同时，如果使用者需要了解实现细节，命名也应该能够提供给使用者对于实现细节理解的方向性指导，这样对于使用者来说，是高效的。]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串字面量长度是有限制的]]></title>
    <url>%2Fd91c2205.html</url>
    <content type="text"><![CDATA[前言偶然在一次单元测试中写了一个非常长的字符串字面量。 正文在一次单元测试中，我写了一个很长的字符串字面量，大概10万个字符左右，编译时，编译器给出了异常告警 java: constant string too long，当时我就惊呆了，惊讶于平常写的字符串字面量竟然还有长度限制？？？（黑人问号）。然后我来了兴致，我倒要看看字符串字面量到底能写到多少个字符不报错。于是我试了大概10分钟左右，发现 65534 这个值是上限，超过了就会报 java: constant string too long。 那么，这个限制在JDK中是在什么地方实现的呢，我Google了一下，发现了这几篇文章：Bug 212752 - Error when there is string bigged than 65534 bytes、Java字符串的最大长度、Java “constant string too long” compile error. Only happens using Ant, not when using Eclipse 我们先来看第一篇文章，在这篇文章中（实际上是个NetBeans的issues主题）有个人提到： Tomas Zezula 2012-05-31 20:15:53 UTCThe compiler message is:“constant string too long” See checkStringConstant(…) method in http://hg.openjdk.java.net/jdk7/tl/langtools/file/a72412b148d7/src/share/classes/com/sun/tools/javac/jvm/Gen.java and MAX_STRING_LENGTH in http://hg.openjdk.java.net/jdk7/tl/langtools/file/a72412b148d7/src/share/classes/com/sun/tools/javac/jvm/Pool.java 也就是在Oracle JDK的编译工具 Javac 内部，代码层面对字符串字面量长度做了限制，我们可以看看他说的几段代码（都是Java代码，Javac 本身也是用Java语言写的，不是C++）： 12345678910111213141516// langtools-b9abf5c3d057\src\share\classes\com\sun\tools\javac\jvm\Gen.java// com.sun.tools.javac.jvm.Gen.../** Check a constant value and report if it is a string that is * too large. */private void checkStringConstant(DiagnosticPosition pos, Object constValue) &#123; if (nerrs != 0 || // only complain about a long string once constValue == null || !(constValue instanceof String) || ((String)constValue).length() &lt; Pool.MAX_STRING_LENGTH) return; log.error(pos, "limit.string"); nerrs++;&#125;... 123456789101112131415161718// langtools-b9abf5c3d057\src\share\classes\com\sun\tools\javac\jvm\Pool.java// com.sun.tools.javac.jvm.Pool/** An internal structure that corresponds to the constant pool of a classfile. * * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API. * If you write code that depends on this, you do so at your own risk. * This code and its internal interfaces are subject to change or * deletion without notice.&lt;/b&gt; */public class Pool &#123; ... public static final int MAX_STRING_LENGTH = 0xFFFF; ...&#125; 12345678// src/share/classes/com/sun/tools/javac/resources/compiler.properties...compiler.err.limit.string=\ constant string too long... 通过上边代码可以看到 MAX_STRING_LENGTH = 0xFFFF 而 0xFFFF 是十进制的 65535 (但是实际上只写了 65534 个就报错了，不知道为什么差一个？)，这里应当就是字符串字面量的限制的来源。这些代码整体怎么运作的，我并没有仔细看，不过按照提示信息能对的上来看，因该就是在这些逻辑里处理的字符串字面量长度的限制，也就是说字符串字面量长度是在编译器 Javac 代码逻辑层面加的限制。 再看第二篇文章 Java字符串的最大长度 文章的意思是，这个限制是在 class 文件格式层面限制的： String内部是以char数组的形式存储，数组的长度是int类型，那么String允许的最大长度就是Integer.MAX_VALUE了。又由于java中的字符是以16位存储的，因此大概需要4GB的内存才能存储最大长度的字符串。不过这仅仅是对字符串变量而言，如果是字符串字面量(string literals)，如“abc”、”1a2b”之类写在代码中的字符串literals，那么允许的最大长度取决于字符串在常量池中的存储大小，也就是字符串在class格式文件中的存储格式： 123456&gt; CONSTANT_Utf8_info &#123;&gt; u1 tag;&gt; u2 length;&gt; u1 bytes[length];&gt; &#125;&gt; u2是无符号的16位整数，因此理论上允许的string literal的最大长度是2^16-1=65535。然而实际测试表明，允许的最大长度仅为65534，超过就编译错误了，有兴趣可以写段代码试试，估计是length还不能为0。 再看第三篇文章Java “constant string too long” compile error. Only happens using Ant, not when using Eclipse：这个是篇爆栈网的主题，题主大致问的是用Ant编译超长字符串字面量会爆出和我遇到的同样的问题，而用eclipse编译则没问题，我自己试了试，用eclipse编译，确实没有了 65534 这个限制： 123456789public class Test &#123; public static void main(String[] args) &#123; String veryLargeLengthStringLiteral = "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ga2AgEBBAIMADAMAgIGpQIBAQQDAgEKMAwCAgarAgEBBAMCAQIwDAICBq4CAQEEAwIBADAMAgIGrwIBAQQDAgEAMAwCAgaxAgEBBAMCAQAwGwICBqcCAQEEEgwQMTAwMDAwMDQxNTA2OTQyNDAbAgIGqQIBAQQSDBAxMD11111111AwGwICBqcCAQEEEgwQMTAwMDAwMDQxNTA2OTQyNDAbAgIGqQIBAQQSDBAxMD11111111AwGwICBqcCAQEEEgwQMTAwMDAwMDQxNTA2OTQyNDAbAgIGqQIBAQQSDBAxMD11111111AwGwICBqcCAQEEEgwQMTAwMDAwMDQxNTA2OTQyNDAbAgIGqQIBAQQSDBAxMD11111111AwGwICBqcCAQEEEgwQMTAwMDAwMDQxNTA2OTQyNDAbAgIGqQIBAQQSDBAxMD11111111TQyNDAbAgIGqQIBAQQSDBAxMD11111111AwGwICBqcCAQEEEgwQMTAwMDAwMDQxNTA2OTQyNDAbAgIGqQIBAQQSDBAxMD11111111TQyNDAbAgIGqQIBAQQSDBAxMD11111111AwGwICBqcCAQEEEgwQMTAwMDAwMDQxNTA2OTQyNDAbAgIGqQIBAQQSDBAxMD11111111T111111111111111111111111111111111111111111111111111111111111EEEgwQMTAwMDAwMDQxNTA2OTQyNDAbAgIGqQIBAQ1"; System.out.println(veryLargeLengthStringLiteral.length()); &#125;&#125;// 在Eclipse中能正常编译并输出 65549 这个代码换到 idea 里编译会直接报错 那这个又是怎么回事呢？其实这个我倒是能知道个大概，因为我以前就知道，Eclipse编译Java代码并不用 Javac （可参考Which Java compiler is used by Eclipse? ）而是用的 JDT 也就是他们自己写的一个编译器，Eclipse能正常编译超过 65534 的字面量，那只能说明他们没在自己的编译器里做长度限制。 那么，第二篇文章的观点岂不是和第三篇有些相悖了？要是在 class 文件格式层面就做了限制，那么理论上Eclipse编译出来的应该完全跑不起来或者完全就不应该编译成功啊？这里我也不是很明白，留着以后知识盲区被修补了再继续了解吧，反正我现在更倾向于这个限制只是在编译器实现层面加的。 更新与勘误2019-08-15 更新后来我在知乎上关于这个主题进行了提问：Java中字符串字面量的65534限制和CONSTANT_Utf8_info的length有关系吗? 之所以JDT能编译过，只是因为JDT优化为了StringBuilder的append 之所以限制是 65534 而不是 65535 只是因为 Javac 源码中做的限制是((String)constValue).length() &lt; Pool.MAX_STRING_LENGTH) 注意是 &lt; 而不是 &lt;= ， 小于65535那自然最多只能是65534了(搞明白这个得感谢“杭州-半拍”的帮助)]]></content>
      <tags>
        <tag>JDK</tag>
        <tag>JVM</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三元表达式返回类型的确定]]></title>
    <url>%2F8ac5addf.html</url>
    <content type="text"><![CDATA[前言后端圈 群友提了一个关于三元表达式返回类型怎么确定的问题。 正文群友提问： 12345678910public static void main(String[] args) &#123; char c = &apos;c&apos;; int i = 129; boolean condition = true; System.out.println(condition ? c : 129); System.out.println(condition ? c : i);&#125;// 第一个结果是 char 型// 第二个结果是 int 型 我的回答： 三元表达式后边两个表达式哪个会返回在《Java语言规范》里有说明，我粗略的看了一下，像这种情况 true ? c : 0 根据规范的描述应该是返回 char 类型的。]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[null可被声明强转为某个类型]]></title>
    <url>%2F5b253c16.html</url>
    <content type="text"><![CDATA[前言一个以前没有注意到的点。 正文发现了一个有意思的点：null也可以被声明强制转换为某个类型的。 下面 Socket 类中有两个接受两个参数的构造器：一个是 (String, int) 一个是 (InetAddress, int) 要是第一个参数直传 null 编译不通过，因为触发了模棱两可匹配，但是如果把 null 强转为指定的类型就能编译过了 ((String) null, 1111) ，感觉很有意思。]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《tomcat内核设计剖析》学到的一个点]]></title>
    <url>%2F337ac5e1.html</url>
    <content type="text"><![CDATA[前言读《tomcat内核设计剖析》学到了一个小技巧，记录一下。 正文在 tomcat 里探查可能存在的自定义类加载器导致内存泄漏的办法：用弱引用配合System.gc()。 大致的原理是：如果一个对象只被弱引用引用，那么下次 gc 后会被回收；如果一个对象不只被弱引用引用还被强引用引用，那么下次 gc 后不能被回收。tomcat 利用了这一点，把所有自定义类加载器引用都放入WeakHashMap里，这样就都被弱引用引用了，然后需要探查泄漏时，手工触发一次gc也就是System.gc() 看一下这个WeakHashMap还剩谁，剩下的就是还在其他地方有强引用的，也就是有内存泄漏的。感觉这个方法很巧妙。]]></content>
      <tags>
        <tag>Java基础</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[踩了一个java命令行参数顺序的坑]]></title>
    <url>%2Fa6794556.html</url>
    <content type="text"><![CDATA[前言这几天线上实例会偶尔报警重启，查了一下问题，偶然发现了一个java命令参数顺序的坑。 正文我线上的启动命令行为： 1java -jar app.jar -DcustomArgs=someCustomArgs -Xmx2048M -Xms2048M -XX:MaxMetaspaceSize=256M -XX:MetaspaceSize=256M -XX:+UseG1GC -XX:MaxGCPauseMillis=100 -XX:+ParallelRefProcEnabled -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+HeapDumpOnOutOfMemoryError -XX:ErrorFile=/log/hs_err_pid%p.log -Xloggc:/log/gc.log -XX:HeapDumpPath=/log 这个命令看起来没什么问题，设置了JVM参数，GC日志打印等等，看起来一切OK。但是，实际上，当线上出现重启后，我去查看gc日志，却发现，压根没有gc日志的文件，我想了想，应当是我设置的参数没有生效，于是用jps -lvm查看，结果如下： 1448 app.jar -DcustomArgs=someCustomArgs -Xmx2048M -Xms2048M -XX:MaxMetaspaceSize=256M -XX:MetaspaceSize=256M -XX:+UseG1GC -XX:MaxGCPauseMillis=100 -XX:+ParallelRefProcEnabled -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+HeapDumpOnOutOfMemoryError -XX:ErrorFile=/log/hs_err_pid%p.log -Xloggc:/log/gc.log -XX:HeapDumpPath=/log 看起来没问题啊，于是我又看了看java命令的操作手册，发现了问题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354java -h用法: java [-options] class [args...] (执行类) 或 java [-options] -jar jarfile [args...] (执行 jar 文件)其中选项包括: -d32 使用 32 位数据模型 (如果可用) -d64 使用 64 位数据模型 (如果可用) -server 选择 "server" VM 默认 VM 是 server, 因为您是在服务器类计算机上运行。 -cp &lt;目录和 zip/jar 文件的类搜索路径&gt; -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt; 用 : 分隔的目录, JAR 档案 和 ZIP 档案列表, 用于搜索类文件。 -D&lt;名称&gt;=&lt;值&gt; 设置系统属性 -verbose:[class|gc|jni] 启用详细输出 -version 输出产品版本并退出 -version:&lt;值&gt; 警告: 此功能已过时, 将在 未来发行版中删除。 需要指定的版本才能运行 -showversion 输出产品版本并继续 -jre-restrict-search | -no-jre-restrict-search 警告: 此功能已过时, 将在 未来发行版中删除。 在版本搜索中包括/排除用户专用 JRE -? -help 输出此帮助消息 -X 输出非标准选项的帮助 -ea[:&lt;packagename&gt;...|:&lt;classname&gt;] -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;] 按指定的粒度启用断言 -da[:&lt;packagename&gt;...|:&lt;classname&gt;] -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;] 禁用具有指定粒度的断言 -esa | -enablesystemassertions 启用系统断言 -dsa | -disablesystemassertions 禁用系统断言 -agentlib:&lt;libname&gt;[=&lt;选项&gt;] 加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof 另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help -agentpath:&lt;pathname&gt;[=&lt;选项&gt;] 按完整路径名加载本机代理库 -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;] 加载 Java 编程语言代理, 请参阅 java.lang.instrument -splash:&lt;imagepath&gt; 使用指定的图像显示启动屏幕有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。 注意这两点：java [-options] -jar jarfile [args...] 和 -X 输出非标准选项的帮助 也就是说，java 这个命令行后边的[-options] 是在 -jar jarfile 前面的，我那个命令行里，正好搞反了，我的命令行里的一堆-X或者-XX应当都属于[-options]里面的，这一点可用java -X验证： 123456789101112131415161718192021222324252627282930313233 -Xmixed 混合模式执行 (默认) -Xint 仅解释模式执行 -Xbootclasspath:&lt;用 : 分隔的目录和 zip/jar 文件&gt; 设置搜索路径以引导类和资源 -Xbootclasspath/a:&lt;用 : 分隔的目录和 zip/jar 文件&gt; 附加在引导类路径末尾 -Xbootclasspath/p:&lt;用 : 分隔的目录和 zip/jar 文件&gt; 置于引导类路径之前 -Xdiag 显示附加诊断消息 -Xnoclassgc 禁用类垃圾收集 -Xincgc 启用增量垃圾收集 -Xloggc:&lt;file&gt; 将 GC 状态记录在文件中 (带时间戳) -Xbatch 禁用后台编译 -Xms&lt;size&gt; 设置初始 Java 堆大小 -Xmx&lt;size&gt; 设置最大 Java 堆大小 -Xss&lt;size&gt; 设置 Java 线程堆栈大小 -Xprof 输出 cpu 配置文件数据 -Xfuture 启用最严格的检查, 预期将来的默认值 -Xrs 减少 Java/VM 对操作系统信号的使用 (请参阅文档) -Xcheck:jni 对 JNI 函数执行其他检查 -Xshare:off 不尝试使用共享类数据 -Xshare:auto 在可能的情况下使用共享类数据 (默认) -Xshare:on 要求使用共享类数据, 否则将失败。 -XshowSettings 显示所有设置并继续 -XshowSettings:all 显示所有设置并继续 -XshowSettings:vm 显示所有与 vm 相关的设置并继续 -XshowSettings:properties 显示所有属性设置并继续 -XshowSettings:locale 显示所有与区域设置相关的设置并继续-X 选项是非标准选项, 如有更改, 恕不另行通知。 也就是说，我因为搞反了java中参数的顺序，导致了java忽略掉了我的参数。 那么，如何看到当前JVM真实应用了的参数呢，我查了一下，发现可以用jinfo -flags &lt;pid&gt; 或 java -XX:+PrintFlagsFinal 或 java -XX:+PrintCommandLineFlags 来查看。 运行jinfo -flags &lt;pid&gt;会有以下输出： 123456Attaching to process ID 560, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.66-b17Non-default VM flags: -XX:CICompilerCount=15 -XX:InitialHeapSize=2147483648 -XX:MaxHeapSize=32210157568 -XX:MaxNewSize=10736369664 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=715653120 -XX:OldSize=1431830528 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGCCommand line: 可以看到 Non-default 中 MaxHeapSize 和 MaxNewSize 都是大的离谱的数 32G 和 10G ，这两个数是怎么来的我暂时没找到来源点（猜测是运维平台自动附加的？），同时，可以看到 Command line: 这里是空的，也就是没有应用命令行中的设置参数。 我们再来运行 java -XX:+PrintCommandLineFlags，结果如下： 1-XX:InitialHeapSize=2147483648 -XX:MaxHeapSize=32210157568 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC 可以看到，在命令行上，应用了参数，参数中设置了MaxHeapSize 和 MaxNewSize 为大的离谱的数 32G 和 10G，当然，这个并不是我设置的，估计是一些其他的脚本设置的（猜测，尚未找到源头）。 这个算是个不大不小的坑（这个坑和线上问题有没有关联尚未验证，总之是个坑），以后需要注意。 参考资料Java的Xms和Xmx最小可以是多少 JVM中的MaxHeapSize值不一致问题 JVM实用参数（三）打印所有XX参数及值 JVM系列第12讲：JVM参数之查看JVM参数 jinfo命令详解 what’s means of jinfo non-default vm flags 20190613更新感谢 @祁晓波 的更正，前文提到的那个离谱的32G，应当是在没有明确指定-Xmx时，JVM根据策略自动计算出的堆最大的大小，然后那个10G的新生代大小同样也是依据于策略算出来的，关于其策略可参考官方的Update Release Notes： Garbage collection improvements Updated Client JVM heap configuration In the Client JVM, the default Java heap configuration has been modified to improve the performance of today’s rich client applications. Initial and maximum heap sizes are larger and settings related to generational garbage collection are better tuned. The default maximum heap size is half of the physical memory up to a physical memory size of 192 megabytes and otherwise one fourth of the physical memory up to a physical memory size of 1 gigabyte. For example, if your machine has 128 megabytes of physical memory, then the maximum heap size is 64 megabytes, and greater than or equal to 1 gigabyte of physical memory results in a maximum heap size of 256 megabytes. The maximum heap size is not actually used by the JVM unless your program creates enough objects to require it. A much smaller amount, termed the initial heap size, is allocated during JVM initialization. This amount is at least 8 megabytes and otherwise 1/64 of physical memory up to a physical memory size of 1 gigabyte. The maximum amount of space allocated to the young generation is one third of the total heap size. The updated heap configuration ergonomics apply to all collectors except Concurrent Mark-Sweep (CMS). CMS heap configuration ergonomics remain the same. Server JVM heap configuration ergonomics are now the same as the Client, except that the default maximum heap size for 32-bit JVMs is 1 gigabyte, corresponding to a physical memory size of 4 gigabytes, and for 64-bit JVMs is 32 gigabytes, corresponding to a physical memory size of 128 gigabytes. 还可参考： As of JDK6U18 following are configurations for the Heap Size. In the Client JVM, the default Java heap configuration has been modified to improve the performance of today’s rich client applications. Initial and maximum heap sizes are larger and settings related to generational garbage collection are better tuned. The default maximum heap size is half of the physical memory up to a physical memory size of 192 megabytes and otherwise one fourth of the physical memory up to a physical memory size of 1 gigabyte. For example, if your machine has 128 megabytes of physical memory, then the maximum heap size is 64 megabytes, and greater than or equal to 1 gigabyte of physical memory results in a maximum heap size of 256 megabytes. The maximum heap size is not actually used by the JVM unless your program creates enough objects to require it. A much smaller amount, termed the initial heap size, is allocated during JVM initialization. This amount is at least 8 megabytes and otherwise 1/64 of physical memory up to a physical memory size of 1 gigabyte. Source : http://www.oracle.com/technetwork/java/javase/6u18-142093.html To answer this question it’s critical whether the Java VM is in CLIENT or SERVER mode. You can specify “-client” or “-server” options. Otherwise java uses internal rules; basically win32 is always client and Linux is always server, but see the table here: http://docs.oracle.com/javase/6/docs/technotes/guides/vm/server-class.html Sun/Oracle jre6u18 doc says re client: the VM gets 1/2 of physical memory if machine has &lt;= 192MB; 1/4 of memory if machine has &lt;= 1Gb; max 256Mb. In my test on a 32bit WindowsXP system with 2Gb phys mem, Java allocated 256Mb, which agrees with the doc. Sun/Oracle jre6u18 doc says re server: same as client, then adds confusing language: for 32bit JVM the default max is 1Gb, and for 64 bit JVM the default is 32Gb. In my test on a 64bit linux machine with 8Gb physical, Java allocates 2Gb, which is 1/4 of physical; on a 64bit linux machine with 128Gb physical Java allocates 32Gb, again 1/4 of physical. Thanks to this SO post for guiding me: Definition of server-class machine changed recently? 另外，从JDK源码hotspot\src\share\vm\runtime\arguments.cpp也可看到相关逻辑（猜测是这里，并未看懂） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889void Arguments::set_heap_size() &#123; if (!FLAG_IS_DEFAULT(DefaultMaxRAMFraction)) &#123; // Deprecated flag FLAG_SET_CMDLINE(uintx, MaxRAMFraction, DefaultMaxRAMFraction); &#125; const julong phys_mem = FLAG_IS_DEFAULT(MaxRAM) ? MIN2(os::physical_memory(), (julong)MaxRAM) : (julong)MaxRAM; // If the maximum heap size has not been set with -Xmx, // then set it as fraction of the size of physical memory, // respecting the maximum and minimum sizes of the heap. if (FLAG_IS_DEFAULT(MaxHeapSize)) &#123; julong reasonable_max = phys_mem / MaxRAMFraction; if (phys_mem &lt;= MaxHeapSize * MinRAMFraction) &#123; // Small physical memory, so use a minimum fraction of it for the heap reasonable_max = phys_mem / MinRAMFraction; &#125; else &#123; // Not-small physical memory, so require a heap at least // as large as MaxHeapSize reasonable_max = MAX2(reasonable_max, (julong)MaxHeapSize); &#125; if (!FLAG_IS_DEFAULT(ErgoHeapSizeLimit) &amp;&amp; ErgoHeapSizeLimit != 0) &#123; // Limit the heap size to ErgoHeapSizeLimit reasonable_max = MIN2(reasonable_max, (julong)ErgoHeapSizeLimit); &#125; if (UseCompressedOops) &#123; // Limit the heap size to the maximum possible when using compressed oops julong max_coop_heap = (julong)max_heap_for_compressed_oops(); if (HeapBaseMinAddress + MaxHeapSize &lt; max_coop_heap) &#123; // Heap should be above HeapBaseMinAddress to get zero based compressed oops // but it should be not less than default MaxHeapSize. max_coop_heap -= HeapBaseMinAddress; &#125; reasonable_max = MIN2(reasonable_max, max_coop_heap); &#125; reasonable_max = limit_by_allocatable_memory(reasonable_max); if (!FLAG_IS_DEFAULT(InitialHeapSize)) &#123; // An initial heap size was specified on the command line, // so be sure that the maximum size is consistent. Done // after call to limit_by_allocatable_memory because that // method might reduce the allocation size. reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize); &#125; if (PrintGCDetails &amp;&amp; Verbose) &#123; // Cannot use gclog_or_tty yet. tty-&gt;print_cr(" Maximum heap size " SIZE_FORMAT, (size_t) reasonable_max); &#125; FLAG_SET_ERGO(uintx, MaxHeapSize, (uintx)reasonable_max); &#125; // If the minimum or initial heap_size have not been set or requested to be set // ergonomically, set them accordingly. if (InitialHeapSize == 0 || min_heap_size() == 0) &#123; julong reasonable_minimum = (julong)(OldSize + NewSize); reasonable_minimum = MIN2(reasonable_minimum, (julong)MaxHeapSize); reasonable_minimum = limit_by_allocatable_memory(reasonable_minimum); if (InitialHeapSize == 0) &#123; julong reasonable_initial = phys_mem / InitialRAMFraction; reasonable_initial = MAX3(reasonable_initial, reasonable_minimum, (julong)min_heap_size()); reasonable_initial = MIN2(reasonable_initial, (julong)MaxHeapSize); reasonable_initial = limit_by_allocatable_memory(reasonable_initial); if (PrintGCDetails &amp;&amp; Verbose) &#123; // Cannot use gclog_or_tty yet. tty-&gt;print_cr(" Initial heap size " SIZE_FORMAT, (uintx)reasonable_initial); &#125; FLAG_SET_ERGO(uintx, InitialHeapSize, (uintx)reasonable_initial); &#125; // If the minimum heap size has not been set (via -Xms), // synchronize with InitialHeapSize to avoid errors with the default value. if (min_heap_size() == 0) &#123; set_min_heap_size(MIN2((uintx)reasonable_minimum, InitialHeapSize)); if (PrintGCDetails &amp;&amp; Verbose) &#123; // Cannot use gclog_or_tty yet. tty-&gt;print_cr(" Minimum heap size " SIZE_FORMAT, min_heap_size()); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>JVM</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-security的过滤器链]]></title>
    <url>%2F4c9ae68d.html</url>
    <content type="text"><![CDATA[前言每次在项目中使用spring-security都想调试其内部逻辑，在这里记录一下调试的入口点，以防忘记。 正文调试的入口在org.springframework.security.web.DefaultSecurityFilterChain#DefaultSecurityFilterChain(org.springframework.security.web.util.matcher.RequestMatcher, java.util.List&lt;javax.servlet.Filter&gt;) 12345public DefaultSecurityFilterChain(RequestMatcher requestMatcher, List&lt;Filter&gt; filters) &#123; logger.info("Creating filter chain: " + requestMatcher + ", " + filters); this.requestMatcher = requestMatcher; this.filters = new ArrayList&lt;&gt;(filters); // 在这里加断点就能看到整个过滤器链了&#125; 另外记住一点：当spring-mvc中配有CORS，并且在spring-security配置中没有将CorsConfigurationSource明确配置到corsFilter这个Bean上时，spring-security会“借用”spring-mvc中的CORS配置，切勿配置多余的CORS，关于这个行为可从调试org.springframework.web.filter.CorsFilter得知（另外官方文档上也明确写了这个行为了） 1234567891011121314151617181920... // https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#cors private CorsConfigurationSource corsConfigurationSource() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedOrigins(Arrays.asList(webConfigurationProperties.getCors().getAllowedOrigins())); corsConfiguration.setAllowedMethods(Arrays.asList(webConfigurationProperties.getCors().getAllowedMethods())); corsConfiguration.setAllowedHeaders(Arrays.asList(webConfigurationProperties.getCors().getAllowedHeaders())); corsConfiguration.setExposedHeaders(Arrays.asList(webConfigurationProperties.getCors().getExposedHeaders())); corsConfiguration.setAllowCredentials(webConfigurationProperties.getCors().getAllowCredentials()); corsConfiguration.setMaxAge(webConfigurationProperties.getCors().getMaxAge()); UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource(); urlBasedCorsConfigurationSource.registerCorsConfiguration(webConfigurationProperties.getCors().getMapping(), corsConfiguration); return urlBasedCorsConfigurationSource; &#125; @Bean public CorsFilter corsFilter() &#123; return new CorsFilter(corsConfigurationSource()); &#125;...]]></content>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给spring-security提了一个issue]]></title>
    <url>%2F61edb88e.html</url>
    <content type="text"><![CDATA[前言今天在用spring-security的角色继承时，遇到了一个坑，通过调试源码解决了，然后发现这应该是spring-security本身的一个小问题，然后就在Spring官方的GitHub上提了一个issue 正文我在使用spring-security的角色继承，关键代码片段如下： 1234...// 定义角色继承，两个角色继承之间用空格或and连接roleHierarchyImpl.setHierarchy(&quot;ROLE_DEVELOPER &gt; ROLE_SUPERVISOR and ROLE_SUPERVISOR &gt; ROLE_ADMIN and ROLE_ADMIN &gt; ROLE_USER and ROLE_USER &gt; ROLE_ANONYMOUS&quot;);... 1234...// 定义需要的权限表达式.access(&quot;hasRole(&apos;USER&apos;)&quot;)... 上边关于角色继承的定义方式，是我在使用之前版本的spring-security获得经验，同时，通过spring-security源码的注释也可看到相关说明 12345678910111213141516171819202122232425/** * The simple interface of a role hierarchy. * * @author Michael Mayr */public interface RoleHierarchy &#123; /** * Returns an array of all reachable authorities. * &lt;p&gt; * Reachable authorities are the directly assigned authorities plus all authorities * that are (transitively) reachable from them in the role hierarchy. * &lt;p&gt; * Example:&lt;br&gt; * Role hierarchy: ROLE_A &amp;gt; ROLE_B and ROLE_B &amp;gt; ROLE_C.&lt;br&gt; * Directly assigned authority: ROLE_A.&lt;br&gt; * Reachable authorities: ROLE_A, ROLE_B, ROLE_C. * * @param authorities - List of the directly assigned authorities. * @return List of all reachable authorities given the assigned authorities. */ public Collection&lt;? extends GrantedAuthority&gt; getReachableGrantedAuthorities( Collection&lt;? extends GrantedAuthority&gt; authorities);&#125; 但是，当我实际跑起来后，发现根本不行，角色继承没生效。我就很纳闷了，原来用过spring-security啊，就是这样就可以啊。然后试了改了改权限表达式，结果还是不行，然后我想了想，调试源码吧，调试源码一般都是必杀技。在调试源码的过程中，我逐渐发现了问题所在。 我先给出角色表达式解析以及角色继承解析的相关代码路径，大家可按这个路径跟踪。角色表达式解析： 12345678910111213141516171819202122232425262728293031323334// 由上到下为执行路径，最上端是入口点org.springframework.security.web.FilterChainProxy.VirtualFilterChain#doFilterorg.springframework.security.web.access.intercept.FilterSecurityInterceptor#doFilterorg.springframework.security.access.intercept.AbstractSecurityInterceptor#beforeInvocationorg.springframework.security.web.access.intercept.FilterSecurityInterceptor#invokeorg.springframework.security.access.AccessDecisionManager#decideorg.springframework.security.access.vote.AffirmativeBased#decideorg.springframework.security.web.access.expression.WebExpressionVoter#voteorg.springframework.security.access.expression.ExpressionUtils#evaluateAsBooleanorg.springframework.expression.spel.standard.SpelExpression#getValue(org.springframework.expression.EvaluationContext, java.lang.Class&lt;T&gt;)org.springframework.expression.spel.ast.SpelNodeImpl#getTypedValueorg.springframework.expression.spel.ast.MethodReference#getValueInternal(org.springframework.expression.spel.ExpressionState)org.springframework.expression.spel.ast.MethodReference#getCachedExecutororg.springframework.expression.spel.support.ReflectiveMethodExecutor#executejava.lang.reflect.Method#invokeorg.springframework.security.access.expression.SecurityExpressionRoot#hasRoleorg.springframework.security.access.expression.SecurityExpressionRoot#hasAnyRoleorg.springframework.security.access.expression.SecurityExpressionRoot#hasAnyAuthorityName 注意上边执行路径中的 java.lang.reflect.Method#invoke 实际上，权限控制表达式内部的原理是是用反射去执行对应的用于判断是否有权限方法的，也就是执行 org.springframework.security.access.expression.SecurityExpressionRoot#hasRole 执行到下图中这里后，返回的是false也就是授权未通过，没有对应角色，当前拥有的角色是从org.springframework.security.access.hierarchicalroles.RoleHierarchy#getReachableGrantedAuthorities获得的，里面并没有需要的角色”ROLE”，因此自然就是false 那么为什么没有呢，按照角色继承的定义，应该能够有才对啊，这是我们就需要看角色继承表达式生成具体角色的逻辑了，这个逻辑的代码路径是这个： 12345org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl#setHierarchyorg.springframework.security.access.hierarchicalroles.RoleHierarchyImpl#buildRolesReachableInOneStepMaporg.springframework.security.access.hierarchicalroles.RoleHierarchyImpl#buildRolesReachableInOneOrMoreStepsMap 通过跟踪这些代码，我们从中可以看出，实际上，正确的角色继承表达式应该这样定义： 123...roleHierarchyImpl.setHierarchy(&quot;ROLE_DEVELOPER &gt; ROLE_SUPERVISOR &gt; ROLE_ADMIN &gt; ROLE_USER &gt; ROLE_ANONYMOUS&quot;);... 实际上定义角色继承表达式的规则已经变了，然而，在spring-security代码库中的RoleHierarchy这个类的注释，还保留着旧版的角色继承表达式的定义方式的说明，这应当是代码更新了但是注释未更新，我按照以往的经验以及注释的说明去写，结果掉坑里了。 总结通过这次问题的排查，可以说明：必要的注释可以有，但是不要过分依赖于注释，要相信代码本身，此外在这次调试源码的过程中我还发现了一个调试源码的技巧：利用Drop Frame，可以倒推代码的执行路径。 20190613更新后来我发现，在4.2.x的spring-security中，角色继承表达式不仅仅可以用”and”连接符，它用任何一种连接符都可以。以下为我在issue page上与@rwinch的对话： Thanks for the clarification. RoleHiearchy isn’t implementation specific. Instead it is trying to convey information rather than the configuration. That said, I can see how it might lead to confusion. Can you think of a way that makes the Javadoc in RoleHiearchy read better? If you do have a better wording, would you be willing to open a PR to change the RoleHiearchy Javadoc? Or, to put it another way, perhaps the current version of “RoleHierarchyImpl” is not compatible with the definition rules of the old version of the “role inheritance” expression. Can you clarify why you believe RoleHierarchyImpl worked differently and when it did? The code has gone largely untouched for over 10 years. I reviewed my previous code these two days and learned that I used the version 4.2.2 before.Then, I looked at the source code for 4.2.2 and found out why the “and” connector can be used in the “role inheritance” expression in this version. In fact, in this version, the connector can be any string. Let’s look at the code for details: 123456789101112131415161718192021222324252627282930313233/** * Parse input and build the map for the roles reachable in one step: the higher role * will become a key that references a set of the reachable lower roles. */private void buildRolesReachableInOneStepMap() &#123; Pattern pattern = Pattern.compile("(\\s*([^\\s&gt;]+)\\s*&gt;\\s*([^\\s&gt;]+))"); Matcher roleHierarchyMatcher = pattern .matcher(this.roleHierarchyStringRepresentation); this.rolesReachableInOneStepMap = new HashMap&lt;GrantedAuthority, Set&lt;GrantedAuthority&gt;&gt;(); while (roleHierarchyMatcher.find()) &#123; GrantedAuthority higherRole = new SimpleGrantedAuthority( roleHierarchyMatcher.group(2)); GrantedAuthority lowerRole = new SimpleGrantedAuthority( roleHierarchyMatcher.group(3)); Set&lt;GrantedAuthority&gt; rolesReachableInOneStepSet; if (!this.rolesReachableInOneStepMap.containsKey(higherRole)) &#123; rolesReachableInOneStepSet = new HashSet&lt;GrantedAuthority&gt;(); this.rolesReachableInOneStepMap.put(higherRole, rolesReachableInOneStepSet); &#125; else &#123; rolesReachableInOneStepSet = this.rolesReachableInOneStepMap .get(higherRole); &#125; addReachableRoles(rolesReachableInOneStepSet, lowerRole); logger.debug("buildRolesReachableInOneStepMap() - From role " + higherRole + " one can reach role " + lowerRole + " in one step."); &#125;&#125; In this code, a regular expression grouping match is used to find a group that matches the rule. In fact, the string to be matched can contain any kind of connector. Any kind of connector will not affect the result of the expression “roleHierarchyMatcher.find()” equal to true. 1234567891011121314151617181920212223@Testpublic void testRegexForRoleHierarchyString() &#123; Pattern pattern = Pattern.compile("(\\s*([^\\s&gt;]+)\\s*&gt;\\s*([^\\s&gt;]+))"); String roleHierarchyStringSplitByAnd = "ROLE_HIGHEST &gt; ROLE_HIGHER and ROLE_HIGHER &gt; ROLE_LOW and ROLE_LOW &gt; ROLE_LOWER"; String roleHierarchyStringSplitByOr = "ROLE_HIGHEST &gt; ROLE_HIGHER or ROLE_HIGHER &gt; ROLE_LOW or ROLE_LOW &gt; ROLE_LOWER"; String roleHierarchyStringSplitBySpace = "ROLE_HIGHEST &gt; ROLE_HIGHER ROLE_HIGHER &gt; ROLE_LOW ROLE_LOW &gt; ROLE_LOWER"; String roleHierarchyStringSplitByWhatever = "ROLE_HIGHEST &gt; ROLE_HIGHER xxx ROLE_HIGHER &gt; ROLE_LOW xxx ROLE_LOW &gt; ROLE_LOWER"; List&lt;String&gt; roleHierarchyStrings = new LinkedList&lt;String&gt;(); roleHierarchyStrings.add(roleHierarchyStringSplitByAnd); roleHierarchyStrings.add(roleHierarchyStringSplitByOr); roleHierarchyStrings.add(roleHierarchyStringSplitBySpace); roleHierarchyStrings.add(roleHierarchyStringSplitByWhatever); for (String roleHierarchyString : roleHierarchyStrings) &#123; Matcher roleHierarchyMatcher = pattern.matcher(roleHierarchyString); if (!roleHierarchyMatcher.find()) &#123; throw new RuntimeException("I'm dead. X﹏X"); &#125; &#125; System.out.println("All pass");&#125; 123All passProcess finished with exit code 0 That is to say, in the version 4.2.2 or the adjacent version, the “RoleHierarchy” comment is neither an error nor a correct one, XD. 12345678910111213141516171819202122232425/** * The simple interface of a role hierarchy. * * @author Michael Mayr */public interface RoleHierarchy &#123; /** * Returns an array of all reachable authorities. * &lt;p&gt; * Reachable authorities are the directly assigned authorities plus all authorities * that are (transitively) reachable from them in the role hierarchy. * &lt;p&gt; * Example:&lt;br&gt; * Role hierarchy: ROLE_A &amp;gt; ROLE_B and ROLE_B &amp;gt; ROLE_C.&lt;br&gt; * Directly assigned authority: ROLE_A.&lt;br&gt; * Reachable authorities: ROLE_A, ROLE_B, ROLE_C. * * @param authorities - List of the directly assigned authorities. * @return List of all reachable authorities given the assigned authorities. */ public Collection&lt;? extends GrantedAuthority&gt; getReachableGrantedAuthorities( Collection&lt;? extends GrantedAuthority&gt; authorities);&#125;]]></content>
      <tags>
        <tag>源码</tag>
        <tag>踩坑</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows环境下开启log4j2彩色日志输出]]></title>
    <url>%2Fae32ecc0.html</url>
    <content type="text"><![CDATA[正文刚刚换到了Windows环境开发，发现原来macOS下配的彩色日志失效了，查了一下，需要加参数：-Dlog4j.skipJansi=false，加上后就好了。]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal的hash算法（关于 0x61c88647）]]></title>
    <url>%2F242f9cf5.html</url>
    <content type="text"><![CDATA[前言此文原是「研习小组」中的一篇主题，当时我在这个主题上花了一番精力，有一些收获，在这里记录一下，备忘。 正文这段时间我看了陈同学的一篇文章，里面提到了 ThreadLocal ，它的源码我以前没看过，所以就借着这个机会看了一下，我发现了在 ThreadLocal 里的 ThreadLocalMap 当中，使用了一种被称之为 斐波那契散列 (存疑)的哈希函数，他的大致过程是： 每次用 0x61c88647 这个数累加。（这里对应哈希函数的一般操作步骤的第一步 ） 123// 这个数可以这样计算出来 ~(2^32 / 1.618) + 0b1 (这里 ^ 代表求幂操作)BigDecimal goldenRatioResult = BigDecimal.valueOf(Math.pow(2, 32)).divide(new BigDecimal("1.618"), 0, ROUND_HALF_UP);int hashIncrenment = ~goldenRatioResult.intValue() + 0b1; // 等效于 Math.abs() 结果是 1640531527 也就是十六进制的 0x61c88647 得到的结果按位和 ThreadLocalMap 的容量-1 做 &amp; 操作。（这里实际上对应了哈希函数的一般操作步骤的第二步，也就是将第一步计算的值和哈希表的容量做取模操作。另外，这里ThreadLocalMap 的容量必须为2的幂，之所以有这样的规定，是因为，当求解 x % y 时，如果y = 2^n 那么取模操作可以转换为按位与操作 x &amp; (y - 1)，效率会比取模操作高，取模操作可以看作是除操作，而除操作是性能比较低的） 12345678910111213/** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */private static final int HASH_INCREMENT = 0x61c88647;/** * Returns the next hash code. */private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; 其中需要注意的是1.618这个数又叫 黄金分割 (黄金分割也可以是0.618，0.618和1.618互为倒数，也就是1/1.618 = 0.618)，而这个黄金分割又是可以由斐波那契数列推导出来的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1. n a(n)0 01 12 13 24 35 56 87 138 219 3410 5511 8912 14413 23314 37715 61016 98717 159718 258419 418120 676521 1094622 1771123 2865724 4636825 7502526 12139327 19641828 31781129 51422930 83204031 134626932 217830933 352457834 570288735 922746536 1493035237 2415781738 3908816939 6324598640 102334155102334155 / 63245986 = 1.61803从上边观察，对于考后的 n ，a(n+1) / a(n) 约等于 1.618 「Golden ratio」「Fibonacci number」 那么问题就来了： 为什么一定要用黄金分割来累加？我看到有个视频说用黄金分割可以让hash值分散(存疑)，但是我有一个疑问，用别的一个什么数，不照样可以让 hash 分开吗？ 另外 ThreadLocalMap 的 hash 最后还需要用按位与的方式用掩码消除高位，那么为什么消除高位后仍能保持得到hash值的分散呢。(存疑，有可能压根不是仍然保持分散) 概念与理论哈希函数的一般分类 Division Based Hash Functions h(x) = x % MBit-Shifting Hash Functions Using the Middle Square MethodMultiplicative Hash Functions 斐波那契哈希属于Multiplicative Hash Functions中的一种实现 In the multiplicative method, the multiplier A must be carefully chosen to scatter the numbers in −1 the table. A very good choice for the constant A is φ W , where φ, known as the golden ratio , is the positive root of the polynomialx 2 − x − 1This is because x is a solution to the polynomial if and only ifx 2 − x − 1=0 iff x 2 − x =1iff x − 11 = xIn other words, a solution x has the property that its inverse is x − 1. The solution, φ, is called the golden ratio because it arises in nature in an astonishing number of places and because the ancient Greeks used this ratio in the design of many of their buildings, considering it a divine −1 2 proportion . Thus, φ and φ = φ − 1 are both roots of x x1. φ is also the value to which th −1 f n /f n−1 converges as n → ∞, where f n is the n Fibonacci number. Since φ = φ − 1, it is approximately 0.6180339887498948482045868343656. (Well approximately depends on your notionof approximation, doesn’t it?)−1 When we let A = φ Was the multiplicative constant, the multiplicative method is called Fibonacci hashing . The constant has many remarkable and astonishing mathematical properties, but the property that makes it a good factor in the above hash function is the following fact.−1 −1 −1 First observe that the sequence of values φ , 2φ , 3φ , … lies entirely in the interval (0, 1). Remember that the curly braces mean, the fractional part of, so for example, 2φ −1 ≈ −1 −1 1.236067977 and≈ 0.236067977.2φThe rst value, two segments whose lengths are in the golden ratio. 哈希函数的一般步骤 Main article: Hash functionThe idea of hashing is to distribute the entries (key/value pairs) across an array of buckets_index that suggests where the entry can be found:index = f(key, array_size)&gt; Often this is done in two steps:hash = hashfunc(key)index = hash % array_size&gt; In this method, the hash_reduced to an index (a number between 0 and array_size − 1) using the modulo operator (%).In the case that the array size is a power of two, the remainder operation is reduced to masking, which improves speed, but can increase problems with a poor hash function.[5] 「Hash table」 Modulo operations might be implemented such that a division with a remainder is calculated each time. For special cases, on some hardware, faster alternatives exist. For example, the modulo of powers of 2 can alternatively be expressed as a bitwise AND operation:x % 2 == x &amp; (2 - 1)Examples (assuming x is a positive integer):x % 2 == x &amp; 1``x % 4 == x &amp; 3``x % 8 == x &amp; 7In devices and software that implement bitwise operations more efficiently than modulo, these alternative forms can result in faster calculations.[11]Optimizing compilers may recognize expressions of the form expression % constant where constant is a power of two and automatically implement them as expression &amp; (constant-1). This can allow writing clearer code without compromising performance. This optimization is not possible for languages in which the result of the modulo operation has the sign of the dividend (including C), unless the dividend is of an unsigned integer type. This is because, if the dividend is negative, the modulo will be negative, whereas expression &amp; (constant-1) will always be positive. 「Modulo operation」 怎样是好的哈希函数 Properties of a Good Hash FunctionhashTo means to chop up or make a mess of things, liked hashed potatoes. A hash function is supposed to chop up its argument and reconstruct a value out of the chopped up little pieces. Good hash functions• make the original value intractably hard to reconstruct from the computed hash value,• are easy to compute (for speed), and• randomly disperse keys evenly throughout the table, making sure that no two keys map to the same index. Choosing a hash functionA good hash function and implementation algorithm are essential for good hash table performance, but may be difficult to achieve.citation needed[6]A basic requirement is that the function should provide a uniform distribution of hash values. A non-uniform distribution increases the number of collisions and the cost of resolving them. Uniformity is sometimes difficult to ensure by design, but may be evaluated empirically using statistical tests, e.g., a Pearson’s chi-squared test for discrete uniform distributions.[7][8]The distribution needs to be uniform only for table sizes that occur in the application. In particular, if one uses dynamic resizing with exact doubling and halving of the table size, then the hash function needs to be uniform only when the size is a power of two. Here the index can be computed as some range of bits of the hash function. On the other hand, some hashing algorithms prefer to have the size be a prime number.[9] The modulus operation may provide some additional mixing; this is especially useful with a poor hash function.For open addressing schemes, the hash function should also avoid clustering, the mapping of two or more keys to consecutive slots. Such clustering may cause the lookup cost to skyrocket, even if the load factor is low and collisions are infrequent. The popular multiplicative hash[3] is claimed to have particularly poor clustering behavior.[9] 好的哈希函数应该能做到“discrete uniform distributions”，也就是“离散均匀分布”，而斐波那契哈希是可以做到很好的“离散均匀分布”的，取一个别的值不一定能做到（也并不一定做不到），这个可以通过一个实验观察到。下图为我写的一个DEMO，红色虚线框中是斐波那契散列，其他的为其他数做的对比：（在 0 - 1 内的分布） 以下为 ThreadLocalMap 自身的 hash 函数的分布情况：（可以看出来，当值为 1.618 时，是“离散均匀分布”的，其他值，也能做到一定的离散均匀分布，但是有的值就做不到）(存疑) Re: Golden Ratio &amp; Hash TablesPosted: Nov 2, 2002 2:58 AM Click to see the message monospaced in plain text Plain Text Click to reply to this topic Reply“Alexei A. Frounze” alexfru@chat.ru wrote in message news:apop0i$3ib1k$2@ID-57378.news.dfncis.de… Can anybody enlighten me why golden ratio is so widely used when doing hashtables? Is it the only possible and effective value? I’ve not found anythingabout this particular choice in the Sedgewick’s book, just the fact thatit’s used. Any simple explanation?I believe Knuth has explanation, but I don’t have the book handy and don’tknow when I’ll be able to read it. Can you explain why (sqrt(5)-1)/2, butnot let’s say (sqrt(3)-1)/2? Does this really have anything to do withFibonacci numbers, packing of seeds and thelike?TIA The usual explanation is that it provides the best dispersion ofconsecutive keys in a multiplicative hash table: that was Knuth’sreason for advocating it.For a hash table of size 2^N, an index for each key K can beconstructed by multiplying K * M, where M is a prime number close to2^N * R, R being the inverse golden ratio (sqrt(5)-1)/2. Keep the Nmost significant bits as the hash index. Knuth’s finding was that thedispersion of indexes for a sequence of consecutive keys is maximizedwhen M is chosen this way, thus a multiplicative hash table with adense set of keys will have the fewest possible collisions when Mapprox= 2^N * R.–Chris Green 「Topic: Golden Ratio &amp; Hash Tables」 x mod 2^k is not a desirable function because it does not depend on all the bits in the binary representation of x. Similarly, it is often tempting to let M be a power of two. E.g., for some integer k&gt;_1. In this case, the hash function simply extracts the bottom _k bits of the binary representation of x. While this hash function is quite easy to compute, it is not a desirable function because it does not depend on all the bits in the binary representation of x. 「Division Method」 哈希表的冲突处理 • separate chaining• open addressing Open AddressingIn open addressing, there are no separate lists attached to the table. All values are in the table itself. When a collision occurs, the cells of the hash table itself are searched until an empty one is found. Which cells are searched depends upon the specic method of open addressing. All variations can be described generically by a sequence of functionsh 0 (x) h 1 (x)h k (x)= = … =h(x) + f(0, x) % M h(x) + f(1, x) % Mh(x) + f(k, x) % Mthwhere h i (x) is the ilocation tested and f(i, x) is a function that returns some integer value based on the values of i and x. The idea is that the hash function h(x) is rst used to nd a location in the hash table for x. If we are trying to insert x into the table, and the index h(x) is empty, we insert it there. Otherwise we need to search for another place in the table into which we can store x. The function f(i, x), called the collision resolution function , serves that purpose. We search the locationsh(x) + f(0, x) % M h(x) + f(1, x) % M h(x) + f(2, x) % M … h(x) + f(k, x)% Muntil either an empty cell is found or the search returns to a cell previously visited in the sequence. The function f(i, x) need not depend on both i and x. Soon, we will look at a few dierent collision resolution functions.To search for an item, the same collision resolution function is used. The hash function is applied to nd the rst index. If the key is there, the search stops. Otherwise, the table is searched until either the item is found or an empty cell is reached. If an empty cell is reached, it implies that the item is not in the table. This raises a question about how to delete items. If an item is deleted, then there will be no way to tell whether the search should stop when it reaches an empty cell, or just jump over the hole. The way around this problem is to lazy deletion . In lazy deletion, the cell is marked DELETED. Only when it is needed again is it re-used. Every cell is marked as eitherACTIVE: it has an item in itEMPTY: it has no item in itDELETED: it had an item that was deleted  it can be re-usedThese three constants are supposed to be dened for any hash table implementation in the ANSI standard.There are several dierent methods of collision resolution using open addressing: linear probing , quadratic probing , double hashing , and hopscotch hashing . 参考资料 「Java中Integer越界的处理」“2的32次方除以1.618这个数，得出来一个结果，每次用这个结果累加”，这个累加操作很快就会造成整数越界 「关于’二补码’(Two’s Complement)」负数转正数或者正数转负数的操作都是用的 二补码 这个操作，这个操作内容就是：按位取反 + 二进制1 「Fibonacci Hashing」 「Fibonacci Hashing &amp; Fastest Hashtable」 「Hashing, Hash Tables and Scatter Tables」 「Fibonacci Hashing: The Optimization that the World Forgot (or: a Better Alternative to Integer Modulo)」这篇是最推荐的，同时还有关于这篇的评论 「Hacker News」 「Fibonacci Hashing」 「为什么使用0x61c88647」 「Why 0x61c88647?」 「浅谈算法和数据结构: 十一 哈希表」]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注意自动拆箱可能引起空指针]]></title>
    <url>%2Fc821db80.html</url>
    <content type="text"><![CDATA[正文今天帮同事看了一个问题，问题大致可以抽象成是这样： 123456... Long nullLong = null; if (0 == nullLong) &#123; // do something &#125;... 这个会爆出空指针 1Exception in thread "main" java.lang.NullPointerException Why? 注意代码的第二行if (0 == nullLong)，这里实际上会触发一个自动拆箱的操作，而空指针就是自动拆箱过程中引发的。为什么会引发？我们得来看自动拆箱是怎么做的，可以翻一下.class文件，就明了了： 123456789...L1 LINENUMBER 7 L1 LCONST_0 ALOAD 1 INVOKEVIRTUAL java/lang/Long.longValue ()J LCMP IFNE L2... 通过上边的反汇编的内容可以看出来，自动拆箱实际上是编译器隐式调用了java/lang/Long.longValue这个方法，这个方法在被调用时，本身被调用的目标对象是null，当然会报空指针的。 这个算是一个隐形的小坑吧，平常没注意，也就是同事正好出这个问题才注意到，记录一下，以后可以避免掉。]]></content>
      <tags>
        <tag>Java基础</tag>
        <tag>源码</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用idea内置的比对功能比较和替换工程文件]]></title>
    <url>%2F36c2bce4.html</url>
    <content type="text"><![CDATA[前言有时候，我们需要将工程里的一部分文件和外部的文件进行比对和替换，这时候，可以考虑 idea 内置的比对功能。这几天，在工作中遇到了需要将工程里的文件和外部文件进行比对替换的场景，我尝试使用 idea 内置的比对工具来完成，发现效果不错，记录一下 正文比对工具的入口是在需要比对的目录或文件上点右键，然后点击 Compare With... 然后选择外部目录或文件就可以了 比对窗口中会按行排列比对项，在每行中有左箭头，右箭头，不等号等几个图示，分别代从右表复制到左、从左复制到右和差异合并（类似于Git的Merge），然后，最重要的是上边的同步按钮，Synchronize Selected 就是同步当前选定的比对行，同样还有同步所有比对行的按钮。 如果有需要和工程外文件或目录比对的需求，可以考虑使用。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Chrome的一个实用隐藏功能]]></title>
    <url>%2Fc1df7c9e.html</url>
    <content type="text"><![CDATA[发现了一个 Google Chrome 里的实用隐藏功能。 当开发者工具处于打开状态时，在 Chrome 顶部工具栏的刷新键上长按，会出现上下文菜单，里面包含了硬刷新等功能，比较好用。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8一行搞定缓存逻辑]]></title>
    <url>%2F504abf90.html</url>
    <content type="text"><![CDATA[Show me the code: 12345678910111213...private static final ConcurrentHashMap&lt;String, String&gt; CACHE = new ConcurrentHashMap&lt;&gt;();public void someMethod() &#123; String value = CACHE.get("key") == null ? CACHE.getOrDefault("key", CACHE.putIfAbsent("key", genValue())) : CACHE.get("key");&#125;private String genValue() &#123; ... return value;&#125;...]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018，我的年终总结]]></title>
    <url>%2F9eeaad15.html</url>
    <content type="text"><![CDATA[前言本文实际上是昨天我在公司里写的一篇年终总结，我想了想，发到博客里吧，去掉了敏感信息，另外做了其他的一些适当的改动。 正文我自己总结了一下，从入职到现在，我的工作逐步形成了四条路线：业务开发、技术探索、工程探索以及性能优化。我大致总结一下四条线我都做了哪些事，遇到了哪些挑战，以及未来的规划。 业务开发此段为了脱敏，删掉。 技术探索技术一直是我关注的点，无论是在58还是在之前的公司。在入职后到现在，我在技术探索方面做了以下几件事： 我逐渐理解了58集团的基础架构中间件 SCF 和 WF，阅读了 SCF 的部分源码，并和部门同事做了分享，我个人认为，理解手中工具的原理，是极其重要的，不理解，在出现问题后会是盲目的，因此未来的计划中，我仍会继续阅读基础架构组件的源码（不限于SCF，只要是日常会用到的都可以），并将阅读和理解的所得总结成文章分享出来，同时带动同事共同参与。 在实践过程中，我发现了 SCF/WF 的一些痛点，想要缓解这些痛点，我认为，拥抱开源是一个解决方案，我尝试将 spring-boot 引入进来，（不会取代 SCF 的，而会想办法结合），并在具体业务中进行了实践。在这个过程中，遇到的挑战是，你替换掉了集团的标准实现，就意味着放弃了一部分集团提供的基础能力，比如监控。事情总是有代价的，有一得就有一失，很多事说到底无非都是取舍。在未来的计划中，我会尝试研究怎样继续兼容集团提供的能力，并且尝试引入开源的能力。 反应式编程模型的探索。在我手头负责的业务中，我正在尝试为其引入新的编程模型 - 反应式编程模型（具体承载者为 spring-webflux）。现在我已将基本的业务逻辑架构用新的编程模型实现完成（摒弃了旧的基于模版方法的架构模式，改为灵活度更高的 service-provider 模式），并且完成了一小部分具体业务。在将来的计划中，我会逐步完善，并上线测试，最终实现用新的架构彻底取代旧的架构。 在实践中我发现，现有 SCF/WF 工程中缺少 IOC 以及 AOP 这样的基本结构，因此我尝试在工程中接入了 Dagger2 和 AspectJ 这两个框架，来为工程引入 IOC 和 AOP 的能力，并在业务工程中进行了实践。 在实践中逐步了解了集团的容器平台以及其他的，诸如大数据、工程效率，等等平台的玩法，并积极发现其高级玩法，如容器平台的自有日志采集，通过接入云平台自有日志采集，将日志采集逻辑从具体业务中彻底去掉，业务逻辑不需要在关心底层的逻辑，只需要关心其自身。 我个人一直相信一个观点，新的总是好的（新，实际上就是旧版本修复 bugs，增加 features），因此，我尝试将我负责的业务工程的 Java 版本升级到了 8，事实证明，这一升级带来的好处是相当巨大的，Java8 中引入了革命性的函数式的编程模型，其 lambda 和 stream 能将代码量减少大致 40% 左右（工程实践所得），更重要的是 Java8 的 stream 能够提供一种‘无中断’的编码过程，思路会像河流一样是顺序的，而不是像以前 for 循环那样停顿的（stream 本身的意思即为 ‘流’）。在将来的计划中，我会尝试与集团运维同学沟通，尝试为工程引入 Java11，以用起来更高级的特性，从而解放生产力。 工程探索如果说架构是灵魂，那么工程就是血肉，架构是需要工程来实现的，在我的职业生涯中，工程，一直也是我关注的点。入职后，我积极的发现工程中的痛点，尝试给出解决方案。 SCF/WF 工程本地调试能力的引入。在入职后我做的第一件事就是尝试为 SCF/WF 工程引入断点调试的能力，我通过 maven 实现了它，并且将方法共享给了同事（同时，在研究过程中我初步了解了 SCF 的启动流程的原理，在研究工程的同时，你也会逐步的理解架构，他们是相辅相承的）。 spring-boot 工程在 58工程效率平台 和 58容器平台 的部署实践。由于我们想要引入 spring-boot ，所以，我们必须要让 spring-boot 能够落地于工程，我通过和同事共同研究了 58工程效率平台 和 58容器平台 的构建部署原理后，总结出了 spring-boot 工程在 58工程效率平台 和 58容器平台 落地的实践方法，并写成文章发布于集团技术大群，影响了集团其他业务线的同事（先后有3位其他业务线同事找过我，并且应用了我提供的工程实践），在将来的计划中，我会持续优化工程结构，实现工程效率最大化。 性能优化性能优化可以说是我职业生涯中的新挑战。在性能优化方面我主要做了以下工作。 业务的性能优化。由于我负责的业务的特性，性能优化是其很重要的一个点。在接手业务以来，比较重要的的优化是通过阅读 SCF 源码了解了其执行部分的抽象模型，进而和同事一起优化了业务 SCF 线程池总数。在将来的计划中，我计划继续进行优化，最终达到缩减集群实例规模，提升响应时间的目标。 SCF 启动速度优化。通过 火焰图 分析，我了解到，SCF 的序列化部分的逻辑占了整个 SCF 启动的大部分时间，同时结合我在公司知识共享平台上看到的外部门同事写的 SCF 启动速度调优经验文章，我在部门某工程中实践了 SCF 启动速度优化的办法，有效降低了 40% 左右的启动时间。 综述以上就是我入职以来的工作总结以及未来的计划。在整体上，我计划未来的工作仍然会按照这四条路线开展，同时在工作之余积极参与开源社区交流，并将收获分享于团队。]]></content>
      <tags>
        <tag>职业生涯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理工具Charles设置PAC自动代理]]></title>
    <url>%2Fb6b16b10.html</url>
    <content type="text"><![CDATA[正文代理工具 Charles 可以设置成 pac 自动代理模式，在自动代理模式下，你关闭代理后fallback到直立连模式，这样就不会带来关闭代理就没法Wi-Fi上网的尴尬了，具体使用方式是： 12# 配置 pac 地址https://chls.pro/&lt;你的IP&gt;.pac 参考资料Auto configuration]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于'二补码'(Two's Complement)]]></title>
    <url>%2Ff89c2671.html</url>
    <content type="text"><![CDATA[前言前一篇文章中，我提到了，在研究一个问题的时候，顺便了解了 Java 的 int 溢出处理。其实，在研究时，还涉及到了另一个概念的理解，那就是 Java 中负数的二进制表现形式：二补码（英文为 Two&#39;s Complement），在这篇文章中我们来了解一下。 正文开始之前，我们先来回顾两个规则： 在 Java 中，全部为有符号数，最高位为符号位，0代表正数，1代表负数 在 Java 中 int 为 32位。 好，复习完了这两条规则，我们开始吧，我们先来说结论，在 Java 中，负数转正数或者正数转负数的操作都是用的 二补码 这个操作，这个操作内容就是：按位取反 + 二进制1，我们来看一个例子。 123456789101112131415161718192021// 十进制数1640531527// 1640531527 转为二进制01100001110010001000011001000111// 1640531527 按位取反10011110001101110111100110111000// 二进制的 100000000000000000000000000000001// 二进制加法 1640531527 按位取反后的数 + 1 10011110001101110111100110111000+ 00000000000000000000000000000001-----------------------------------= 10011110001101110111100110111001// 最后的到的 10011110001101110111100110111001 从新转为 10 进制-1640531527 上边的过程用 Java 代码表示： 1System.out.println(~0b01100001110010001000011001000111 + 0b00000000000000000000000000000001); 关于负数正数，为什么是按位取反再加一这种规则，再多写一些，看了阮一峰的一篇文章，了解到的： 12345678910111213141516171819202122232425262728293031323334353637383940// 大家可以想一下，设 a = 1640531527，取取负数 b ，可以用 b = 0 - a 来实现，换成二进制运算如下// 二进制的 000000000000000000000000000000000// 二进制的 164053152701100001110010001000011001000111// 二进制的减法 0 - 1640531527 00000000000000000000000000000000- 01100001110010001000011001000111-----------------------------------=？// 在上边的算式里，你会发现，没法减，下边的数比上边的大，想要减需要借位，也就是变成下边这样 100000000000000000000000000000000- 01100001110010001000011001000111-----------------------------------= 10011110001101110111100110111000// 上边的算式中，被减数是凭空接了 1 位的，这样就够减了，其实大家仔细观察一下，100000000000000000000000000000000 减 01100001110010001000011001000111 后得到的 10011110001101110111100110111000 实际上就是 01100001110010001000011001000111 按位取了一下反// 我们再来观察一下 100000000000000000000000000000000 是可以按下面的式子分解的100000000000000000000000000000000 = 11111111111111111111111111111111 + 00000000000000000000000000000001// 那么，其实上边的减法我们可以化为如下形式 11111111111111111111111111111111+ 00000000000000000000000000000001-----------------------------------= 100000000000000000000000000000000- 01100001110010001000011001000111-----------------------------------= 10011110001101110111100110111000// 再清晰一些：我们设 a = 01100001110010001000011001000111，求 -a，那么就是-a = 0 - a-a = (11111111111111111111111111111111 + 00000000000000000000000000000001) - a-a = (11111111111111111111111111111111 - a) + 00000000000000000000000000000001// 上边的式子就很清楚了 11111111111111111111111111111111 - a 其实就是把 a 按位取反，而后边加上了 00000000000000000000000000000001 就是 + 1，也就是正数转负数（负数转正数）就是按位取反再加一-a = ~a + 1 参考资料关于2的补码 2’s complement]]></content>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中Integer越界的处理]]></title>
    <url>%2F12b48437.html</url>
    <content type="text"><![CDATA[前言这两天在研究一个问题时，偶然的越到了 int 越界的问题，我很惊奇的发现，当一个 数 大于了 Integer.MAX_VALUE 时，用 System.out.println() 输出后，会得到一个负数。我很好奇这个负数是怎么来的，所以查了一下资料，了解了一下 Java 对于 int 越界的处理。 正文在 Java 里，对于 int 的越界处理十分的简单：当一个数超过了 Integer.MAX_VALUE 后，Java 就会从 Integer 的另一头从新开始，也就是从 Integer.MIN_VALUE 往回倒推。 也就是 越界数能显示的结果 = Integer.MIN_VALUE + (越界数 - Integer.MAX_VALUE) - 1 12345678public static void main(String[] args) &#123; BigDecimal magic = BigDecimal.valueOf(Math.pow(2, 32)).divide(new BigDecimal("1.618"), 0, BigDecimal.ROUND_HALF_UP); System.out.println(magic.intValue() + " : " + Integer.toBinaryString(magic.intValue())); BigInteger bigInteger = new BigInteger(magic.toEngineeringString()); System.out.println(" " + magic.toEngineeringString() + " : " + Long.toBinaryString(bigInteger.longValue())); System.out.println(Integer.MIN_VALUE + (magic.longValue() - Integer.MAX_VALUE) - 1);&#125; 1234// 结果-1640475766 : 10011110001110000101001110001010 2654491530 : 10011110001110000101001110001010-1640475766 参考资料How does Java handle integer underflows and overflows and how would you check for it? Integer overflow]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个通用的基于Comparable的Validator]]></title>
    <url>%2F739a4aff.html</url>
    <content type="text"><![CDATA[前言大家知道，在 Spring 中，有个很实用的 Bean Validation 的功能，它可以让我们用声明式的方式轻松分离验证逻辑。它内置了一些基础的验证器，但是，有一个比较常见的场景，这些内置的验证器是没有支持的，这个场景就是 “开始时间必须在结束时间之前”。我想了一想，通过 Java 中的反射以及 Comparable/Comparator 实现了一套通用的验证器，理论上，任何一种能通过比较逻辑比较的值，都可以验了。 正文大家可以先想一下，要实现一个类中去验证某两个属性的大小关系（或者一般的来讲：基于比较器的关系），该有哪些步骤呢？首先要比较两个属性，那么就需要拿到这两个属性的值，凭借经验，我们很容易就能想到：反射；其次，想比较两个值的大小，这个就更简单了，若两个值都是 Comparable 的，那么直接调用 java.lang.Comparable#compareTo 就好了。倘若不是 Comparable 的，那也好办，在 Java 中，有这么一个类 java.util.Comparator 它是任何一种比较逻辑的总接口，只要我们能给出一个实现了它的比较逻辑（或者说函数），也就可以验了。 OK，思路有了，按照 Spring 以及 Bean Validation 的规则实现出来就好了（这些规则请自行 Google），先来看基于 Comparable 的验证： 123456789101112131415161718192021@Constraint(validatedBy = ComparableFieldsMatchValidator.class) //注意这个，这个声明了用哪个验证器去验证@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ComparableFieldsMatch &#123; // 想要参与比较的左值 String leftFieldName(); // 想要参与比较的左值 String rightFieldName(); // 比较的规则 CompareRule compareRule(); // 以下三个方法是 @Constraint 必须要有的 String message() default ""; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 比较的规则public enum CompareRule &#123; LEFT_GREATER_THEN_RIGHT &#123; @Override public List&lt;Integer&gt; acceptableValue() &#123; return Collections.singletonList(1); &#125; @Override public String messageTemplate() &#123; return "⚠ 左值 [%s] 应比右值 [%s] 大"; &#125; &#125;, LEFT_EQUAL_RIGHT &#123; @Override public List&lt;Integer&gt; acceptableValue() &#123; return Collections.singletonList(0); &#125; @Override public String messageTemplate() &#123; return "⚠ 左值 [%s] 应等于右值 [%s]"; &#125; &#125;, LEFT_LESS_THEN_RIGHT &#123; @Override public List&lt;Integer&gt; acceptableValue() &#123; return Collections.singletonList(-1); &#125; @Override public String messageTemplate() &#123; return "⚠ 左值 [%s] 应比右值 [%s] 小"; &#125; &#125;, LEFT_GREATER_EQUAL_THEN_RIGHT &#123; @Override public List&lt;Integer&gt; acceptableValue() &#123; return Arrays.asList(1, 0); &#125; @Override public String messageTemplate() &#123; return "⚠ 左值 [%s] 应大于等于右值 [%s]"; &#125; &#125;, LEFT_LESS_EQUAL_THEN_RIGHT &#123; @Override public List&lt;Integer&gt; acceptableValue() &#123; return Arrays.asList(-1, 0); &#125; @Override public String messageTemplate() &#123; return "⚠ 左值 [%s] 应小于等于右值 [%s]"; &#125; &#125;; public abstract List&lt;Integer&gt; acceptableValue(); public abstract String messageTemplate();&#125; 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ComparableFieldsMatches &#123; ComparableFieldsMatch[] value() default &#123;&#125;;&#125; 12345678910111213141516171819202122// 验证器public class ComparableFieldsMatchValidator implements ConstraintValidator&lt;ComparableFieldsMatch, Object&gt; &#123; private ComparableFieldsMatch constraintAnnotation; @Override public void initialize(ComparableFieldsMatch constraintAnnotation) &#123; this.constraintAnnotation = constraintAnnotation; &#125; @Override public boolean isValid(Object fieldsOwner, ConstraintValidatorContext context) &#123; // 通过反射拿到需要比较的 左、右值 Object leftFieldValue = Utils.getFieldThenMakeAccessible(fieldsOwner, constraintAnnotation.leftFieldName()); Object rightFieldValue = Utils.getFieldThenMakeAccessible(fieldsOwner, constraintAnnotation.rightFieldName()); CompareRule compareRule = constraintAnnotation.compareRule(); int compareToResult = ((Comparable) leftFieldValue).compareTo(rightFieldValue); return compareRule.acceptableValue().contains(compareToResult); // 如果比较结果命中了比较规则编码的 acceptableValue，则是合规的 &#125;&#125; 再来看基于 Comparator 的验证： 1234567891011121314151617181920@Constraint(validatedBy = ComparatorFieldsMatchValidator.class)@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ComparatorFieldsMatch &#123; String leftFieldName(); String rightFieldName(); // 需要的 Comparator 的 Class Class&lt;? extends Comparator&gt; comparatorClass(); CompareRule compareRule(); String message() default ""; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ComparatorFieldsMatches &#123; ComparatorFieldsMatch[] value() default &#123;&#125;;&#125; 1234567891011121314151617181920212223242526272829// https://www.baeldung.com/spring-mvc-custom-validator// http://daobin.wang/2017/06/Spring-Validation/public class ComparatorFieldsMatchValidator implements ConstraintValidator&lt;ComparatorFieldsMatch, Object&gt; &#123; private ComparatorFieldsMatch constraintAnnotation; @Override public void initialize(ComparatorFieldsMatch constraintAnnotation) &#123; this.constraintAnnotation = constraintAnnotation; &#125; @Override public boolean isValid(Object fieldsOwner, ConstraintValidatorContext context) &#123; Object leftFieldValue = Utils.getFieldThenMakeAccessible(fieldsOwner, constraintAnnotation.leftFieldName()); Object rightFieldValue = Utils.getFieldThenMakeAccessible(fieldsOwner, constraintAnnotation.rightFieldName()); CompareRule compareRule = constraintAnnotation.compareRule(); // 获得 Comparator 的 Class，并用反射创建示例 try &#123; Comparator comparator = constraintAnnotation.comparatorClass().newInstance(); int compareResult = comparator.compare(leftFieldValue, rightFieldValue); return compareRule.acceptableValue().contains(compareResult); &#125; catch (InstantiationException | IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 好了，验证器写好了，我们再来看一下使用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@ComparableFieldsMatches( @ComparableFieldsMatch( leftFieldName = "startTime", rightFieldName = "endTime", compareRule = CompareRule.LEFT_LESS_THEN_RIGHT, message = "开始时间不能在结束时间之后" ))public class DatePeriod &#123; public DatePeriod() &#123; &#125; public DatePeriod(@PastOrPresent @NotNull Date startTime, @PastOrPresent @NotNull Date endTime) &#123; this.startTime = startTime; this.endTime = endTime; &#125; @ApiModelProperty(value = "开始时间", required = true, example = "2018-10-01 00:00:00") @PastOrPresent @NotNull private Date startTime; @ApiModelProperty(value = "结束时间", required = true, example = "2018-12-01 00:00:00") @PastOrPresent @NotNull private Date endTime; public Date getStartTime() &#123; return startTime; &#125; public void setStartTime(Date startTime) &#123; this.startTime = startTime; &#125; public Date getEndTime() &#123; return endTime; &#125; public void setEndTime(Date endTime) &#123; this.endTime = endTime; &#125; // &#123;"startTime": "%s", "endTime": "%s"&#125; @Override public String toString() &#123; return String.format("&#123;\"startTime\": \"%s\", \"endTime\": \"%s\"&#125;", DateFormatUtils.format(startTime, "yyyyMMdd"), DateFormatUtils.format(endTime, "yyyyMMdd")); &#125;&#125; 是不是很简单呢，这样我们的通用验证器能为我们免去很多重复的验证逻辑，解放了生产力 😄 参考资料Spring MVC Custom Validation Spring Validation 实现前置参数校验]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于某个类不能强转为自己的类型的问题的记录]]></title>
    <url>%2Ffaa5d31d.html</url>
    <content type="text"><![CDATA[前言前段时间，同事写了一段涉及到从 memcached 里拿出来值，并强转为某一类型的逻辑，结果出现了类不能强转为自己类型的异常，很有意思，记录一下。 正文在 memcached 中，存储的是 TypeA 经过 Java 标准序列化后的内容，取值时返回的是 Object，需要强转为 TypeA。本来很简单的逻辑，但是出现异常了，异常爆出 TypeA 不能转为 TypeA，我们俩再三确认了一下，类名没有写错。 后来，我想到以前我看过的一本书上（忘了从哪本书看的了）说：Java 中，判断两个类型是否相同需要：1.两个类有相同的限定名；2.两个类由同一类加载器实例加载。既然类限定名是没有问题的，那么只能说明要强转成的 TypeA 和从 memcached 中取回的 TypeA（Java 标准反序列化生成的实例的 class）不是由同一类加载器实例加载的。后来查了一下，果不其然，同事写的那段逻辑是用 spring-devtool 启动的，而 spring-devtool 自己实现了一个类加载器，这个类加载器默认加载所有自己写的 Java 代码编译出来的 .class （也就是非 .jar 中的 .class），加载要强转为的 TypeA 就是由他加载的。而 memcached 中取回 TypeA 这块的逻辑是在 .jar 中封包的，这部分是由 AppClassLoader 加载的。这样就造成了同样是 TypeA，由不同类加载器实例（别提实例了，类加载器的类都不同）加载出来的情况，因此，他们虽然名字一样，但是已经不是一个类了，所以不能强转成功了。]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于log4j的一个坑]]></title>
    <url>%2F740ca403.html</url>
    <content type="text"><![CDATA[前言这两天改了一下生产环境的log4j的配置，结果踩了一个小坑，记录一下。 正文在生产环境的日志配置中新加了一个日志文件输出配置，如下注释处： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt;&lt;log4j:configuration&gt; &lt;appender name="CONSOLE" class="org.apache.log4j.ConsoleAppender"&gt; &lt;layout class="org.apache.log4j.PatternLayout"&gt; &lt;param name="ConversionPattern" value="[%d&#123;MM-dd HH:mm:ss,SSS\&#125; %-5p] [%t] %c&#123;2\&#125;:%L - %m%n"/&gt; &lt;/layout&gt; &lt;filter class="org.apache.log4j.varia.LevelRangeFilter"&gt; &lt;param name="levelMin" value="error"/&gt; &lt;param name="levelMax" value="off"/&gt; &lt;param name="AcceptOnMatch" value="true"/&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;appender name="DAILY_ROLLING_FILE" class="org.apache.log4j.DailyRollingFileAppender"&gt; &lt;param name="File" value="../log/main.log"/&gt; &lt;param name="DatePattern" value="'.'yyyy-MM-dd'.log'"/&gt; &lt;layout class="org.apache.log4j.PatternLayout"&gt; &lt;param name="ConversionPattern" value="[%d&#123;MM-dd HH:mm:ss SSS\&#125; %-5p] [%t] %c&#123;3\&#125;:%L - %m%n"/&gt; &lt;/layout&gt; &lt;filter class="org.apache.log4j.varia.LevelMatchFilter"&gt; &lt;param name="LevelToMatch" value="ERROR"/&gt; &lt;param name="AcceptOnMatch" value="true"/&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 新增配置开始 --&gt; &lt;appender name="ANALYSIS_DAILY_ROLLING_FILE" class="org.apache.log4j.DailyRollingFileAppender"&gt; &lt;param name="File" value="../log/analysis.log"/&gt; &lt;param name="DatePattern" value="'.'yyyy-MM-dd'.log'"/&gt; &lt;layout class="org.apache.log4j.PatternLayout"&gt; &lt;param name="ConversionPattern" value="%m%n"/&gt; &lt;/layout&gt; &lt;filter class="org.apache.log4j.varia.LevelMatchFilter"&gt; &lt;param name="LevelToMatch" value="INFO"/&gt; &lt;param name="AcceptOnMatch" value="true"/&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;appender name="ASYNC_ANALYSIS_DAILY_ROLLING_FILE" class="org.apache.log4j.AsyncAppender"&gt; &lt;appender-ref ref="ANALYSIS_DAILY_ROLLING_FILE"/&gt; &lt;/appender&gt; &lt;logger name="LOGGER_ANALYSIS"&gt; &lt;level value="INFO"/&gt; &lt;appender-ref ref="ASYNC_ANALYSIS_DAILY_ROLLING_FILE"/&gt; &lt;/logger&gt; &lt;!-- 新增配置结束 --&gt; &lt;root&gt; &lt;level value="ERROR"/&gt; &lt;appender-ref ref="DAILY_ROLLING_FILE"/&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 这个新增的配置会在原有的日志文件 main.log 外，新增一个全新的日志文件 analysis.log 记录一些信息。结果上线后，不仅日志输出到了 analysis.log，同时也输出到了 main.log 中了一份，冗余了。Google 了一下，原来是 root 和 additivity 的问题。 原来，在如下的两个 logger 中，存在着继承关系，LOGGER_ANALYSIS 是继承了 root 的 123456789&lt;logger name="LOGGER_ANALYSIS"&gt; &lt;level value="INFO"/&gt; &lt;appender-ref ref="ASYNC_ANALYSIS_DAILY_ROLLING_FILE"/&gt;&lt;/logger&gt;&lt;root&gt; &lt;level value="ERROR"/&gt; &lt;appender-ref ref="DAILY_ROLLING_FILE"/&gt;&lt;/root&gt; 继承，就意味着 LOGGER_ANALYSIS 是继承了 root 的 appender-ref 的，因此，LOGGER_ANALYSIS 不知输出到了自己的 appender 设置的文件 analysis.log 里，也会输出到 DAILY_ROLLING_FILE 对应的 main.log 里，也就是冗余了。 那么，怎么解决呢？很简单，让儿子不继承爸爸就好了，不做富二代，白手起家，自己打天下。 1234&lt;logger name="LOGGER_ANALYSIS" additivity="false"&gt; &lt;level value="INFO"/&gt; &lt;appender-ref ref="ASYNC_ANALYSIS_DAILY_ROLLING_FILE"/&gt;&lt;/logger&gt; 注意上边的 additivity=&quot;false&quot; 就这个设置，就声明和 root 脱离父子关系了，独立了。问题解决。 参考资料关于log4j root logger 标签 以及additivity 属性 Appenders and Layouts]]></content>
      <tags>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring实现根据controller中接收请求参数不同走不同service]]></title>
    <url>%2Fa9b7a8df.html</url>
    <content type="text"><![CDATA[前言前几天一个工程中，需要实现这样一个场景：根据前端发送过来的请求参数的不同，走不同的 service（可同事走多个），最初我的思路是尝试实现在 spring 中实现动态的依赖注入，也就是根据请求参数，动态的在 controller 中注入某个 service 接口的特定实现（接口有多个实现），但是发现这个实现不了，然后想了想，换了个思路，重新设计了一下，实现了需求中的场景。 正文我的解决办法是，使用“生产线工人工作能力自己掂量机制”来解决，这名字我自己起的，实际上就是想要实现按参数选择走哪个 service 实现，可以一次性把所有 service 实现全都注入进来，然后依次请求，同时在每个 service 实现中写一套规则判别方法，判断当前请求自己是不是能够处理，如果能够处理，则进入处理方法，若自己没有处理能力，则退出，让请求走到其他 service 做同样的判断。形象点，可以想象一下，在一条生产线的传送带上传送着不同品类的待加工的元部件，有若干工人排列在传送带旁边，每个工人只会加工某一种元件，那么，当传送带上的元件传送到自己面前时，需要判断一下，自己有没有处理这个元件的能力（掂量一下自己的能力），若有，取过来处理，若没有，放过去让别人走流程。 理解了其中逻辑，我们就来看代码吧（片段）： 123456789public interface ServiceProvider &#123; // 掂量一下自己有没有能力加工当前的元件（也就是Request），能就返回 true 不能返回 false boolean support(Request request); // 具体加工元件的逻辑 Response execute(Request request);&#125; 1234567891011121314151617@Servicepublic class ServiceImpl implements Service &#123; // 注入一系列 service 数量不定 https://stackoverflow.com/questions/2153298/how-to-autowire-factorybean @Resource(name = "serviceProviders") private List&lt;ServiceProvider&gt; serviceProviders; @Override public List&lt;Response&gt; execute(Request request) &#123; return serviceProviders // 循环每个 service TODO 现在时间复杂度为 O(n) 可以尝试优化为 O(logn) .stream() .filter(serviceProvider -&gt; serviceProvider.support(request)) // 按加工能力过滤 .map(serviceProvider -&gt; serviceProvider.execute(request)) // 执行 service 得 execute 方法 .collect(Collectors.toList()); &#125;&#125; 这里有一点需要解释一下，在上面第二段代码中，有这么一段： 12@Resource(name = &quot;serviceProviders&quot;)private List&lt;ServiceProvider&gt; serviceProviders; 这里是使用 spring 中的 FactoryBean 机制实现的，可以简单的这样理解 FactoryBean ：FactoryBean 是生成普通 Bean 的 Bean，当注入 FactoryBean 时，默认注入的是其生产出来的所有普通 Bean，而不是它自己。 在上边代码中，注入的名为 serviceProviders 的这个 Bean，实际上是这样定义出来的： 1234567891011121314151617181920212223242526@Component("serviceProviders") // 注意这个 Bean 的名字，当其他 Bean 中注入这个 Bean 时，会注入 createInstance() 返回类型的 Bean，而不是其自身的类型 ServiceProviderFactoryBeanpublic class ServiceProviderFactoryBean extends AbstractFactoryBean&lt;List&lt;ServiceProvider&gt;&gt; implements ApplicationContextAware &#123; private ApplicationContext applicationContext; @Override public Class&lt;?&gt; getObjectType() &#123; return List.class; &#125; @Override protected List&lt;ServiceProvider&gt; createInstance() &#123; // 扫描所有 provider 并从 Bean 容器取出放入 list Reflections reflections = new Reflections(ServiceProvider.class.getPackage().getName()); return reflections .getSubTypesOf(ServiceProvider.class) .stream() .map((Function&lt;Class&lt;? extends ServiceProvider&gt;, ServiceProvider&gt;) serviceProviderClass -&gt; applicationContext.getBean(serviceProviderClass)) .collect(Collectors.toList()); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125;&#125; 通过这样的设计，就完成了我们的需求，实际上我们等于把思路反转了一下，从想尽办法控制注入到不做控制，一股脑全部注入进去，然后按规则过滤。有时候，其实遇到一条思路走不通的时候，可以反过来想想，也许就会走通。 勘误「后端圈」小伙伴指出，我这个注入一系列 Beans 的机制写复杂了，实际上在 Spring 中，注入 List&lt;SomeBean&gt; somebeans 就能自动实现将所有 SomeBean 全部注入进来了。压根不需要自己写 FactoryBean 的，这个机制的实现过程，可以参考 Spring 源码：org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveMultipleBeans 和 org.springframework.beans.factory.support.DefaultListableBeanFactory#addCandidateEntry 123456789101112131415// 单个Bean的类型为org.springframework.beans.factory.config.DependencyDescriptor，而List&lt;Bean&gt;的类型为org.springframework.beans.factory.support.DefaultListableBeanFactory.MultiElementDescriptor，从这里分成了两个流程/** * Add an entry to the candidate map: a bean instance if available or just the resolved * type, preventing early bean initialization ahead of primary candidate selection. */private void addCandidateEntry(Map&lt;String, Object&gt; candidates, String candidateName, DependencyDescriptor descriptor, Class&lt;?&gt; requiredType) &#123; if (descriptor instanceof MultiElementDescriptor || containsSingleton(candidateName)) &#123; Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, this); candidates.put(candidateName, (beanInstance instanceof NullBean ? null : beanInstance)); &#125; else &#123; candidates.put(candidateName, getType(candidateName)); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Nullableprivate Object resolveMultipleBeans(DependencyDescriptor descriptor, @Nullable String beanName, @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) &#123; Class&lt;?&gt; type = descriptor.getDependencyType(); if (type.isArray()) &#123; Class&lt;?&gt; componentType = type.getComponentType(); ResolvableType resolvableType = descriptor.getResolvableType(); Class&lt;?&gt; resolvedArrayType = resolvableType.resolve(); if (resolvedArrayType != null &amp;&amp; resolvedArrayType != type) &#123; type = resolvedArrayType; componentType = resolvableType.getComponentType().resolve(); &#125; if (componentType == null) &#123; return null; &#125; Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, componentType, new MultiElementDescriptor(descriptor)); // 注意这里，这里 new 了一个 MultiElementDescriptor ，和上边那段代码的分支对应上了 if (matchingBeans.isEmpty()) &#123; return null; &#125; if (autowiredBeanNames != null) &#123; autowiredBeanNames.addAll(matchingBeans.keySet()); &#125; TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter()); Object result = converter.convertIfNecessary(matchingBeans.values(), type); if (getDependencyComparator() != null &amp;&amp; result instanceof Object[]) &#123; Arrays.sort((Object[]) result, adaptDependencyComparator(matchingBeans)); &#125; return result; &#125; else if (Collection.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) &#123; Class&lt;?&gt; elementType = descriptor.getResolvableType().asCollection().resolveGeneric(); if (elementType == null) &#123; return null; &#125; Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, elementType, new MultiElementDescriptor(descriptor)); if (matchingBeans.isEmpty()) &#123; return null; &#125; if (autowiredBeanNames != null) &#123; autowiredBeanNames.addAll(matchingBeans.keySet()); &#125; TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter()); Object result = converter.convertIfNecessary(matchingBeans.values(), type); if (getDependencyComparator() != null &amp;&amp; result instanceof List) &#123; ((List&lt;?&gt;) result).sort(adaptDependencyComparator(matchingBeans)); &#125; return result; &#125; else if (Map.class == type) &#123; ResolvableType mapType = descriptor.getResolvableType().asMap(); Class&lt;?&gt; keyType = mapType.resolveGeneric(0); if (String.class != keyType) &#123; return null; &#125; Class&lt;?&gt; valueType = mapType.resolveGeneric(1); if (valueType == null) &#123; return null; &#125; Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, valueType, new MultiElementDescriptor(descriptor)); if (matchingBeans.isEmpty()) &#123; return null; &#125; if (autowiredBeanNames != null) &#123; autowiredBeanNames.addAll(matchingBeans.keySet()); &#125; return matchingBeans; &#125; else &#123; return null; &#125;&#125;]]></content>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用HSDB查看javassist生成的动态class]]></title>
    <url>%2Fa7709277.html</url>
    <content type="text"><![CDATA[前言今天需要分析一个工程中的几个动态代理类，但是，这几个动态代理类是由javassist生成的，在target中是不存在其文件的，因此无法直接查看。然后搜索了一番，找到了使用HSDB(HotSpot Debugger)这个工具来查看的办法。 正文直接上操做步骤吧，这个HSDB本就是一个实用工具，实践一下就会用了。 第一步. 运行起自己的应用。 第二步. jps -l 找到自己应用的PID 第三步. sudo java -classpath &quot;$JAVA_HOME/lib/sa-jdi.jar&quot; sun.jvm.hotspot.HSDB启动HSDB 第四步. File -&gt; Attach to HotSpot Process... Attach上自己应用的PID 第五步. Tools -&gt; Class Browser 第六步. 按照要查找的动态代理类的类名作为关键字搜索（模糊搜索） 第七步. 在搜到的类结果面板中点Create .class File，此时会在刚才我们执行打开HSDB命令的目录中生成对应的.class文件 第八步. 用idea查看生成对应的.class文件即可 参考资料javassist Tutorial 1 从java进程里dump出类的class文件的小工具–dumpclass 从JVM中dump出动态代理生成的class 通过HSDB来了解String值的真身在哪里 借HSDB来探索HotSpot VM的运行时数据 如何dump出一个Java进程里的类对应的Class文件？ Dump classes from running JVM process. 保存java 动态代理生成的字节码文件]]></content>
      <tags>
        <tag>JDK</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于String Pool的学习笔记]]></title>
    <url>%2F6c7c33f2.html</url>
    <content type="text"><![CDATA[前言前几天在「后端圈」群里，有位同学问了一个关于 java.lang.String#intern() 的问题： String s11 = new String(“11”); s11.intern(); String s12 = “11”; System.out.println(s11 == s12); 请教下，应该输出true还是false？ 在研究这个问题时，无意中，从问题中牵扯出来了对于一个概念的理解。 正文大家看问题中的 String s12 = &quot;11&quot;; 这一段代码，这是一个很简单的字面量声明，经过「后端圈」群里兰大的指导，同时加上我自己的验证，我了解到，这个字符串字面量的声明会在编以后存储到 class 文件中的 class文件常量池 中。关于这一点可以用 javap -v 来印证： 那么，就应该说明 String s12 = &quot;11&quot;; 这里的11这个字面量，会在运行时常量池生成时，被塞到其中。但是后来我看了一下 java.lang.String#intern() 的注释，里面有这样一段描述： 123...A pool of strings, initially empty, is maintained privately by the class &#123;@code String&#125;.... 看完这个，我就产生了一个疑问，java.lang.String#intern() 背后的这个 “Pool” 和 运行时常量池 是一回事吗？带着疑问，我又搜索了几篇文章，没找到答案。后来，在「JVM参数交流群」里提问得到了回复，根据笨神以及群里小伙伴‘蛋炒饭’、‘半拍’的回答，得出了结论，String Pool 和 运行时常量池，不是一回事。同时我还搜到了占小狼大大的一篇文章 「深入分析String.intern和String常量的实现原理」 在这篇文章的最后，阐述了 String Pool 和 运行时常量池的关系： 字符串常量一开始以Symbol类型表示，最终通过StringTable::intern方法生成字符串对象，并把字符串的真实引用更新到constantPool中，这样下次执行ldc指令时可以直接返回对象引用 通过这段描述，我简单的理解了一下字符串字面量在 堆、String Pool 和 Constant Pool 中存放的形式：可以理解为一个有两级缓存的结构。真实的字面量是放在堆中的，而 String Pool 可看作是一个全局一级缓存，里面缓存着堆上对应的真实字符串的引用，然后 Constant Pool 看作是各个 class 对应的二级缓存，里面存放着指向刚才 String Pool 里对应缓存内容的引用，也就是: Java中的字符串 -&gt; Constant Pool 中缓存引用 -&gt; String Pool 中缓存的引用 -&gt; 堆中实际的字符串 这样一种结构。 当然，其实这里边还有很多细节我还没有理解，估计是需要看源码才能解得了，不过通过这次群里讨论了解到了一些概念层面的东西也不错，把原来模糊的概念了解的清晰起来了。 参考资料Java / JVM Internals JVM字符串常量池同运行时常量池关系理解 Java中的常量池(字符串常量池、class常量池和运行时常量池) 字符串常量池、运行时常量池 深入分析String.intern和String常量的实现原理 如何理解《深入理解java虚拟机》第二版中对String.intern()方法的讲解中所举的例子？ Java 中new String(“字面量”) 中 “字面量” 是何时进入字符串常量池的?]]></content>
      <tags>
        <tag>Java基础</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曲线救国，解决spring-boot2.0.6中webflux无法获得请求IP的问题]]></title>
    <url>%2F5f5b006f.html</url>
    <content type="text"><![CDATA[前言这几天在用 spring-boot 2 的 webflux 重构一个工程，写到了一个需要获得客户端请求 IP 的地方，发现写不下去了，在如下的 Handler（webflux 中 Handler 相当于 mvc 中的 Controller）中 123456789101112131415161718192021222324252627282930313233343536373839import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.stereotype.Component;import org.springframework.web.reactive.function.server.RouterFunction;import org.springframework.web.reactive.function.server.ServerRequest;import org.springframework.web.reactive.function.server.ServerResponse;import reactor.core.publisher.Mono;import static org.springframework.web.reactive.function.server.RequestPredicates.GET;import static org.springframework.web.reactive.function.server.RequestPredicates.accept;import static org.springframework.web.reactive.function.server.RouterFunctions.route;/** * 某业务 Handler */@Componentpublic class SplashHandler &#123; private Mono&lt;ServerResponse&gt; execute(ServerRequest serverRequest) &#123; ... 业务代码 // serverRequest 获得 IP ？ ... 业务代码 &#125; @Configuration public static class RoutingConfiguration &#123; @Bean public RouterFunction&lt;ServerResponse&gt; execute(SplashHandler handler) &#123; return route( GET("/api/ad").and(accept(MediaType.TEXT_HTML)), handler::execute ); &#125; &#125;&#125; 我发现 org.springframework.web.reactive.function.server.ServerRequest 根本没有暴露用于获得客户端 IP 的 API，想想这在传统 MVC 中是相当基本的需求啊，竟然获取不到，然后 Google 了一下，发现这个是 spring-webflux 的一个 BUG，这个 BUG 在 spring-webflux 5.1 中解决了，但是，略有些尴尬的是当前最新稳定版的 spring-boot 还是依赖 5.0.x 的 spring-webflux 的。难道要等官方升级么，那不知道得等到什么时候，因此我接着搜了搜资料，看了看文档和源码，自己想了个曲线救国的办法。 正文在 spring-webflux 中，有一个 org.springframework.web.server.WebFilter 接口，类似于 Servlet API 中的过滤器，这个 API 提供了一个方法会将一个限定名为 org.springframework.web.server.ServerWebExchange 的类暴露出来，而在这个类中就包含了对于请求端 IP 的获取方法： 12org.springframework.web.server.ServerWebExchange#getRequestorg.springframework.http.server.reactive.ServerHttpRequest#getRemoteAddress 因此，我们大可以实现一个 WebFilter 在里面通过暴露的 ServerWebExchange 拿到客户端 IP，然后再将其塞到请求的 header 中，这样，后续过程就可以从 header 中取 IP 了。思路有了，我们开始实现吧。 过滤、取 IP、放 header，一气呵成： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import org.springframework.context.annotation.Configuration;import org.springframework.http.server.reactive.ServerHttpRequest;import org.springframework.stereotype.Component;import org.springframework.web.reactive.config.CorsRegistry;import org.springframework.web.reactive.config.WebFluxConfigurer;import org.springframework.web.server.ServerWebExchange;import org.springframework.web.server.WebFilter;import org.springframework.web.server.WebFilterChain;import reactor.core.publisher.Mono;import java.net.InetSocketAddress;import java.util.Objects;/*If you want to keep Spring Boot WebFlux features and you want to add additional WebFlux configuration, you can add your own @Configuration class of type WebFluxConfigurer but without @EnableWebFlux.If you want to take complete control of Spring WebFlux, you can add your own @Configuration annotated with @EnableWebFlux. */@Configurationpublic class WebConfiguration implements WebFluxConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry .addMapping("/**") .allowedOrigins("*") .allowedMethods("GET", "POST", "PUT", "PATCH", "DELETE", "OPTION") .allowedHeaders("header1", "header2", "header3") .exposedHeaders("header1", "header2") .allowCredentials(true) .maxAge(3600); &#125; /** * https://stackoverflow.com/questions/51192630/how-do-you-get-clients-ip-address-spring-webflux-websocket?rq=1 * https://stackoverflow.com/questions/50981136/how-to-get-client-ip-in-webflux * https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-filters * 由于在低版本的 spring-webflux 中不支持直接获得请求 IP（https://jira.spring.io/browse/SPR-16681），因此写了一个补丁曲线救国， * 从 org.springframework.web.server.ServerWebExchange 中获得 IP 后，在放到 header 里 */ @Component public static class RetrieveClientIpWebFilter implements WebFilter &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) &#123; InetSocketAddress remoteAddress = exchange.getRequest().getRemoteAddress(); String clientIp = Objects.requireNonNull(remoteAddress).getAddress().getHostAddress(); ServerHttpRequest mutatedServerHttpRequest = exchange.getRequest().mutate().header("X-CLIENT-IP", clientIp).build(); ServerWebExchange mutatedServerWebExchange = exchange.mutate().request(mutatedServerHttpRequest).build(); return chain.filter(mutatedServerWebExchange); &#125; &#125;&#125; 后续过程 header 取值： 1234private Mono&lt;ServerResponse&gt; execute(ServerRequest serverRequest) &#123; String clientIp = serverRequest.headers().asHttpHeaders().getFirst("X-CLIENT-IP") ... 业务代码&#125; 通过上述解决方案（其实严格上说是 hacking）就解决了我们遇到的问题了。 参考资料How do you get Client’s IP address? (Spring WebFlux WebSocket) How to get client IP in webflux? spring-webflux 官方文档第 1.2.3. 小节 ‘Filters’ Spring FrameworkSPR-16681 (jira)]]></content>
      <tags>
        <tag>源码</tag>
        <tag>spring-boot</tag>
        <tag>踩坑</tag>
        <tag>spring-webflux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK 命令行工具用法汇总]]></title>
    <url>%2Fc3ae467f.html</url>
    <content type="text"><![CDATA[前言JDK 中内置了很多实用的小工具，可以帮助我们管理、分析、调优、监控本地的货远程的 JVM，在此统一记录一下它们的用法。 正文查看某 Java 进程的进程号，启用的参数等 1jps -lvm | grep &lt;Java process name&gt; 查看或修改某 Java 进程启用的参数 查看 1jinfo &lt;Java processs id&gt; 修改 1jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;Java processs id&gt; 参考资料jinfo命令详解]]></content>
      <tags>
        <tag>JDK</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 JMC 无法连接远程 JVM 的问题]]></title>
    <url>%2Ff45b7165.html</url>
    <content type="text"><![CDATA[正文这几天线上出现了一些 JVM 相关的问题，打算用 JMC(Java Mission Control) 连接远程 JVM 来分析一下，远程 JVM 配置好了参数如下 1...其他参数... -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.port=26671 -XX:+UnlockCommercialFeatures -XX:+FlightRecorder ...其他参数... 本以为用本地的 JMC 连接就好了，结果连接时爆出 ...jmc Could not connect to... 异常，试了下 telnet ip 端口 正常连同，那么应当不是物理网络连通性的问题，后来 Google 了一下，发现，如果是要连接远程 JVM 是要在远程 JVM 上明确指定 JMX 绑定的 host 的，加上了如下参数 1-Djava.rmi.server.hostname=&lt;远程JVM主机IP&gt; 就可以正常连通了。 参考资料Cannot connect to a local JVM with JMC - unexpected IP in error message]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 ERR_UNSAFE_PORT]]></title>
    <url>%2Ffd1802d8.html</url>
    <content type="text"><![CDATA[今天在公司的服务器上部署了一个接口管理平台，使用的6666、6667、6668这几个端口，服务用curl在服务器本地可以正常连接，但是用自己的机子连接，浏览器却提示ERR_UNSAFE_PORT，这个错误的页面长的很像ERR_CONNECTION_REFUSED这种页面，但是仔细一看并不是。ERR_UNSAFE_PORT这种错误并不代表这个端口因为服务异常访问不了，而是因为浏览器认为这几个端口是用与一些现有的tcp协议的保留端口，是不应该通过浏览器访问的，出于安全原因阻止了我们的访问。解决这个错误的方法也很简单，避开这些端口就好了，比如我选用了60000以上的3个端口，就可以了。]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 AspectJ 实现静态 AOP]]></title>
    <url>%2F4953a864.html</url>
    <content type="text"><![CDATA[前言前段时间在为公司的工程加入 AOP 支持时，选用了 AspectJ 的编译期织入静态 AOP 的实现方案，在此总结一下吧。 正文说到 AOP 想必大家受 spring 熏陶多年，都会有所了解。在 spring 中，我们一般会选用其基于代理的动态 AOP 方案，但是，在一些比较特殊的工程中，使用动态 AOP 并不合适，比如一些使用了基于代理机制的 RPC 框架的工程，因此就需要一种纯粹静态的 AOP 决方案。而 AspectJ 就提供了基于编译期织入的纯静态 AOP 方案。 那么，该如何使用呢（我们这里讲的是脱离 spring 的使用方式）。我们通过小例子来展示一下。在这个小例子中，我们来做一个基于注解的方法运行计时器，最终的效果应该如下： 1234567@StopWatchpublic class Scratch &#123; public void test() &#123; // do something... &#125;&#125; 12345当前线程 [main] 计时开始执行 当前线程 [main] 当前方法 [execution(public com.xx.Scratch com.xx.Scratch.test())]当前线程 [main] 计时结束，共耗时 [1986 MILLISECONDS] 也就是在类级别加上注解@StopWatch就能够统计出来此类所有public方法的运行时间。 实现我们来看代码吧，一码胜千言： 123456789101112import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.util.concurrent.TimeUnit;@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface StopWatch &#123; TimeUnit timeUnit() default TimeUnit.MILLISECONDS;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142import com.google.common.base.Stopwatch;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.slf4j.Logger;import org.slf4j.LoggerFactory;// https://stackoverflow.com/questions/17481183/aspectj-class-level-annotation-advice-with-annotation-as-method-argument@Aspectpublic class StopWatchAspect &#123; private static final Logger LOGGER = LoggerFactory.getLogger(StopWatchAspect.class); private static Stopwatch _stopwatch; @Pointcut("execution(public * *(..))") public void publicMethod() &#123; &#125; @Pointcut(value = "@within(stopWatch)", argNames = "stopWatch") public void annotatedWithStopWatch(StopWatch stopWatch) &#123; &#125; @Pointcut(value = "publicMethod() &amp;&amp; annotatedWithStopWatch(stopWatch)", argNames = "stopWatch") public void publicMethodAnnotatedWithStopWatch(StopWatch stopWatch) &#123; &#125; @Before(value = "publicMethodAnnotatedWithStopWatch(stopWatch)", argNames = "stopWatch") public void before(StopWatch stopWatch) &#123; _stopwatch = Stopwatch.createStarted(); LOGGER.info(String.format("当前线程 [%s] 计时开始", Thread.currentThread().getName())); &#125; @Around(value = "publicMethodAnnotatedWithStopWatch(stopWatch)", argNames = "proceedingJoinPoint,stopWatch") public Object around(ProceedingJoinPoint proceedingJoinPoint, StopWatch stopWatch) throws Throwable &#123; LOGGER.info(String.format("执行 当前线程 [%s] 当前方法 [%s]", Thread.currentThread().getName(), proceedingJoinPoint.toLongString())); return proceedingJoinPoint.proceed(); &#125; @After(value = "publicMethodAnnotatedWithStopWatch(stopWatch)", argNames = "stopWatch") public void after(StopWatch stopWatch) &#123; LOGGER.info(String.format("当前线程 [%s] 计时结束，共耗时 [%d %s] ", Thread.currentThread().getName(), _stopwatch.elapsed(stopWatch.timeUnit()), stopWatch.timeUnit().name())); &#125;&#125; 上边两段代码分别展示了我们的定时器注解和用于处理定时器逻辑的切面，因为我们要实现基于注解的计时，必然会需要自己定义一个注解，这个不用赘述，主要的，我们来看切面代码，这个是实现定时器逻辑的关键。 先来看类定义： 12@Aspectpublic class StopWatchAspect &#123; 要想将一个普通的类声明为切面，就需要加上一个 AspectJ 自己的注解@Aspect，加上这个注解后，AspectJ 就会识别出来这个类，从而来走后续的流程。 再来看切入点定义 1234567891011@Pointcut(&quot;execution(public * *(..))&quot;) // 在所有 public 方法中切入public void publicMethod() &#123;&#125;@Pointcut(value = &quot;@within(stopWatch)&quot;, argNames = &quot;stopWatch&quot;) // 在标注有 @StopWatch 的类中的所有方法中切入public void annotatedWithStopWatch(StopWatch stopWatch) &#123;&#125;@Pointcut(value = &quot;publicMethod() &amp;&amp; annotatedWithStopWatch(stopWatch)&quot;, argNames = &quot;stopWatch&quot;) // 在同时满足 public 以及所在类标注有 @StopWatch 这两个条件的方法切入public void publicMethodAnnotatedWithStopWatch(StopWatch stopWatch) &#123;&#125; 在 AspectJ 中使用特殊的表达式来定义切入点，具体的表达式语法请参照官方的文档，在此不再复述。 然后看通知定义 12345678910111213141516@Before(value = &quot;publicMethodAnnotatedWithStopWatch(stopWatch)&quot;, argNames = &quot;stopWatch&quot;)public void before(StopWatch stopWatch) &#123; _stopwatch = Stopwatch.createStarted(); LOGGER.info(String.format(&quot;当前线程 [%s] 计时开始&quot;, Thread.currentThread().getName()));&#125;@Around(value = &quot;publicMethodAnnotatedWithStopWatch(stopWatch)&quot;, argNames = &quot;proceedingJoinPoint,stopWatch&quot;)public Object around(ProceedingJoinPoint proceedingJoinPoint, StopWatch stopWatch) throws Throwable &#123; LOGGER.info(String.format(&quot;执行 当前线程 [%s] 当前方法 [%s]&quot;, Thread.currentThread().getName(), proceedingJoinPoint.toLongString())); return proceedingJoinPoint.proceed();&#125;@After(value = &quot;publicMethodAnnotatedWithStopWatch(stopWatch)&quot;, argNames = &quot;stopWatch&quot;)public void after(StopWatch stopWatch) &#123; LOGGER.info(String.format(&quot;当前线程 [%s] 计时结束，共耗时 [%d %s] &quot;, Thread.currentThread().getName(), _stopwatch.elapsed(stopWatch.timeUnit()), stopWatch.timeUnit().name()));&#125; 关于 AspectJ 通知的类型请参看官方文档，在此例中，我们用到了@Before、@Around和@After这三种，分别在其中开启计时器、输出运行方法签名信息和结束计时。 这样基本的切面逻辑我们就写好了，但是，只有这些切面逻辑是不能在运行时实现真正的我们想要实现的 AOP 逻辑的，还需要织入的过程（我们选用编译期织入，所以是在编译时完成织入的）。 我们来看织入的配置 12345678910&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;$&#123;version.aspectjrt&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;$&#123;version.aspectjweaver&#125;&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;version.aspectj-maven-plugin&#125;&lt;/version&gt; &lt;configuration&gt; &lt;complianceLevel&gt;$&#123;maven.compiler.target&#125;&lt;/complianceLevel&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;goal&gt;test-compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 配置编译期织入需要我们配置好 AspectJ 的依赖以及 maven 插件，有了这些之后，在编译时，AspectJ 会自动为我们生成如下这样的 .class（以下为反编译生成的代码）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//import com.google.common.base.Stopwatch;import org.aspectj.lang.NoAspectBoundException;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.slf4j.Logger;import org.slf4j.LoggerFactory;@Aspectpublic class StopWatchAspect &#123; private static final Logger LOGGER = LoggerFactory.getLogger(StopWatchAspect.class); private static Stopwatch _stopwatch; static &#123; try &#123; ajc$postClinit(); &#125; catch (Throwable var1) &#123; ajc$initFailureCause = var1; &#125; &#125; public StopWatchAspect() &#123; &#125; @Before( value = &quot;publicMethodAnnotatedWithStopWatch(stopWatch)&quot;, argNames = &quot;stopWatch&quot; ) public void before(StopWatch stopWatch) &#123; _stopwatch = Stopwatch.createStarted(); LOGGER.info(String.format(&quot;当前线程 [%s] 计时开始&quot;, Thread.currentThread().getName())); &#125; @Around( value = &quot;publicMethodAnnotatedWithStopWatch(stopWatch)&quot;, argNames = &quot;proceedingJoinPoint,stopWatch&quot; ) public Object around(ProceedingJoinPoint proceedingJoinPoint, StopWatch stopWatch) throws Throwable &#123; ajc$inlineAccessFieldGet$com_bj58_jxedt_pay_unity_core_stopwatch_StopWatchAspect$com_bj58_jxedt_pay_unity_core_stopwatch_StopWatchAspect$LOGGER().info(String.format(&quot;执行 当前线程 [%s] 当前方法 [%s]&quot;, Thread.currentThread().getName(), proceedingJoinPoint.toLongString())); return proceedingJoinPoint.proceed(); &#125; @After( value = &quot;publicMethodAnnotatedWithStopWatch(stopWatch)&quot;, argNames = &quot;stopWatch&quot; ) public void after(StopWatch stopWatch) &#123; LOGGER.info(String.format(&quot;当前线程 [%s] 计时结束，共耗时 [%d %s] &quot;, Thread.currentThread().getName(), _stopwatch.elapsed(stopWatch.timeUnit()), stopWatch.timeUnit().name())); &#125; public static StopWatchAspect aspectOf() &#123; if (ajc$perSingletonInstance == null) &#123; throw new NoAspectBoundException(&quot;com.bj58.jxedt.pay.unity.core.stopwatch.StopWatchAspect&quot;, ajc$initFailureCause); &#125; else &#123; return ajc$perSingletonInstance; &#125; &#125; public static boolean hasAspect() &#123; return ajc$perSingletonInstance != null; &#125;&#125; 对比前面我们写的切面代码，这个生成的 .class 多了一些生成出来的内容，这些内容是 AspectJ 为我们生成的，生成了这些之后，就实现了我们真正的 AOP 逻辑了。 到此为止，我们就完成了 AspectJ 编译期织入 AOP 的代码编写了，就可以愉快的使用了。在这里补充一点，在一些需要排除掉兼容性困扰的场景中推荐选择编译期织入，而不是其他织入方式，因为编译期织入在编译时就完成了 AOP 逻辑，如果有不兼容的情况，早在编译期就能发现，这样就确保了在加载期和运行期是兼容的稳定的。 参考资料Intro to AspectJ]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结一下自己在实践与思考中形成的编码规范]]></title>
    <url>%2F6e0cf8e6.html</url>
    <content type="text"><![CDATA[前言这段时间，公司领导让我做了一些整理工程规范相关的事，趁此机会，我也把以前在规范方面的实践和思考在这里做个整理，阶段性的总结一下，以后还需要不断更新。 正文1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 原则 * &lt;ul&gt; * &lt;li&gt;一致（一致的缩进量、一致的空行位置、一致的命名，等）&lt;/li&gt; * &lt;li&gt;直觉（不违背直觉，所见即所想也即所得）&lt;/li&gt; * &lt;li&gt;语义（有意义的命名、不做牺牲或违背语义的优化，写给人看的代码）&lt;/li&gt; * &lt;/ul&gt; * &lt;p&gt; * 工程结构 * &lt;ul&gt; * &lt;li&gt;包顶层路径按业务模块切分&lt;/li&gt; * &lt;li&gt;使用严格的分层模型，请务必遵守，所有代码只出现在它应该出现的地方&lt;/li&gt; * &lt;/ul&gt; * &lt;p&gt; * 代码编写 * &lt;ul&gt; * &lt;li&gt;代码的语义优先，不要为了优化性能等借口放弃代码的语义&lt;/li&gt; * * &lt;li&gt;禁止使用缩写命名，缩写命名自己都看不懂，更别提给别人看了，使用有意义的英语命名，不要怕名字长，实在喜欢短命名，可以考虑代码混淆器，混淆出来的代码连包都很短&lt;/li&gt; * &lt;li&gt;禁止在命名中使用错字（以 IDE 没有波浪线提示为准）&lt;/li&gt; * &lt;li&gt;变量名使用小驼峰命名，类名使用大驼峰命名&lt;/li&gt; * &lt;li&gt;所有常量定义在 Constants 中，禁止多处定义常量，（但可多处定义枚举）常量类为 final 类（也就是禁止继承）&lt;/li&gt; * &lt;li&gt;常量（static final）禁止使用小写命名，使用大写 + 下划线方式命名&lt;/li&gt; * &lt;li&gt;接口禁止使用 I 开头，实现使用 Impl 后缀，接口与实现写在同一包下，不要为实现在建一个层级的包&lt;/li&gt; * &lt;li&gt;禁用大写方法名&lt;/li&gt; * * &lt;li&gt;写完后请随手格式化（请统一使用 IDE 默认格式化规则）&lt;/li&gt; * &lt;li&gt;IDE 报黄色警告的地方，看一下是什么原因，尽力消除有警告的代码，这样随手就是优化&lt;/li&gt; * &lt;li&gt;方法和方法变量和变量之间保持一致数量的空行，方法体内第一行不能为空行（匿名内部类方法除外），类的开始大括号下留一行空行，结束大括号上边不能是空行&lt;/li&gt; * * &lt;li&gt;禁止在方法中保留注释的代码（请将其剪切保存到别出）&lt;/li&gt; * &lt;li&gt;禁止保留 IDE 生成的 TODO标签，等自动生成项&lt;/li&gt; * &lt;li&gt;禁止写不必要的注释（不要重复自己），方法、变量看名字就能知道什么语义，就无需注释了，所以命名遵守语义化很重要&lt;/li&gt; * &lt;li&gt;注释中的 param 和 return 如果感觉不需要写，直接去掉！不要保留空的 param 和 return&lt;/li&gt; * * &lt;li&gt;若类或方法上需要加多个注解，那么在所有需要加多个注解的地方，按照同样顺序排列这些注解，并且按照注解的等级从下向上排列（通用的在下边，特属的在上边）&lt;/li&gt; * * &lt;li&gt;不建议深度优先的包路径，请使用广度优先的包路径，并用前缀或后缀区分包下的类&lt;/li&gt; * &lt;li&gt;禁止保留无用的 import&lt;/li&gt; * * &lt;li&gt;所有异常不要 catch 直接 throw 到上层，在到达前端之前统一使用 AOP 方式处理&lt;/li&gt; * * &lt;li&gt;maven 中依赖项请安组排列&lt;/li&gt; * &lt;li&gt;maven 中禁止引入不需要的依赖和插件&lt;/li&gt; * &lt;li&gt;maven 中明确指定 Java 版本&lt;/li&gt; * &lt;/ul&gt; */]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS 中快速在多个不同 Jdk 版本间切换]]></title>
    <url>%2F6077f21b.html</url>
    <content type="text"><![CDATA[背景一般，我们的机器上会同时安装多个版本的 Jdk ，默认的，macOS 会选择最高版本 Jdk 作为默认 Jdk，这样带来一些问题，比如说，有些中间件不支持最新的 Jdk 如 Jdk10，我们需要切换到低版本去，怎样最灵活的实现在不同版本 Jdk 之间快速切换呢，可以使用 shell 来搞定。 实战在当前 shell 对应的配置文件中（我用的 zsh，配置文件为 ~/.zshrc）加入如下代码： 1234# Switch Java version 有多少个版本的 Jdk 就写多少个alias java10=&quot;export JAVA_HOME=`/usr/libexec/java_home -v 10`; java -version&quot;alias java8=&quot;export JAVA_HOME=`/usr/libexec/java_home -v 1.8`; java -version&quot;alias java7=&quot;export JAVA_HOME=`/usr/libexec/java_home -v 1.7`; java -version&quot; 然后source ~/.zshrc使其生效（source shell 对应的配置文件） 这样在想要运行特定版本的 Jdk 才能支持的中间件时，比如必须 Jdk8，就使用java8这个命令切换到 Jdk8 环境后，再运行相关程序就好了，当然，退出 shell 后会恢复到系统默认配置，现用现运行就好了。 参考资料Switching Java versions on Mac OS How to set or change the default Java (JDK) version on OS X?]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让 MyBatis Generator 用数据库注释作 Java 注释，并支持附加注解]]></title>
    <url>%2Fbbefb134.html</url>
    <content type="text"><![CDATA[背景这两天详细了解了 MyBatis Generator 这款工具，它生成 POJO 以及 Mapper 的功能还是比较实用的，而且由于生成的代码也是工程代码的一部分，自定义起来相对库来说也会方便一些，因此我打算将其用于公司的工程中。但是，MyBatis Generator 也是有一些不足的，其默认生成的 Java 注释实在惨不忍睹，包含了大量重复的无效信息；此外，我想实现在数据库中写一次注释，在 Java 代码中复用这种效果，同时还需要在生成 Java POJO 的过程中附加上公司自研 RPC 框架的注解。这两点功能 MyBatis Generator 默认提供的注释生成器是不能很好的支持的。因此需要自定义一个注释生成器来实现这些特定的需求。 实现想要自己定义注释生成器，先要找到 MyBatis Generator 提供的注释生成器接口。这个接口是 org.mybatis.generator.api.CommentGenerator 其默认实现为 org.mybatis.generator.internal.DefaultCommentGenerator （默认实现也是唯一实现），其实我翻了一翻 DefaultCommentGenerator 的代码，发现其默认是支持将数据库注释作为生成的 Java 类的注释的，只是功能默认是关闭的，但是附加注解，默认实现是不支持的，我们就来自己实现吧。由于 MyBatis Generator 并没有为我们提供抽象类级别的生成器，只有一个顶层借口，而且顶层接口包含了过量的方法，大部分我们都用不到，因此们需要自己实现一个抽象类，来屏蔽不需要的方法接口，然后让自定义注释生成器继承抽象类（当然也可以直接继承默认实现，但我觉得那不是好的选择）。 拿起键盘就是干！哈哈，敲代码吧（工程在我的 GitHub 上）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package io.github.since1986.mybatis.comment.generator;import org.mybatis.generator.api.CommentGenerator;import org.mybatis.generator.api.IntrospectedColumn;import org.mybatis.generator.api.IntrospectedTable;import org.mybatis.generator.api.dom.java.*;import org.mybatis.generator.api.dom.xml.XmlElement;import java.util.Properties;import java.util.Set;// 抽象类，屏蔽掉接口中过多的不需要实现的方法，不需要的什么都不做就好了public abstract class AbstractCommentGenerator implements CommentGenerator &#123; @Override public void addConfigurationProperties(Properties properties) &#123; &#125; @Override public void addFieldComment(Field field, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) &#123; &#125; @Override public void addFieldComment(Field field, IntrospectedTable introspectedTable) &#123; &#125; @Override public void addModelClassComment(TopLevelClass topLevelClass, IntrospectedTable introspectedTable) &#123; &#125; @Override public void addClassComment(InnerClass innerClass, IntrospectedTable introspectedTable) &#123; &#125; @Override public void addClassComment(InnerClass innerClass, IntrospectedTable introspectedTable, boolean markAsDoNotDelete) &#123; &#125; @Override public void addEnumComment(InnerEnum innerEnum, IntrospectedTable introspectedTable) &#123; &#125; @Override public void addGetterComment(Method method, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) &#123; &#125; @Override public void addSetterComment(Method method, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) &#123; &#125; @Override public void addGeneralMethodComment(Method method, IntrospectedTable introspectedTable) &#123; &#125; @Override public void addJavaFileComment(CompilationUnit compilationUnit) &#123; &#125; @Override public void addComment(XmlElement xmlElement) &#123; &#125; @Override public void addRootComment(XmlElement rootElement) &#123; &#125; @Override public void addGeneralMethodAnnotation(Method method, IntrospectedTable introspectedTable, Set&lt;FullyQualifiedJavaType&gt; imports) &#123; &#125; @Override public void addGeneralMethodAnnotation(Method method, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn, Set&lt;FullyQualifiedJavaType&gt; imports) &#123; &#125; @Override public void addFieldAnnotation(Field field, IntrospectedTable introspectedTable, Set&lt;FullyQualifiedJavaType&gt; imports) &#123; &#125; @Override public void addFieldAnnotation(Field field, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn, Set&lt;FullyQualifiedJavaType&gt; imports) &#123; &#125; @Override public void addClassAnnotation(InnerClass innerClass, IntrospectedTable introspectedTable, Set&lt;FullyQualifiedJavaType&gt; imports) &#123; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package io.github.since1986.mybatis.comment.generator;import org.mybatis.generator.api.IntrospectedColumn;import org.mybatis.generator.api.IntrospectedTable;import org.mybatis.generator.api.dom.java.Field;import org.mybatis.generator.api.dom.java.FullyQualifiedJavaType;import org.mybatis.generator.api.dom.java.TopLevelClass;import org.mybatis.generator.config.PropertyRegistry;import org.mybatis.generator.internal.util.StringUtility;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.LinkedList;import java.util.List;import java.util.Properties;import java.util.StringTokenizer;// 这个是我们具体的实现，可以借鉴默认实现的一些办法去写public class CommentWithAnnotationCommentGenerator extends AbstractCommentGenerator &#123; private static final Logger LOGGER = LoggerFactory.getLogger(CommentWithAnnotationCommentGenerator.class); private static final String SUPPRESS_ALL_ANNOTATIONS = "suppressAllAnnotations"; private static final String FIELD_ANNOTATION_FULLY_QUALIFIED_NAMES = "fieldAnnotationFullyQualifiedNames"; private static final String CLASS_ANNOTATION_FULLY_QUALIFIED_NAMES = "classAnnotationFullyQualifiedNames"; private static final String FIELD_COMMENT_TEMPLATE = "/** %s */"; private static final String CLASS_COMMENT_TEMPLATE = "/** %s */"; private Properties properties = new Properties(); // 保留官方的重要设置属性，这样更符合直觉 private boolean suppressAllComments; private boolean suppressAllAnnotations; private List&lt;String&gt; fieldAnnotationFullyQualifiedNames = new LinkedList&lt;&gt;(); private List&lt;String&gt; classAnnotationFullyQualifiedNames = new LinkedList&lt;&gt;(); @Override public void addConfigurationProperties(Properties properties) &#123; this.properties.putAll(properties); suppressAllComments = StringUtility.isTrue(this.properties.getProperty(PropertyRegistry.COMMENT_GENERATOR_SUPPRESS_ALL_COMMENTS)); suppressAllAnnotations = StringUtility.isTrue(this.properties.getProperty(SUPPRESS_ALL_ANNOTATIONS)); fieldAnnotationFullyQualifiedNames.addAll(Util.toList(this.properties.getProperty(FIELD_ANNOTATION_FULLY_QUALIFIED_NAMES))); classAnnotationFullyQualifiedNames.addAll(Util.toList(this.properties.getProperty(CLASS_ANNOTATION_FULLY_QUALIFIED_NAMES))); &#125; @Override public void addFieldComment(Field field, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) &#123; if (!suppressAllComments &amp;&amp; Util.isNotBlank(introspectedColumn.getRemarks())) &#123; LOGGER.debug(String.format("field = %s, column = %s, columnRemarks = %s", field.getName(), introspectedColumn.getActualColumnName(), introspectedColumn.getRemarks())); field.addJavaDocLine(String.format(FIELD_COMMENT_TEMPLATE, introspectedColumn.getRemarks())); &#125; if (!suppressAllAnnotations) &#123; LOGGER.debug(String.format("fieldAnnotationFullyQualifiedNames = %s]", fieldAnnotationFullyQualifiedNames)); fieldAnnotationFullyQualifiedNames.forEach(fieldAnnotationFullyQualifiedName -&gt; &#123; field.addJavaDocLine(Util.atAnnotationName(fieldAnnotationFullyQualifiedName)); &#125;); &#125; else &#123; LOGGER.debug(String.format("suppressAllComments = %b, suppressAllAnnotations = %b", suppressAllComments, suppressAllAnnotations)); &#125; &#125; @Override public void addModelClassComment(TopLevelClass topLevelClass, IntrospectedTable introspectedTable) &#123; if (!suppressAllComments &amp;&amp; Util.isNotBlank(introspectedTable.getRemarks())) &#123; LOGGER.debug(String.format("class = %s, table = %s, tableRemarks = %s", topLevelClass.getType(), introspectedTable.getFullyQualifiedTable(), introspectedTable.getRemarks())); topLevelClass.addJavaDocLine(String.format(CLASS_COMMENT_TEMPLATE, introspectedTable.getRemarks())); &#125; if (!suppressAllAnnotations) &#123; LOGGER.debug(String.format("classAnnotationFullyQualifiedNames = %s]", classAnnotationFullyQualifiedNames)); classAnnotationFullyQualifiedNames.forEach(classAnnotationFullyQualifiedName -&gt; &#123; topLevelClass.addJavaDocLine(Util.atAnnotationName(classAnnotationFullyQualifiedName)); topLevelClass.addImportedType(new FullyQualifiedJavaType(classAnnotationFullyQualifiedName)); &#125;); fieldAnnotationFullyQualifiedNames.forEach(fieldAnnotationFullyQualifiedName -&gt; &#123; topLevelClass.addImportedType(new FullyQualifiedJavaType(fieldAnnotationFullyQualifiedName)); &#125;); &#125; else &#123; LOGGER.debug(String.format("suppressAllComments = %b, suppressAllAnnotations = %b", suppressAllComments, suppressAllAnnotations)); &#125; &#125; static class Util &#123; static boolean isBlank(String string) &#123; return string == null || string.trim().length() == 0; &#125; static boolean isNotBlank(String string) &#123; return !isBlank(string); &#125; static List&lt;String&gt; toList(String commaSeparatedString) &#123; List&lt;String&gt; list = new LinkedList&lt;&gt;(); assert isNotBlank(commaSeparatedString); StringTokenizer stringTokenizer = new StringTokenizer(commaSeparatedString, ","); String token; while (stringTokenizer.hasMoreTokens()) &#123; token = stringTokenizer.nextToken(); list.add(token); &#125; if (list.size() == 0) &#123; list.add(commaSeparatedString); &#125; return list; &#125; static String atAnnotationName(String annotationFullyQualifiedName) &#123; int lastIndexOfDot = annotationFullyQualifiedName.lastIndexOf("."); assert lastIndexOfDot != -1; String atAnnotationName = annotationFullyQualifiedName.substring(lastIndexOfDot + 1); assert isNotBlank(atAnnotationName); return String.format("@%s", atAnnotationName); &#125; &#125;&#125; 上边两个类是我们自定义注释生成器的所有核心内容，我在实现的时候踩了一个小小的坑，在注释生成器接口中有几个 addFieldAnnotation addClassAnnotation 命名中包含注解字眼的方法，我一开始想当然的以为附加注解需要在这里面实现，后来才发现，两者没什么关系 1234567891011121314/** * Adds a @Generated annotation to a class. * * @param innerClass * the class * @param introspectedTable * the introspected table * @param imports * the comment generator may add a required imported type to this list * * @since 1.3.6 */ void addClassAnnotation(InnerClass innerClass, IntrospectedTable introspectedTable, Set&lt;FullyQualifiedJavaType&gt; imports); 上边是 addClassAnnotation 的注释，可以看到，其根@Generated有关。我们自己想要附加注解，实际上还是在附加注释那一步以字符串的形式附加上去的，与这几个*Annotation方法无关。 使用1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;properties resource="package/to/your/data_source.properties"/&gt; &lt;context id="context_mysql" defaultModelType="flat" targetRuntime="MyBatis3"&gt; &lt;property name="javaFileEncoding" value="UTF-8"/&gt; &lt;!-- CommentWithAnnotationCommentGenerator --&gt; &lt;commentGenerator type="io.github.since1986.mybatis.comment.generator.CommentWithAnnotationCommentGenerator"&gt; &lt;property name="fieldAnnotationFullyQualifiedNames" value="one.your.customer.FieldAnnotationClass,another.your.customer.FieldAnnotationClass"/&gt; &lt;property name="classAnnotationFullyQualifiedNames" value="one.your.customer.ClassAnnotationClass,another.your.customer.ClassAnnotationClass"/&gt; &lt;/commentGenerator&gt; &lt;jdbcConnection driverClass="$&#123;driverClass&#125;" connectionURL="$&#123;connectionURL&#125;" userId="$&#123;userId&#125;" password="$&#123;password&#125;"&gt; &lt;!-- better keep this --&gt; &lt;property name="useInformationSchema" value="true"/&gt; &lt;/jdbcConnection&gt; &lt;javaModelGenerator targetPackage="your.model" targetProject="/path/to/your/project/src/main/java"&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage="your.mapper" targetProject="src/main/resources"&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator targetPackage="your.mapper" type="ANNOTATEDMAPPER" targetProject="src/main/java"&gt; &lt;/javaClientGenerator&gt; &lt;table tableName="your_table" domainObjectName="YourDomain"&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 在生成的 Java 中会将数据库注释作为注释，诠释了DRY原则，另外付加入了我们需要的框架注解，不用再手工处理重复劳动了，解放了生产力，可以早点下班回家，多休息休息了（做梦中…） 参考资料mybatis-generator自定义注释生成 Mybatis Generator最完整配置详解]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea远程调试]]></title>
    <url>%2Ff47cfdef.html</url>
    <content type="text"><![CDATA[背景我司有一套自研的 RPC 框架，公司现有得开发模式是 RPC 服务提供端不 debug 而用单元测试来完成开发循环，这种方式有利有弊，我个人还是希望在单元测试外可以自由的调试这样，有些情况远比单元测试要高效。那么问题来了，由于 RPC 服务端是已容器方式启动的，所以无法直接在 idea 工程中断点调试，有两种办法可以解决：1.自己实现一个启动器，抛弃容器自己启动 RPC 服务；2.使用远程调试调试已经通过容器启动的 RPC 服务。第一种我觉得办法是最优雅的，但是需要自己开发启动器，时间较长（正在尝试实现），在开发出来之前，可以先临时使用第二种办法应急。好了，我们其实只要知道怎样远程调试就好了。 实践开启远程调试可以分成两步。 第一步，在 JVM 启动时加上参数，告知 JVM 我们将要远程调试： 1-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=5555,server=y,suspend=n 第二步，在 idea 中配置开始远程调试 配置好 Run/Debug Configurations 注意上图中5555对应了我们在 JVM 参数中的 address=5555 像本地调试一样，用绿虫子启动，就开始监听并调试了，断点也会停了,启动后控制台会输出Connected to the target VM, address: &#39;localhost:5555&#39;, transport: &#39;socket&#39;，当停止调试后，控制台会输出Disconnected from the target VM, address: &#39;localhost:5555&#39;, transport: &#39;socket&#39; 后记其实，做这个远程调试的初衷，就是为了减轻自己开发的负担，让自己整个开发工作流更加顺畅，我其实大可以按照公司的方式，用单元测试来做，但是，能让自己提升效率的事，为什么不琢磨一下呢，不循规蹈矩，爱折腾，我觉得才是一种优良的品质。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm2中使用rz和sz]]></title>
    <url>%2F14df9481.html</url>
    <content type="text"><![CDATA[安装依赖1234567brew install lrzszbrew install wgetcd /usr/local/binsudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.shsudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.shsudo chmod 777 /usr/local/bin/iterm2-* 修改 iTerm2 Profile 配置1234567Regular expression: rz waiting to receive.\*\*B0100Action: Run Silent CoprocessParameters: /usr/local/bin/iterm2-send-zmodem.shRegular expression: \*\*B00000000000000Action: Run Silent CoprocessParameters: /usr/local/bin/iterm2-recv-zmodem.sh 参考资料Mac上如何通过跳板机向服务器上上传大文件 Mac osx 下安装iTerm2，并使用rz sz上传下载（附homebrew配置）]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决maven的一个StackOverflowError]]></title>
    <url>%2F4422e9a6.html</url>
    <content type="text"><![CDATA[今天在用 “debug” 模式运行 maven 的 jetty:run 时，出现了 java.lang.StackOverflowError ，具体的栈信息如下： 123456789101112131415161718192021The system is out of resources.Consult the following stack trace for details.java.lang.StackOverflowError at com.sun.tools.javac.comp.Attr.visitBinary(Attr.java:2062) at com.sun.tools.javac.tree.JCTree$JCBinary.accept(JCTree.java:1565) at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:431) at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:418) at com.sun.tools.javac.comp.Attr.attribExpr(Attr.java:460) at com.sun.tools.javac.comp.Attr.visitBinary(Attr.java:2062) at com.sun.tools.javac.tree.JCTree$JCBinary.accept(JCTree.java:1565) at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:431) at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:418) at com.sun.tools.javac.comp.Attr.attribExpr(Attr.java:460) at com.sun.tools.javac.comp.Attr.visitBinary(Attr.java:2062) at com.sun.tools.javac.tree.JCTree$JCBinary.accept(JCTree.java:1565) at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:431) at com.sun.tools.javac.comp.Attr.attribTree(Attr.java:418) at com.sun.tools.javac.comp.Attr.attribExpr(Attr.java:460) at com.sun.tools.javac.comp.Attr.visitBinary(Attr.java:2062) ...此处省略 N 个重复的 Google 了一下，了解到解决 java.lang.StackOverflowError 的一种办法是增大栈的大小： 1-Xss你想增加到的大小 由于我是用 idea 启动的 debug，所以要在 idea 中设置，设置选项的位置如下： 调成了栈大小后，重新 debug 发现不再 StackOverflowError 了。]]></content>
      <tags>
        <tag>实践</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在后端工程中使用静态依赖注入框架Dagger2]]></title>
    <url>%2Fb243446d.html</url>
    <content type="text"><![CDATA[想必前端的同学对于Dagger2并不陌生，在Android开发中，它是主力的依赖注入框架，但是，实际上，Dagger2不仅仅能用于前端开发中，在后端也有它的用武之地。 最近在做公司的一个产品，公司强制必须使用内部自研框架，由于这个框架不支持IOC，所以用起来很让人头疼，想着将Spring结合到框架了里，但是感觉短时间做不到，然而我还是十分的怀念有IOC的日子，这是，突然想起来，去年在搞Android时了解到了一款依赖注入框架Dagger2，想了想，为什么不用它呢。 说干就干，我找到了Dagger2的官方文档，文档很简单，一页就说完了基本的IOC使用。大致看了一眼，基本上就知道怎么用了，那么我们就来一个简单的 demo 说明一下用法吧。 首先是配置依赖项和注解处理器，我们的 demo 用maven来演示（我自己做工程一般会选择Gradle，但是公司使用maven，这里就和公司一致了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;io.github.since1986&lt;/groupId&gt; &lt;artifactId&gt;learn-dagger&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.dagger&lt;/groupId&gt; &lt;artifactId&gt;dagger&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;com.google.dagger&lt;/groupId&gt; &lt;artifactId&gt;dagger-compiler&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 注意上边配置的dependencies里有一个dagger，另外plugins的maven-compiler-plugin配置了annotationProcessorPaths，这些都是用来处理代码生成的。正式这些代码生成机制，造就了Dagger2的”静态注入”的特性。（这里说明一下，Dagger2是”静态的依赖注入框架”，所谓”静态”，我的理解是指用代码生成的方式来处理注入，生成的代码也会是你的工程代码的一部分，你可以像自己写的代码一样来调用，编译时也会被一起编译，这些代码一旦生成，在运行时是不会变化的，所以称之为”静态”） 配置好了依赖以及注解处理器，我们就可以编码了。我们的 demo 尽量简单一些，一共有两个service，一个UserService，一个ProfileService，其中UserService中注入了ProfileService： 12345678package io.github.since1986.learn.dagger.service;import io.github.since1986.learn.dagger.model.Profile;public interface ProfileService &#123; Profile get(long id);&#125; 12345678package io.github.since1986.learn.dagger.service;import io.github.since1986.learn.dagger.model.User;public interface UserService &#123; User get(long id);&#125; 1234567891011package io.github.since1986.learn.dagger.service;import io.github.since1986.learn.dagger.model.Profile;public class ProfileServiceImpl implements ProfileService &#123; @Override public Profile get(long id) &#123; return Profile.DEFAULT; &#125;&#125; 12345678910111213141516171819202122package io.github.since1986.learn.dagger.service;import io.github.since1986.learn.dagger.model.User;import javax.inject.Inject;public class UserServiceImpl implements UserService &#123; private final ProfileService profileService; @Inject // 使用JavaEE标准的javax.inject.Inject来注入 public UserServiceImpl(ProfileService profileService) &#123; this.profileService = profileService; &#125; @Override public User get(long id) &#123; User default_ = User.DEFAULT; default_.setProfile(profileService.get(id)); return default_; &#125;&#125; 我们注意UserServiceImpl中这一段 1234@Inject // 使用JavaEE标准的javax.inject.Inject来注入public UserServiceImpl(ProfileService profileService) &#123; this.profileService = profileService;&#125; 依赖注入在业务类中只需要写一个注解@Inject就好了，这里其实很类似于Spring的构造器注入。当然，只有这个@Inject是无法完成真正的注入的，我们接着看下边的代码： 12345678910111213141516package io.github.since1986.learn.dagger.service;import dagger.Module;import dagger.Provides;import javax.inject.Singleton;@Modulepublic class ProfileServiceModule &#123; @Singleton @Provides static ProfileService provideProfileService() &#123; return new ProfileServiceImpl(); &#125;&#125; 12345678910111213141516package io.github.since1986.learn.dagger.service;import dagger.Module;import dagger.Provides;import javax.inject.Singleton;@Modulepublic class UserServiceModule &#123; @Singleton @Provides static UserService provideUserService(ProfileService profileService) &#123; return new UserServiceImpl(profileService); &#125;&#125; 123456789101112131415package io.github.since1986.learn.dagger;import dagger.Component;import io.github.since1986.learn.dagger.service.ProfileServiceModule;import io.github.since1986.learn.dagger.service.UserService;import io.github.since1986.learn.dagger.service.UserServiceModule;import javax.inject.Singleton;@Singleton@Component(modules = &#123;UserServiceModule.class, ProfileServiceModule.class&#125;)public interface AppComponent &#123; UserService userService();&#125; 我们可以看出来实际上，真正用于处理依赖注入组件读取的配置信息（相当于Spring中的@Configuration）是写在@Module和@Component标注的类里的。 @Module中有@Provides标示出来需要对外发布的Bean（这里不知道该怎么起名，就借用Spring的概念吧），你可以简单地把它理解为Spring中的@Bean。 @Component中(modules = {UserServiceModule.class, ProfileServiceModule.class})将UserServiceModule和ProfileServiceModule这两个Module结合了起来（这里可以勉强理解为Spring中的容器，当然Dagger2里应该并不存在容器的概念）。 到这里，依赖注入的配置过程就完成了（与Spring一样，也是通过Java文件进行配置完成DI），然后我们再来看如何使用。在使用时，和Spring就有所不同了，由于是”静态”注入，所以注入实际上是依靠注解处理器来生成代码从而完成的，因此需要让注解处理器运作起来，我们用maven的maven-compiler-plugin中的compiler:compile来生成就好了。生成完毕后，会在target/generated-sources/annotations/下生成一些列源代码，这些源码就是Dagger2帮我们生成的依赖注入处理类。其中有一个比我们的AppComponent类名多一个Dagger前缀的类，这个类就是我们想要的（多一个Dagger前缀是Dagger2的规则）。 123456789101112package io.github.since1986.learn.dagger;import io.github.since1986.learn.dagger.service.UserService;public class App &#123; private static UserService userService = DaggerAppComponent.create().userService(); public static void main(String[] args) &#123; System.out.println(userService.get(1).getProfile().getName()); &#125;&#125; private static UserService userService = DaggerAppComponent.create().userService();注意这一段，以我的理解，这个类似于Spring中的context.getBean()。 到这里，我们的小 demo 就写好了，相当的简单，几个注解，外加注解处理器，就搞定了依赖注入。那么也许你会问，有spring这么强大的框架，我为什么还要用Dagger2呢？我个人理解，确实一般情况下是用不到的，但是Dagger2比较轻量，不存在很多复杂的概念，因此整合进一些小众框架用于提供IOC支持会相对容易一些，我也是基于实际的需要出发，所以选择了它，如果能快速整合Spring的话，我还是会选择用Spring。当然，小巧轻量也是一个优势，说不定就能玩出更多花样来，谁知道呢。]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea的SQL控制台可以在运行时手工指定SQL参数]]></title>
    <url>%2Fc6dbd277.html</url>
    <content type="text"><![CDATA[在写一个 SQL 时发现，idea 的 SQL 控制台是可以在运行 SQL 的时候，手工填入需要传入 SQL 的参数的，这一点很方便我们调试。触发这个功能只需要在 SQL 中将参数留成?就好了。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用伪代码辅助业务逻辑的设计]]></title>
    <url>%2Fd2b4bb9e.html</url>
    <content type="text"><![CDATA[这几天在做一个急活，很短时间内就需要上线，并且其中有一个功能点的业务逻辑很绕，很不好实现，当然，也是有办法在短时间内搞定复杂业务逻辑的设计的。我是使用了”伪代码辅助分析”这种方式来做的。 将想要实现的业务逻辑先不考虑和编程语言语法强关联，先从基本的思维逻辑入手，用伪代码尝试写出整个业务逻辑的流程。然后在将代码用最 low 的方法按照思路流水般写出来，然后在写的同时，考虑哪些部分可以复用，将其提取出来，这样一步一步就能将一下子想不明白的复杂业务逻辑转化为代码了。当然在中间需要不断和产品同学以及一个小组里的同事反复交流、确认，这样人多力量大，也能够辅助自己分析清楚业务逻辑。 一点点实践中的体会，记录下来，算是小的总结。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 保存分销VIP购买分成 * &lt;pre&gt; * 收益计算部分的业务逻辑如下： * 特殊的情况： * 教练永远是 40% 公司永远是 20% * * 一般的情况，收益需要计算两部分： * 一部分是自己的最终收益 = 自己本身的比例 + 所有下级的比例之和 * 另一部分是给自己所有上级带来的收益（上供），这个是需要考虑断层的 * * switch（介绍人等级）&#123; * case 1 &#123; //教练 * 自己干活拿的佣金比例 = 自己本身的比例 + 所有下级的比例之和 * 40% * * 上供 * 4 3 2 * 4 3 (3拿 15% + 15%) 断层情况1 * 4 2 (4拿 10% + 15%) 断层情况2 * &#125; * * case 2 &#123; //驾校 * 自己干活拿 * 40% + 15% * * 上供 * 4 3 * 4 (4拿 10% + 15%) 断层情况 * &#125; * * case 3 &#123; //经理人 * 自己干活拿 * 40% + 15% + 15% * * 上供（无断层） * 4 * &#125; * * case 4 &#123; //高级经理人 * 自己干活拿 * 40% + 15% + 15% + 10% * * 无上供 * &#125; * &#125; * * &lt;/pre&gt; * @param studentOpenid 购买 VIP 的学员的 openid * @param orderId 学员购买 VIP 生成订单的 id */void save(String studentOpenid, long orderId);]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Generate POJOs.groovy从表生成POJO]]></title>
    <url>%2Fc3bb3a33.html</url>
    <content type="text"><![CDATA[在日常工作中，将表转换为POJO是再常见不过的场景了，字段少还好说，要是字段多了，一个个手写是很烦人的，可以借助 IDE 提供的工具来帮我们完成这类繁琐的工作。 在 idea 中自带了一个Generate POJOs.groovy，就是用来将表转换为POJO的，这个脚本在”Scratches and Consoles”中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import com.intellij.database.model.DasTableimport com.intellij.database.model.ObjectKindimport com.intellij.database.util.Caseimport com.intellij.database.util.DasUtil/* * Available context bindings: * SELECTION Iterable&lt;DasObject&gt; * PROJECT project * FILES files helper */packageName = &quot;这里改成你POJO的包;&quot;typeMapping = [ (~/(?i)int/) : &quot;long&quot;, (~/(?i)float|double|decimal|real/): &quot;double&quot;, (~/(?i)datetime|timestamp/) : &quot;java.sql.Timestamp&quot;, (~/(?i)date/) : &quot;java.sql.Date&quot;, (~/(?i)time/) : &quot;java.sql.Time&quot;, (~/(?i)/) : &quot;String&quot;]FILES.chooseDirectoryAndSave(&quot;Choose directory&quot;, &quot;Choose where to store generated files&quot;) &#123; dir -&gt; SELECTION.filter &#123; it instanceof DasTable &amp;&amp; it.getKind() == ObjectKind.TABLE &#125;.each &#123; generate(it, dir) &#125;&#125;def generate(table, dir) &#123; def className = javaName(table.getName(), true) def fields = calcFields(table) new File(dir, className + &quot;.java&quot;).withPrintWriter &#123; out -&gt; generate(out, className, fields) &#125;&#125;def generate(out, className, fields) &#123; out.println &quot;package $packageName&quot; out.println &quot;&quot; out.println &quot;&quot; out.println &quot;public class $className &#123;&quot; out.println &quot;&quot; fields.each() &#123; if (it.annos != &quot;&quot;) out.println &quot; $&#123;it.annos&#125;&quot; out.println &quot; private $&#123;it.type&#125; $&#123;it.name&#125;;&quot; &#125; out.println &quot;&quot; fields.each() &#123; out.println &quot;&quot; out.println &quot; public $&#123;it.type&#125; get$&#123;it.name.capitalize()&#125;() &#123;&quot; out.println &quot; return $&#123;it.name&#125;;&quot; out.println &quot; &#125;&quot; out.println &quot;&quot; out.println &quot; public void set$&#123;it.name.capitalize()&#125;($&#123;it.type&#125; $&#123;it.name&#125;) &#123;&quot; out.println &quot; this.$&#123;it.name&#125; = $&#123;it.name&#125;;&quot; out.println &quot; &#125;&quot; out.println &quot;&quot; &#125; out.println &quot;&#125;&quot;&#125;def calcFields(table) &#123; DasUtil.getColumns(table).reduce([]) &#123; fields, col -&gt; def spec = Case.LOWER.apply(col.getDataType().getSpecification()) def typeStr = typeMapping.find &#123; p, t -&gt; p.matcher(spec).find() &#125;.value fields += [[ name : javaName(col.getName(), false), type : typeStr, annos: &quot;&quot;]] &#125;&#125;def javaName(str, capitalize) &#123; def s = com.intellij.psi.codeStyle.NameUtil.splitNameIntoWords(str) .collect &#123; Case.LOWER.apply(it).capitalize() &#125; .join(&quot;&quot;) .replaceAll(/[^\p&#123;javaJavaIdentifierPart&#125;[_]]/, &quot;_&quot;) capitalize || s.length() == 1? s : Case.LOWER.apply(s[0]) + s[1..-1]&#125; 可以按照需要来更改。这个脚本使用也很简单，在需要转换的表上点右键，在”Scripted Extensions”菜单中点击”Generate POJOs.groovy”子菜单，就可以运行这个脚本了，运行后会弹出文件选择框让我们来选择存放生成POJO文件的目录，选好后就会生成表对应的POJO了。 处理重复性事物我们要善用工具，这样能省很多事。]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效MySQL开发规范]]></title>
    <url>%2Fb1c04874.html</url>
    <content type="text"><![CDATA[*本篇转载自公司内部文章（已脱敏处理） 基础规范 数据库字符集默认使用utf8，如果存储emoji等四字节使用utf8mb4字符集 禁止将业务日志实时保存到数据库，建议保存到日志文件，对于统计后的结果再存放到mysql中 禁止线上核心业务使用mysql存储过程、视图、触发器、Event、InnoDB外键约束等，这些容易将业务逻辑和db耦合在一起，而且在MySQL的这些特性中存在严重BUG 库表设计 库名、表名、字段名必须使小写字母，并采用下划线分割；对相关功能的表应当使用相同前缀，如job_xxx，前缀通常为库名或依赖主实体对象： 建议表及关键字段写备注，详细说明表及字段的含义 涉及货币金额或其他精度敏感的数据必须使用定点数DECIMAL替代FLOAT和DOUBLE 库名、表名、字段名禁止使用MySQL保留字，如date、like、desc、return等 控制表字段数，单表不超过50个纯INT/20个VARCHAR(10)字段等同存储体积的字段数，上限控制在20~50 字段长度只分配真正需要的空间 问题：使用VARCHAR(5) 和VARCHAR(200) 存储’hello’的磁盘空间开销是一样的,使用更短的列有什么优势吗？ 更大的定义列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值,尤其是使用内存临时表进行排序或操作时会特别糟糕 索引设计 基本规则：索引不是越多越好，能不添加的索引尽量不要添加，过多的索引会严重降低数据插入和更新的效率，并带来更多的读写冲突和死锁！ 索引名称必须使用小写，普通索引按照“idx_字段名_字段名【_字段名】”进行命名，唯一索引按照“uniq_字段名_字段名【_字段名】”进行命名” 表必须有主键，推荐使用独立于业务的AUTO_INCREMENT列或全局ID生成器做主键，禁止使用多字段做联合主键 不使用UUID/MD5/HASH等函数生成的无规则值做主键，效率极差 索引数量控制 单张表中索引数量不超过5个 单个索引中的字段数不超过5个 对字符串使用前缀索引，前缀索引长度不超过10个字符 索引字段的顺序需要考虑每个字段去重之后的数量，区分度最大的【个数最多的】放在前面。 合理创建联合索引（避免冗余），符合最左前缀原则：(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c) 可能需要添加索引的字段： ORDER BY，GROUP BY，DISTINCT的字段需要添加在索引的后面 UPDATE、DELETE语句需要根据WHERE条件添加索引 对于JOIN操作，需要在JOIN字段上建立索引 线上慎用FORCE INDEX，使用前需要和DBA沟通，并得到DBA的测试允许 线上OLTP系统中禁止使用外键，高并发时极易引起死锁等问题 索引使用禁忌 不使用%前导的查询，如like &#39;%ab&#39; 不使用负向查询，如not in/not like/&lt;&gt; 不在低区分度的列上建立索引，例如“性别” 不在索引列进行数学运算和函数运算 示例：假设在表tab中id建立了索引 Select col_A,col_B from tab where id + 1 &gt; 10001 不会使用索引 Select col_A,col_B from tab where id &gt; 10001 – 1 会使用索引 SQL优化 线上尽量少使用大SQL，可能一条大SQL就把整个数据库堵死，将复杂SQL拆分为多条简单SQL，化繁为简 一条SQL只能在一个CPU上运算，如果SQL比较复杂执行效率会非常低 简单SQL缓存命中率更高 减少锁表时间 充分利用多核CPU，提高并发效率 减少MySQL端的数学运算和逻辑判断，避免SQL语句出现md5()、order by rand()等 尽量少用SELECT * ,只取需要的数据列, 避免无谓的IO、CPU和网络开销 WHERE条件中，同一字段改写OR为IN()，IN包含的值不应过多，默认不超过200个，IN里禁止使用子查询 过滤表记录合并且不去重的情况，改写UNION为UNION ALL 减少使用拼接SQL,使用预编译语句，降低SQL注入概率 WHERE条件中的非等值条件（IN、BETWEEN、&lt;、&lt;=、&gt;、&gt;=）会导致使用不了联合索引的后续字段，注意避免 WHERE条件比较，字段类型和传入值必须保证类型一致，避免隐式转换 示例：字段： code varchar(50) NOT NULL COMENT &#39;编码&#39; #code上建立了索引 SELECT id,name,addr from tab_name where code=10001; 不会使用索引 SELECT id,name,addr from tab_name where code=&#39;10001&#39;; 会使用索引 Limit分页优化 传统分页： Select * from table limit 10000,10; LIMIT原理：Limit 10000,10 偏移量越大则越慢 推荐分页： 分页方式一： Select * from table WHERE id&gt;=23423 limit 11; #10+1 (每页10条) Select * from table WHERE id&gt;=23434 limit 11; 分页方式二： Select * from table WHERE id &gt;= ( select id from table limit 10000,1 ) limit 10; 分页方式三： Select * from table INNER JOIN (SELECT id from table limit 10000,10) USING(id) 分页方式四： 程序取ID: Select id from table limit 10000,10; 然后 Select * from table WHERE ID in(123,456…);]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效Redis开发规范]]></title>
    <url>%2Fce36c3d9.html</url>
    <content type="text"><![CDATA[*本篇转载自公司内部文章（已脱敏处理） 冷热数据分离，不要将所有数据全部都放到Redis中 虽然Redis支持持久化，但是Redis的数据存储全部都是在内存中的，成本昂贵。建议根据业务只将高频热数据存储到Redis中【QPS大于5000】，对于低频冷数据可以使用MySQL/MongoDB等基于磁盘的存储方式，不仅节省内存成本，而且数据量小在操作时速度更快、效率更高！ 不同的业务数据要分开存储 不要将不相关的业务数据都放到一个Redis实例中，建议新业务申请新的单独实例。因为Redis为单线程处理，独立存储会减少不同业务相互操作的影响，提高请求响应速度；同时也避免单个实例内存数据量膨胀过大，在出现异常情况时可以更快恢复服务！ 存储的Key一定要设置超时时间 如果应用将Redis定位为缓存Cache使用，对于存放的Key一定要设置超时时间！因为若不设置，这些Key会一直占用内存不释放，造成极大的浪费，而且随着时间的推移会导致内存占用越来越大，直到达到服务器内存上限！另外Key的超时长短要根据业务综合评估，而不是越长越好！ 对于必须要存储的大文本数据一定要压缩后存储 对于大文本【超过500字节】写入到Redis时，一定要压缩后存储！大文本数据存入Redis，除了带来极大的内存占用外，在访问量高时，很容易就会将网卡流量占满，进而造成整个服务器上的所有服务不可用，并引发雪崩效应，造成各个系统瘫痪！ 线上Redis禁止使用Keys正则匹配操作 Redis是单线程处理，在线上KEY数量较多时，操作效率极低【时间复杂度为O(N)】，该命令一旦执行会严重阻塞线上其它命令的正常请求，而且在高QPS情况下会直接造成Redis服务崩溃！如果有类似需求，请使用scan命令代替！ 可靠的消息队列服务 Redis List经常被用于消息队列服务。假设消费者程序在从队列中取出消息后立刻崩溃，但由于该消息已经被取出且没有被正常处理，那么可以认为该消息已经丢失，由此可能会导致业务数据丢失，或业务状态不一致等现象发生。为了避免这种情况，Redis提供了RPOPLPUSH命令，消费者程序会原子性的从主消息队列中取出消息并将其插入到备份队列中，直到消费者程序完成正常的处理逻辑后再将该消息从备份队列中删除。同时还可以提供一个守护进程，当发现备份队列中的消息过期时，可以重新将其再放回到主消息队列中，以便其它的消费者程序继续处理。 谨慎全量操作Hash、Set等集合结构 在使用HASH结构存储对象属性时，开始只有有限的十几个field，往往使用HGETALL获取所有成员，效率也很高，但是随着业务发展，会将field扩张到上百个甚至几百个，此时还使用HGETALL会出现效率急剧下降、网卡频繁打满等问题【时间复杂度O(N)】,此时建议根据业务拆分为多个Hash结构；或者如果大部分都是获取所有属性的操作,可以将所有属性序列化为一个STRING类型存储！同样在使用SMEMBERS操作SET结构类型时也是相同的情况！ 根据业务场景合理使用不同的数据结构类型 目前Redis支持的数据库结构类型较多：字符串（String），哈希（Hash），列表（List），集合（Set），有序集合（Sorted Set）, Bitmap, HyperLogLog和地理空间索引（geospatial）等,需要根据业务场景选择合适的类型，常见的如：String可以用作普通的K-V、计数类；Hash可以用作对象如商品，包含较多属性的信息；List可以用作消息队列、粉丝/关注列表等；Set可以用于推荐；Sorted Set可以用于排行榜等！]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Junit无法正常测试多线程问题原因分析与解决]]></title>
    <url>%2F4a713ad3.html</url>
    <content type="text"><![CDATA[背景今天在 Junit 中尝试调试多线程业务，结果发现，testXX 方法中早早就退出了虚拟机，启动的子线程全都压根没有执行，也就是 Junit 中无法正常的测试多线程。 分析一开始，我以为是在主线程中出现了异常，导致了虚拟机的退出，但是做了一个小实验分析了一下，发现不是那么回事。经过试验，我发现，无论是 Exception RuntimeException 甚至 Error 都不能造成虚拟机的退出，子线程都能被执行到，只有 System.exit(n) 才能直接退掉虚拟机，忽略子线程的执行。 1234567891011121314151617181920212223package com.github.since1986.learn.java;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class LearnThread &#123; public static void main(String[] args) throws Exception &#123; int subThreadCount = 9; ExecutorService executorService = Executors.newFixedThreadPool(subThreadCount); for (int i = 0; i &lt; subThreadCount; i++) &#123; executorService.submit(() -&gt; &#123; System.out.printf("线程 [%s] 运行\n", Thread.currentThread().getName()); &#125;); &#125; //throw new Exception(); //throw new RuntimeException(); //throw new Error(); System.exit(0); &#125;&#125; 输出 1Process finished with exit code 0 因此，大致可以猜测，Junit 中在什么地方调用了System.exit() 所以造成了子线程无法执行，Google 了一下，有这篇文章也研究了这个问题，果然在 Junit 中有一个类 org.junit.runner.JUnitCore 包含了 System.exit() 123456789101112/** * Run the tests contained in the classes named in the &lt;code&gt;args&lt;/code&gt;. * If all tests run successfully, exit with a status of 0. Otherwise exit with a status of 1. * Write feedback while tests are running and write * stack traces for all failed tests after the tests all complete. * * @param args names of classes in which to find tests to run */public static void main(String... args) &#123; Result result = new JUnitCore().runMain(new RealSystem(), args); System.exit(result.wasSuccessful() ? 0 : 1);&#125; 我想在这个类上打上断点试一下，走一遍，结果惊奇的发现，断点并没有走到这个，然后看了看 debug 窗中线程 main 发现有这么一个类 com.intellij.rt.execution.junit.JUnitStarter 最后 main() 原来是在这了类里的，这个类明显是 idea 内部的一个插件类。 Google 了一下，实际上这个插件是开源的，可以看到这个类的源代码，大致上看了一眼，里面也是调用了System.exit()（不管怎样，最后 testXX 方法肯定会是通过main()来执行的，所以我们看main()就好了），所以，大只能印证个大概，是因为 Junit 当中使用了System.exit()，所以导致了子线程的执行因为虚拟机的退出而被忽略，所以无法正常测试多线程。 123456789101112131415161718192021222324public static void main(String[] args) throws IOException &#123; Vector argList = new Vector(); for (int i = 0; i &lt; args.length; i++) &#123; String arg = args[i]; argList.addElement(arg); &#125; final ArrayList listeners = new ArrayList(); final String[] name = new String[1]; String agentName = processParameters(argList, listeners, name); if (!JUNIT5_RUNNER_NAME.equals(agentName) &amp;&amp; !canWorkWithJUnitVersion(System.err, agentName)) &#123; System.exit(-3); &#125; if (!checkVersion(args, System.err)) &#123; System.exit(-3); &#125; String[] array = new String[argList.size()]; argList.copyInto(array); int exitCode = prepareStreamsAndStart(array, agentName, listeners, name[0]); System.exit(exitCode);&#125; 解决其实明白了大致的原因，解决起来也就简单了，让主线程等待子线程都执行完毕就好了，实现这一点有多种方式，可以用”倒计数门栓”或者”可循环使用屏障”。（实际上我中间请教了我的同事，他并没有分析这莫多，大致凭经验告诉我可以使用倒计数门栓，我当时试了确实管用） 总结通过这次解决工作中出现的一个问题的契机，我对 Junit 以及多线程又加深了一些理解。总的来说，对于理论的理解要在实践中不断的磨练才能越来越深入。]]></content>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用快捷键记录]]></title>
    <url>%2Fc7eaf7eb.html</url>
    <content type="text"><![CDATA[前言在日常开发中，经常会用到一些快捷键操作，在这里统一记录一下，防止遗忘。 macOS⌘ + ↑ Finder 转向上层目录 ⇧ + ⌘ + . 显示/隐藏 隐藏文件 ⌘ + c 复制后按 ⌥ + ⌘ + v 相当于 Windows 中的剪切 IntelliJ IDEACtrl + shift + 大数字键 给代码打标签 按住 ⌥ + 鼠标选中 列编辑 ⌥ + ⌘ + 左右方向建 回到上一/下一 编辑点 ⌥ + ⌘ + b 定位到实现 Ctrl + j 快速打开 Javadoc ⌘ + F12 打开大纲 ⇧ + ⌘ + 小键盘加号键 展开全部 ⇧ + ⌘ + 小键盘减号键 收起全部 ⌥ + ⌘ + [ 切换到上一项目窗口 ⌥ + ⌘ + ] 切换到下一项目窗口 ⌘ + y 删除行 ⇧ + ⌘ + u 切换选择字母的大小写 ⌘ + g 快速跳转到 行:列 Chrome⇧ + ⌘ + r 强制刷新（相当于 Windows 中的 Ctrl + F5） iTerm⌘ + d 横向分屏 ⇧ + ⌘ + d 纵向分屏 ⌥ + ⌘ + f 密码管理器]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过分析原型做系统设计]]></title>
    <url>%2Fa6253051.html</url>
    <content type="text"><![CDATA[刚刚接手了一个新系统，领导让我去做一下设计，一开始我稍感有些找不到头绪，后来看了产品同学给的 AxureRP 原型文件后，感觉有了思路了。总体的思路是”由点及面”，先分析原型中给出的各个页面可能需要哪些接口，都分析出来后，再总结出整体的类设计。不要一上来就铺大面，从细微处着眼，然后再汇集成整体的构架，这样在思路上就很自然了，就像大海是由小溪汇聚成河流，在汇聚成江，最后合流成为海与洋一样，实际上大自然早就给了我们就决问题的灵感了，要善于发现。]]></content>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles无法抓取iOS中HTTPS请求的解决]]></title>
    <url>%2Fe138fa49.html</url>
    <content type="text"><![CDATA[今天工作中需要用 Charles 抓取 iOS 中的 HTTPS 包，已经配置好了 macOS 端与 iOS 端的证书，但是 HTTPS 抓取全是红叉，后来看了看官方文档，有这么一段描述： If you are on iOS 10.3 or later, open the Settings.app and navigate to General &gt; About &gt; Certificate Trust Settings, and find the Charles Proxy certificate, and switch it on to enable full trust for it (More information about this change in iOS 10). 原来 iOS 10.3 以后需要手动打开一个开关，才能正常抓包 HTTPS。 打开这个开关后，果然能够正常抓包了。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作中常用的Linux命令汇总]]></title>
    <url>%2Ffaa8f5e3.html</url>
    <content type="text"><![CDATA[日常工作中，需要用到不少命令，在这里记录一下，以强化记忆。 查看系统当前登录用户信息1234567wwhowhoamilast 查看终端命令执行历史1history 压缩123tar –czf desc.tar.gz *.srczip -r desc.zip ./src/* 解压123tar -xzvf file.tar.gzunzip -d /desc src.zip 软链接123ln -s file linkrm -r link 移动文件1mv src desc/src 文件传输12345scp /local/file/path user@remote_host:/remote/save/pathscp user@remote_host:/file/path /local/file/pathrz 字符串操作12#获得文件名（去掉路径）basename /file/path/file_name #输出 file_name 文件操作12345#查看文件行数cat xxx.x | wc -l#ll命令显示人类可读的文件大小ll -h 环境查看12345#查看所有环境变量env#查看所有变量set]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实践中遇到的设计模式的总结]]></title>
    <url>%2F432fb420.html</url>
    <content type="text"><![CDATA[模式来源于实践，又会反过来作用于实践，在日常的工作中，我们经常会有意无意的接触一些模式，在此持续记录一下，为设计提供灵感的来源。 构建器模式 java.lang.StringBuilder]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用业务SQL积累]]></title>
    <url>%2F2e631123.html</url>
    <content type="text"><![CDATA[积累一下常用的业务SQL,以备将来重新回顾使用。 有如下用户表和订单表，查出用户信息及其订单数（只查订单数大于等于1的），并按其订单数倒序users id name phone 1 测试1 12345671 2 测试2 12345672 3 测试3 12345673 4 测试4 12345674 orders id number user_id 1 o1 1 2 o2 2 3 o3 2 4 o4 2 1select * from (select users.id, users.name, users.phone, (select count(orders.id) from orders where orders.user_id = users.id) as order_count from users) as temp_table where temp_table.order_count &gt;= 1 order by temp_table.order_count desc;]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS命令行备忘]]></title>
    <url>%2F440c7082.html</url>
    <content type="text"><![CDATA[前言命令行总是记不住，用的时候去Google，查找成本太高，想了想，索性开篇文章汇总一下，做个备忘录，每次查完了都记到这里，下次直接从这里查，速度还快些。另外记录的过程也等于加深一遍记忆。 另外推荐安装工具 thefuck 很实用。 一般命令12#查看IP等信息（相当于Windows中的ipconfig）ifconfig 123#查看进程监听的端口号jps #查出进程号lsof -p &lt;进程号&gt; | grep LISTEN brew 命令1234567891011#查看服务列表brew services list#启动服务brew services start &lt;服务名&gt;#停止服务brew services stop &lt;服务名&gt;#重启服务brew services restart &lt;服务名&gt; npm 相关1234567891011#pm2 查看pm2 list#pm2 启动pm2 start &lt;name&gt;#pm2 重启pm2 restart &lt;name&gt;#pm2 停止pm2 stop &lt;name&gt; 参考资料Homebrew Services]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot中推断main方法所在类名的方法]]></title>
    <url>%2F4efb37b0.html</url>
    <content type="text"><![CDATA[刚刚在看spring-boot的源码，偶然发现了spring-boot中推断main()所在类名的处理方法，感觉很巧妙，记录一下。原理就是手工抛一个RuntimeException然后获得这个RuntimeException的StackTraceElement[]，迭代每个StackTraceElement从中找出methodName为main的那一个的className。 1234567891011121314private Class&lt;?&gt; deduceMainApplicationClass() &#123; try &#123; StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) &#123; if ("main".equals(stackTraceElement.getMethodName())) &#123; return Class.forName(stackTraceElement.getClassName()); &#125; &#125; &#125; catch (ClassNotFoundException ex) &#123; // Swallow and continue &#125; return null;&#125;]]></content>
      <tags>
        <tag>源码</tag>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从HashMap控制Node下标界限的方法来理解掩码的概念]]></title>
    <url>%2F9f829116.html</url>
    <content type="text"><![CDATA[背景以前一直对掩码这个概念十分模糊，这两天在学习HashMap的时候，了解到了掩码在工程当中的实际应用，感觉对于掩码这个概念的理解加深了。 HashMap中掩码的应用在HashMap中，节点Node是存放于一个Node[]（节点数组）中的，这个数组会根据loadFactor（装载因子）扩容，并且其capacity（节点数组长度的上限）总会是上一次扩容前capacity的两倍。每个节点都会有一个hash值（散列值），而这个hash可以认为是比较随意的，最起码不会是正好总能落在Node[]的index上下界里的，肯定会有超过Node[]大小范围的值，如果直接用hash当作index来在Node[]存储，必然会造成下标越界，那么，该如何处理这一情况呢？HashMap的作者通过掩码来保证了节点不会在节点数组上下标越界： 1234567891011121314151617181920212223242526假设有一个节点hash值为如下（节点的hash是用专门的方法计算出来的，详情请看HashMap源码）0000000000000000000000001111_1011 //也就是十进制的251，假设当前capacity为16，也就是Node[]的index界限为15,。节点的hash值251已远远超出了15，如果拿这个值作为下标必然会越界HashMap作者使用capacity - 1作为掩码(mask)，那么掩码就是 16 - 1 = 15，也就是二进制的000000000000000000000000000011110000000000000000000000000000_1111 //mask将Node的hash与掩码做逻辑与操作得到的值换成十进制是11，已经在Node[]的index界限范围内了0000000000000000000000001111_1011 //hash&amp;0000000000000000000000000000_1111 //mask￬0000000000000000000000000000_1011 //index通过分析，我们可以看到，在这里，掩码的作用实际上是掩盖掉了被操作数据超过掩码大小范围的部分，其实可以理解为&quot;管中窥豹&quot;，你的视线只能涉及管口范围内的部分，其他部分视线被掩盖住了；也可以理解成去看一个带着面具(mask)的人脸，你只能看到面具没有遮盖的部分（眼睛），其他部分被掩盖住了000000000000000000000000[1111]_1011 //造成hash比Node[]的index界限大的原因是因为hash有方括号标示出来的这四个1（也就是比掩码最高一位1还要靠前的1），所以要让hash能够当作index来用的话，就需要消除掉这四个1[0000000000000000000000000000]_1111 //掩码前面的这些0相当于面具的遮盖部分，后面的4个1就相当于面具中能够露出眼睛的部分掩码中的0位会将被操作数对应位清零（因为0 &amp; 0 = 0 并且 0 &amp; 1 = 0）也就是将被操作数对应位&quot;掩盖&quot;了0000000000000000000000001111&amp;0000000000000000000000000000￬0000000000000000000000000000最终能看到的&quot;面具露出来的部分&quot;就是index（为二进制11，小于Node[]的index界限15）0000000000000000000000000000_1011 总结本次通过学习HashMap中控制Node下标界限的方法，间接地加深了对于掩码概念的理解，就像其英文”mask”原本的意思一样，掩码其实就是被操作数的”面具”。 参考资料Java HashMap工作原理及实现]]></content>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK动态代理实现原理浅析]]></title>
    <url>%2Fbf178159.html</url>
    <content type="text"><![CDATA[关于代理模式代理模式理解起来还是比较简单的。大致可以理解为代理人与被代理人实现同一接口定义的行为，在外部调用者调用定义的行为时，不直接调用代理人的提供的行为，而是调用代理人提供的行为，此时调用者是不会感觉到区别的，因为代理人有着和被代理人的行为定义是相同的，调用者感觉不到区别（也就是实现了同一接口），在代理人的行为中在去调用被代理人的行为，并且可以实现增强。记得前几年有部电影，我觉得其实就很好的诠释了”代理”这个概念，想必看了就明白代理模式是怎么回事了。 更多的不再细说了，这不是本文的重点。我们这次主要是学习动态代理。 关于动态代理上边说的代理模式实际上细分的话，可以分为静态代理和动态代理，在实际编码中，代理模式一般是以动态代理的形式出现的。 JDK动态代理动态代理的实现途径有很多种，比如用JDK动态代理和CGLIB动态代理，本篇文章我们主要关注JDK动态代理。 用法首先了解一下怎样使用。来看一个具体的例子吧： 1234567package com.github.since1986.learn.java.proxy;//定义好行为public interface InterfaceA &#123; String doSomething(String param);&#125; 12345678910//定义好默认实现package com.github.since1986.learn.java.proxy;public class ImplementationA implements InterfaceA &#123; @Override public String doSomething(String param) &#123; return String.format("hello, %s.", param); &#125;&#125; 12345678910111213141516171819202122232425262728package com.github.since1986.learn.java.proxy.dynamic;import com.github.since1986.learn.java.proxy.ImplementationA;import com.github.since1986.learn.java.proxy.InterfaceA;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class DynamicProxyCase &#123; public static void main(String[] args) &#123; //生成代理 InterfaceA proxyA = (InterfaceA) Proxy.newProxyInstance(DynamicProxyCase.class.getClassLoader(), new Class[]&#123;InterfaceA.class&#125;, new InvocationHandler() &#123; //反射调用默认行为（并可在此实现增强） @Override public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException &#123; return method.invoke(new ImplementationA(), args) + " Bye~"; &#125; &#125;); //调用接口定义的行为 System.out.println(proxyA.doSomething("Test")); &#125;&#125; 运行结果： 1hello, Test Bye~. 总结起来，写JDK动态代理一共4步（比把大象装到冰箱里多一步）： 定义行为（也就是接口） 实现一个默认行为（也就是给第1步中定义的接口提供一个默认实现） 实现一个回调方法（在这个回调中调用第2步中的默认行为） 1java.lang.reflect.InvocationHandler#invoke(Object proxy, Method method, Object[] args) throws Throwable; 调用Proxy#newProxyInstance生成代理实例 1java.lang.reflect.Proxy#newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException 原理了解了怎样使用，我们再来看看JDK动态代理是怎么实现的吧。 先看 1java.lang.reflect.Proxy#newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException 这个方法，这个方法是整个动态代理流程的入口点。 在这个方法中会去反射获得我们定义的接口的Class 1234/* * Look up or generate the designated proxy class. */Class&lt;?&gt; cl = getProxyClass0(loader, intfs); //intfs是克隆的参数传进来的interfaces：Class&lt;?&gt;[] intfs = interfaces.clone(); 然后通过这个Class拿到java.lang.reflect.Constructor 1final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); 再通过java.lang.reflect.Constructor的java.lang.reflect.Constructor#newInstance来创建代理的实例并返回，所以我们调用java.lang.reflect.Proxy#newProxyInstance返回的代理实例其实是java.lang.reflect.Constructor#newInstance提供的。 接下来再来看java.lang.reflect.Constructor#newInstance： 1234567ConstructorAccessor ca = constructorAccessor; // read volatileif (ca == null) &#123; ca = acquireConstructorAccessor();&#125;@SuppressWarnings("unchecked")T inst = (T) ca.newInstance(initargs);return inst; 注意这一段，java.lang.reflect.Constructor#newInstance返回的实际上是sun.reflect.ConstructorAccessor#newInstance所返回的 我们再转到sun.reflect.ConstructorAccessor#newInstance，可以看到这个方法是个接口方法 我们打开它其中一个实现sun.reflect.NativeConstructorAccessorImpl，可以看到再往下就是开始操作class文件结构了，我们到此基本上大致了解一部分JDK动态代理的原理了，那就是生成class文件。那么我们如何看到生成的class文件呢？另外前边提到的InvocationHandler在流程中没有出现啊？不用着急，我们一一来。 怎样看到生成的class文件呢？在生成动态代理前设置一个Properties就可以了（这个Properties源码位置在sun.misc.ProxyGenerator#saveGeneratedFiles）：System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);。设置好后，我们可以看到生成的以$开头的class文件： 用idea打开这个class文件看反编译后的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.sun.proxy;import com.github.since1986.learn.java.proxy.InterfaceA;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements InterfaceA &#123; //动态生成的代理类，实现了我们定义的接口 private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final String doSomething(String var1) throws &#123; //我们定义的行为（接口方法） try &#123; return (String)super.h.invoke(this, m3, new Object[]&#123;var1&#125;); //注意这里 &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object")); m2 = Class.forName("java.lang.Object").getMethod("toString"); m3 = Class.forName("com.github.since1986.learn.java.proxy.InterfaceA").getMethod("doSomething", Class.forName("java.lang.String")); m0 = Class.forName("java.lang.Object").getMethod("hashCode"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 注意上边代码doSomething方法中这一段： 1return (String)super.h.invoke(this, m3, new Object[]&#123;var1&#125;); 这里面的super.h是java.lang.reflect.Proxy#h这个属性： 12345/** * the invocation handler for this proxy instance. * @serial */protected InvocationHandler h; 也就是说InvocationHandler是被插入到了生成的class文件中的。我们继续看h.invoke(this, m3, new Object[]{var1});，在这个调用中传入的参数，第一个this就是当前生成的$Proxy0的实例，第二个参数m3实际上就是我们定义的接口方法 1m3 = Class.forName("com.github.since1986.learn.java.proxy.InterfaceA").getMethod("doSomething", Class.forName("java.lang.String")); 第三个参数是被传入的被调用的接口方法的实际参数。这个h.invoke就是前面我们提到的那个java.lang.reflect.InvocationHandler的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Processes a method invocation on a proxy instance and returns * the result. This method will be invoked on an invocation handler * when a method is invoked on a proxy instance that it is * associated with. * * @param proxy the proxy instance that the method was invoked on * * @param method the &#123;@code Method&#125; instance corresponding to * the interface method invoked on the proxy instance. The declaring * class of the &#123;@code Method&#125; object will be the interface that * the method was declared in, which may be a superinterface of the * proxy interface that the proxy class inherits the method through. * * @param args an array of objects containing the values of the * arguments passed in the method invocation on the proxy instance, * or &#123;@code null&#125; if interface method takes no arguments. * Arguments of primitive types are wrapped in instances of the * appropriate primitive wrapper class, such as * &#123;@code java.lang.Integer&#125; or &#123;@code java.lang.Boolean&#125;. * * @return the value to return from the method invocation on the * proxy instance. If the declared return type of the interface * method is a primitive type, then the value returned by * this method must be an instance of the corresponding primitive * wrapper class; otherwise, it must be a type assignable to the * declared return type. If the value returned by this method is * &#123;@code null&#125; and the interface method's return type is * primitive, then a &#123;@code NullPointerException&#125; will be * thrown by the method invocation on the proxy instance. If the * value returned by this method is otherwise not compatible with * the interface method's declared return type as described above, * a &#123;@code ClassCastException&#125; will be thrown by the method * invocation on the proxy instance. * * @throws Throwable the exception to throw from the method * invocation on the proxy instance. The exception's type must be * assignable either to any of the exception types declared in the * &#123;@code throws&#125; clause of the interface method or to the * unchecked exception types &#123;@code java.lang.RuntimeException&#125; * or &#123;@code java.lang.Error&#125;. If a checked exception is * thrown by this method that is not assignable to any of the * exception types declared in the &#123;@code throws&#125; clause of * the interface method, then an * &#123;@link UndeclaredThrowableException&#125; containing the * exception that was thrown by this method will be thrown by the * method invocation on the proxy instance. * * @see UndeclaredThrowableException */public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; 就是在这个方法中，我们调用了实际的默认实现，并实现了对默认实现的增强： 12345//反射调用默认行为（并可在此实现增强）@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException &#123; return method.invoke(new ImplementationA(), args) + " Bye~";&#125; 可以看到实际上这个方法中的3个参数Object proxy, Method method, Object[] args就是$Proxy0通过h.invoke(this, m3, new Object[]{var1});传递给我们的，也就是说，我们实现的InvocationHandler的 1public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; 实际上是一个回调，也就是我们预先定义好的，然后JDK生成的类$Proxy0回过来调用的。到这里，整个流程基本上就清楚了，总结一下：JDK动态代理的基本原理就是 我们定义好接口和默认实现，JDK根据通过生成class文件的方式”动态”的生成一个代理类，这个代理类实现了我们定义的接口，并在接口实现方法中回调了我们通过InvocationHandler定义的处理流程，这个处理流程中我们回去调用默认实现，并提供增强。 总结在本篇文章中我们通过一个例子了解了JDK动态代理的使用方法，并且通过源码大致了解了JDK动态代理的浅层实现原理，其实，在我们日常实用的框架中会经常用到JDK动态代理（例如MyBatis），我们平常也可以留心注意一下，JDK动态代理还是很实用的。 参考资料从JVM中dump出动态代理生成的class]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个双向链表的倒置功能（1->2->3 变成 3->2->1）]]></title>
    <url>%2F17c527fd.html</url>
    <content type="text"><![CDATA[背景这两天花了些时间研究了一道题目，把解题的思维过程记录一下。原题目如下： 实现一个双向链表的倒置功能（1-&gt;2-&gt;3 变成 3-&gt;2-&gt;1），请勿直接使用JDK的LinkedList。 解题拆题拿到这个题目后，第一感觉网上有这个题，当然，不能一上来就去搜答案，这类题旨在考验程序员的问题分析能力的，直接看了答案就没有意义了。先自己去想，实在有的点卡住了，再去搜索一些思路。而且也只去看资料中关于卡主这部分的内容，不要全篇看，以自己的思考为主。 然后我们开始分析。要想解题，首先要明白这个题是想让我们做什么。很明显，这个题包含了两个要点： 实现倒置（结果） 实现双向链表数据结构（结果依赖的前提） 实现倒置是结果，实现双向链表数据结构是依赖，那么我们从结果开始思考，将得出结果的逻辑抽象出来，然后再慢慢反推依赖。 纸笔分析这类题有个特点，第一眼看上去会比较懵逼，生在脑子里想也比较累，所以我们可以在纸端辅助思考，用文字来捋顺自己的思路： 上图中是我的最初始的分析思路，当然，到后期编码实现时，会发现其中的step3其实是不全面的，没关系，在纸和笔分析阶段我们要写的是最直接的思路，后期会不断优化。 编码实现在编码阶段，我是与思考阶段反着来的，我先实现了依赖，也就是先实现双向链表这个数据结构 那么，代码从哪里写起呢？我是从接口开始的，因为很明显，在JDK的标准库里，都是从接口开始的，接口对消费端提供了行为的定义。很明显，作为一个最基本的线性表应当有删增改查四个方法，然后对于双向的表来说，应当有getFirst和getLast，所以，最基本的两个接口就有了。 12345678910111213141516171819package com.github.since1986.learn.collection;/** * 线性表 */public interface List&lt;E&gt; &#123; void add(E element); void add(int index, E element); E get(int index); void remove(E element); void remove(int index); int size();&#125; 1234567891011package com.github.since1986.learn.collection;/** * 双向表 */public interface Deque&lt;E&gt; extends List&lt;E&gt; &#123; E getFirst(); E getLast();&#125; 然后我们的双向链表LinkedList应当实现双向表Deque 1public class LinkedList&lt;E&gt; implements Deque&lt;E&gt; 然后再思考，我应当怎样存储双线链表中的节点呢，在这里，我其实第一开始思路有点跑偏了，由于原来我看过JDK中的ArrayList的代码，所以我总是想是不是用一个数组来存储，但是后来越想越觉得别扭，索性打开了JDK的LinkedList的代码，看了一眼，恍然大悟，其实定义一个内部的类Node，Node中包含了指向next和previous的引用，这个引用本身就构成了一个链式的结构。OK了，数据结构搞定。 1234567891011121314//核心数据结构（不对外包暴露）static class Node&lt;E&gt; &#123; private Node&lt;E&gt; previous; private Node&lt;E&gt; next; E element; Node(Node&lt;E&gt; previous, Node&lt;E&gt; next, E element) &#123; this.previous = previous; this.next = next; this.element = element; &#125;&#125; 注意一点，这个数据结构不应被LinkedList的消费者看到，保持内聚性。 然后我们来实现add，有了add我们就能够添加测试数据了，其他有几个方法和题目无关，我们可以先放着不实现。 1234567891011@Overridepublic void add(E element) &#123; if (size == 0) &#123; //假如当前的size == 0，那么就让当前add进来的元素，生成节点成为first节点和last节点 first = last = new Node&lt;&gt;(null, null, element); &#125; else &#123; //否则向last节点后添加一个新的节点（也就是生成一个新节点，将last节点的next指向这个新节点），让后让新的节点成为last就可以了 Node&lt;E&gt; newLast = new Node&lt;&gt;(last, null, element); last.next = newLast; last = newLast; &#125; size++;&#125; 再来实现get以及其依赖的getNode 12345678910111213141516171819private Node&lt;E&gt; getNode(int index) &#123; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IndexOutOfBoundsException(); &#125; else if (size == 0) &#123; //如果当前size == 0则返回null return null; &#125; else if (index &lt; size / 2) &#123; //如果index处于list的前半部分（也就是index &lt; size / 2）那么就从first节点开始向后找 Node&lt;E&gt; temp = first; for (int i = 0; i &lt; index; i++) &#123; temp = temp.next; &#125; return temp; &#125; else &#123; //否则，从last节点开始向前找 Node&lt;E&gt; temp = last; for (int i = size - 1; i &gt; index; i--) &#123; temp = temp.previous; &#125; return temp; &#125;&#125; 1234@Overridepublic E get(int index) &#123; return getNode(index) == null ? null : getNode(index).element;&#125; 到这里，基本的数据结构算是实现了，我们来看一眼完整的LinkedList代码吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140package com.github.since1986.learn.collection;/** * （双向）链表 */public class LinkedList&lt;E&gt; implements Deque&lt;E&gt; &#123; private int size; private Node&lt;E&gt; first; private Node&lt;E&gt; last; @Override public void add(E element) &#123; if (size == 0) &#123; //假如当前的size == 0，那么就让当前add进来的元素，生成节点成为first节点和last节点 first = last = new Node&lt;&gt;(null, null, element); &#125; else &#123; //否则向last节点后添加一个新的节点（也就是生成一个新节点，将last节点的next指向这个新节点），让后让新的节点成为last就可以了 Node&lt;E&gt; newLast = new Node&lt;&gt;(last, null, element); last.next = newLast; last = newLast; &#125; size++; &#125; @Override public void add(int index, E element) &#123; //TODO 与题目无关，暂不实现 &#125; @Override public E get(int index) &#123; return getNode(index) == null ? null : getNode(index).element; &#125; @Override public void remove(E element) &#123; //TODO 与题目无关，暂不实现 &#125; @Override public void remove(int index) &#123; //TODO 与题目无关，暂不实现 &#125; @Override public int size() &#123; return size; &#125; @Override public E getFirst() &#123; return getFirstNode().element; &#125; @Override public E getLast() &#123; return getLastNode().element; &#125; //核心数据结构（不对外包暴露） static class Node&lt;E&gt; &#123; private Node&lt;E&gt; previous; private Node&lt;E&gt; next; E element; Node(Node&lt;E&gt; previous, Node&lt;E&gt; next, E element) &#123; this.previous = previous; this.next = next; this.element = element; &#125; Node&lt;E&gt; getPrevious() &#123; return previous; &#125; void setPrevious(Node&lt;E&gt; previous) &#123; this.previous = previous; &#125; Node&lt;E&gt; getNext() &#123; return next; &#125; void setNext(Node&lt;E&gt; next) &#123; this.next = next; &#125; &#125; private Node&lt;E&gt; getNode(int index) &#123; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IndexOutOfBoundsException(); &#125; else if (size == 0) &#123; //如果当前size == 0则返回null return null; &#125; else if (index &lt; size / 2) &#123; //如果index处于list的前半部分（也就是index &lt; size / 2）那么就从first节点开始向后找 Node&lt;E&gt; temp = first; for (int i = 0; i &lt; index; i++) &#123; temp = temp.next; &#125; return temp; &#125; else &#123; //否则，从last节点开始向前找 Node&lt;E&gt; temp = last; for (int i = size - 1; i &gt; index; i--) &#123; temp = temp.previous; &#125; return temp; &#125; &#125; Node&lt;E&gt; getFirstNode() &#123; return size == 0 ? null : getNode(0); &#125; Node&lt;E&gt; getLastNode() &#123; return size == 0 ? null : getNode(size - 1); &#125; void setFirstNode(Node&lt;E&gt; first) &#123; this.first = first; &#125; void setLastNode(Node&lt;E&gt; last) &#123; this.last = last; &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append("(null) &lt;-&gt; "); Node&lt;E&gt; node = first; while (node != null) &#123; stringBuilder.append(node.element); stringBuilder.append(" &lt;-&gt; "); node = node.next; &#125; stringBuilder.append("(null)"); return stringBuilder.toString(); &#125;&#125; 实现好了数据结构，我们再来实现算法倒置吧，这才是最终目标。这里注意一点，我们要实现的reverse方法不应在LinkedList中提供，因为在LinkedList语义上，提供这个方法并无意义，reverse更应该是个util类的方法，输入的是一个LinkedList，输出是倒置后的LinkedList。所以我们把这个方法封装在一个工具类里面对消费者代码提供。由于我们的reverse方法要访问LinkedList内部的Node类的API，而Node类访问是包级别的，所以我们的工具类应当同LinkedList在同一个包下定义。 来看具体代码吧，算法实现的思路写在注释里了： 123456789101112131415161718192021222324252627282930313233343536package com.github.since1986.learn.collection;public final class LinkedListUtils &#123; /* * 倒置（根据高内聚的原则，这个API不应由LinkedList本身提供，因为倒置是要操作LinkedList内部API Node的，这个Node对消费者应当是不可见的，所以用了一个与LinkedList同一个包的Utils类来操作，这样就对外掩藏了Node这个API） * 分为两个步骤： * 第一步 交换每个节点的previous和next * 第二步 交换LinkedList的first和last */ public static &lt;E&gt; LinkedList&lt;E&gt; reverse(LinkedList&lt;E&gt; linkedList) &#123; //保存原首尾节点信息，用于交换每个节点的previous和next后将LinkedList的first和last进行交换 LinkedList.Node&lt;E&gt; originalFirstNode = linkedList.getFirstNode(); LinkedList.Node&lt;E&gt; originalLastNode = linkedList.getLastNode(); //交换每个节点的previous和next LinkedList.Node&lt;E&gt; originalOrderCurrentNode = originalFirstNode; //按照原顺序循环 while (originalOrderCurrentNode != null) &#123; //按照原LinkedList的顺序循环，直至到达null（假如原LinkedList为 (null) &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; 4 &lt;-&gt; (null) 那么也就是按 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; (null) 这样来循环，其中4后面的(null)为循环终止条件） LinkedList.Node&lt;E&gt; originalPrevious = originalOrderCurrentNode.getPrevious(); //获得当前node的原previous LinkedList.Node&lt;E&gt; originalNext = originalOrderCurrentNode.getNext(); //获得当前node的原next LinkedList.Node&lt;E&gt; tempReference = originalOrderCurrentNode; //新建一个引用，后续的previous和next的交换在新引用上进行，不影响原LinkedList的节点，这样才能让while循环能够继续（可以想象一下，如果直接在原节点上交换，假如当前由1节点循环到了2个节点 那么 1 -&gt; 2 -&gt; 3交换后就变成了 3 -&gt; 2 -&gt; 1 ，循环的下一次等于还是1，就重复了，就不是原顺序在循环了，逻辑上是不对的） originalOrderCurrentNode = originalNext; //让循环继续到下一节点 tempReference.setPrevious(originalNext); //将当前node的previous设置为原来的next tempReference.setNext(originalPrevious); //将当前node的next设置为原来的previous &#125; //交换LinkedList的first和last linkedList.setFirstNode(originalLastNode); linkedList.setLastNode(originalFirstNode); return linkedList; &#125;&#125; 在实现倒置时，我在怎样让while循环能够继续这里卡住了，怎么想也想不通，后来看了看这篇文章中这段代码： 12345678910public DListNode reverse(DListNode head) &#123; DListNode curr = null; while (head != null) &#123; curr = head; head = curr.next; curr.next = curr.prev; curr.prev = head; &#125; return curr;&#125; 才明白了，其实用一个中间引用就好了。另外在前面纸笔分析处我们提到了，纸笔分析中的step3并不全面，其实是少了： 123//交换LinkedList的first和lastlinkedList.setFirstNode(originalLastNode);linkedList.setLastNode(originalFirstNode); 这一环节，没有这一环节倒置后每个Node虽然是正确的，但是首尾节点并不正确，后来我才想明白，实际上首尾对调后才算完成了整个链表的倒置。 好，到了这里，基本上题目就解完了。整体工程在我的GitHub里。 总结通过这个题目，锻炼了一下自己思考/分析/解决问题的能力，同时也对JDK中的LinkedList加深了理解. 参考资料Java标准库的LinkedList源码 Linked List - 链表]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于面向对象]]></title>
    <url>%2F75636f49.html</url>
    <content type="text"><![CDATA[关于”面向对象”最著名的一句话可能就是”万物皆对象了”，当然，这是一句”正确的废话”。实际上我们大可以逆向思维，想象一下，如果没有了”对象”的概念，你会怎么做。比如要实现复用，我能想到的，最直接的办法是将过程封装到文件里，以某种方式导入文件来复用，那还真不如有个”对象”这个概念呢，我想”面向对象”应当是过程式范式发展到一定的程度有了需求自然而然产生了，一切都是为了解决问题而生的。我猜想应当是这样的，需求是创造性的源泉。]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList扩容规则的关键代码]]></title>
    <url>%2Fdd047d82.html</url>
    <content type="text"><![CDATA[看了看ArrayList中扩容处理的代码。感觉写的还是很有意思的。 扩容处理处，传入想要增长到的大小（也就是当前实际容量大小 + 1），然后获得原承载数组容量上限大小；再将新的承载数组容量上限大小 = 原承载数组容量上限大小 + (原承载数组容量上限大小 / 2)，其实也就是让新承载数组容量上限大小变为原承载数组容量上限大小的1.5倍。如果新承载数组容量上限大小比想要增长到的大小（也就是当前实际容量大小 + 1）要小（出现这种情况因为addAll方法有可能一次性放很多值进来，数量多到了超过了 原承载数组容量上限 * 1.5），则让新承载数组容量上限大小 = 想要增长到的大小；如果新承载数组容量上限大小比规定的最高上限还要大（有可能通过addAll放入了巨量的数据），那么就走超大处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! 将想要增长到的大小（也就是当前实际容量大小 + 1）传入 确保容量足够处理 的过程 elementData[size++] = e; return true;&#125;/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125;//确保容量足够处理过程private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //如果想要增长到的大小（也就是当前实际容量大小 + 1）已经大于承载数组容量上限了 grow(minCapacity); //则进行扩容&#125;/** * 进行扩容 * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; //传入想要增长到的大小（也就是当前实际容量大小 + 1） // overflow-conscious code int oldCapacity = elementData.length; //获得原承载数组容量上限大小 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //新的承载数组容量上限大小 = 原承载数组容量上限大小 + (原承载数组容量上限大小 / 2)，其实也就是让新承载数组容量上限大小变为原承载数组容量上限大小的1.5倍 （注意：右移一位相当于除2） if (newCapacity - minCapacity &lt; 0) //如果新承载数组容量上限大小比想要增长到的大小（也就是当前实际容量大小 + 1）要小（出现这种情况因为addAll方法有可能一次性放很多值进来，数量多到了超过了 原承载数组容量上限 * 1.5） newCapacity = minCapacity; //则让新承载数组容量上限大小 = 想要增长到的大小 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //如果新承载数组容量上限大小比规定的最高上限还要大（有可能通过addAll放入了巨量的数据） newCapacity = hugeCapacity(minCapacity); //那么就走超大处理 // minCapacity is usually close to size, so this is a win: //一般来说想要增长到的大小会与原来承载数组中实际数据的size接近，也就极端情况一次性addAll大量数据的情况并不常见 elementData = Arrays.copyOf(elementData, newCapacity); //将老的承载数组按照刚才生成的上限复制成一个新的承载数组&#125;]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发现了一篇很通俗易懂的讲解聚集索引与非聚集索引的文章]]></title>
    <url>%2F9e5f69ef.html</url>
    <content type="text"><![CDATA[来自“日新阁”的一篇文章，作者写的很形象，很易懂。 聚集索引和非聚集索引的区别: 汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。 如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。 我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。 通过以上例子，我们可以理解到什么是“聚集索引”和“非聚集索引”。 进一步引申一下，我们可以很容易的理解：每个表只能有一个聚集索引，因为目录只能按照一种方法进行排序。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决hexo local search的XML Parsing Error: not well-formed异常]]></title>
    <url>%2Fb73920ad.html</url>
    <content type="text"><![CDATA[如果你的hexo的local search出现了： 1XML Parsing Error: not well-formed 请尝试这样解决： 用WebStorm打开你的blog代码，replace in path 勾选 Regex，替换\u0008为空 用Firefox打开local search测试，若还报同样异常，通过Firefox控制台定位到search.xml文件出错处，放大屏幕查看出错出方块乱码内的Unicode编码是多少记下来 用WebStorm打开你的blog代码，replace in path 勾选 Regex，替换刚才记下的Unicode为空 hexo clean hexo g 重新生成，再次测试 反复步骤2-4，直至成功 Ps. 推荐大家用 WebStorm或idea来写博客，功能强大。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Graph Easy画流程图]]></title>
    <url>%2F47b22367.html</url>
    <content type="text"><![CDATA[WhatGraph Easy是什么？是一个用来生成ASCIIFlow的工具，也就是用文本来”写”流程图的工具。 Why我用流程图软件一样能画流程图，为什么要用Graph Easy？反问自己：流程图软件出的图能贴到代码注释里吗？ How安装1234567#shellbrew install graphvizcpansudo cpan Graph:Easy 使用123456789echo '[A] --&gt; &#123;start: front,0;&#125; [A1],[A2]' | graph-easy输出+---+ +----+| A | -+-----&gt; | A1 |+---+ | +----+ | +----+ +-----&gt; | A2 | +----+ 详细用法见官方文档 解决中文错位见用 Ascii 画关系图 参考资料推荐一个制作「ASCII 流程图」工具——Graph Easy graph-easy-cn · GitBook 使用Graph Easy来做炫酷的Ascii字符图 用 Ascii 画关系图]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring内置的AOP工具]]></title>
    <url>%2F8862452.html</url>
    <content type="text"><![CDATA[Spring 内置了一个 AOP 工具类，提供了很多实用的方法，比如判断当前 class 是不是 AOP class ，或者直接进行反射调用，等等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349/* * Copyright 2002-2016 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.aop.support;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.lang.reflect.Proxy;import java.util.LinkedHashSet;import java.util.LinkedList;import java.util.List;import java.util.Set;import org.springframework.aop.Advisor;import org.springframework.aop.AopInvocationException;import org.springframework.aop.IntroductionAdvisor;import org.springframework.aop.IntroductionAwareMethodMatcher;import org.springframework.aop.MethodMatcher;import org.springframework.aop.Pointcut;import org.springframework.aop.PointcutAdvisor;import org.springframework.aop.SpringProxy;import org.springframework.aop.TargetClassAware;import org.springframework.core.BridgeMethodResolver;import org.springframework.core.MethodIntrospector;import org.springframework.util.Assert;import org.springframework.util.ClassUtils;import org.springframework.util.ReflectionUtils;/** * Utility methods for AOP support code. * * &lt;p&gt;Mainly for internal use within Spring's AOP support. * * &lt;p&gt;See &#123;@link org.springframework.aop.framework.AopProxyUtils&#125; for a * collection of framework-specific AOP utility methods which depend * on internals of Spring's AOP framework implementation. * * @author Rod Johnson * @author Juergen Hoeller * @author Rob Harrop * @see org.springframework.aop.framework.AopProxyUtils */public abstract class AopUtils &#123; /** * Check whether the given object is a JDK dynamic proxy or a CGLIB proxy. * &lt;p&gt;This method additionally checks if the given object is an instance * of &#123;@link SpringProxy&#125;. * @param object the object to check * @see #isJdkDynamicProxy * @see #isCglibProxy */ public static boolean isAopProxy(Object object) &#123; return (object instanceof SpringProxy &amp;&amp; (Proxy.isProxyClass(object.getClass()) || ClassUtils.isCglibProxyClass(object.getClass()))); &#125; /** * Check whether the given object is a JDK dynamic proxy. * &lt;p&gt;This method goes beyond the implementation of * &#123;@link Proxy#isProxyClass(Class)&#125; by additionally checking if the * given object is an instance of &#123;@link SpringProxy&#125;. * @param object the object to check * @see java.lang.reflect.Proxy#isProxyClass */ public static boolean isJdkDynamicProxy(Object object) &#123; return (object instanceof SpringProxy &amp;&amp; Proxy.isProxyClass(object.getClass())); &#125; /** * Check whether the given object is a CGLIB proxy. * &lt;p&gt;This method goes beyond the implementation of * &#123;@link ClassUtils#isCglibProxy(Object)&#125; by additionally checking if * the given object is an instance of &#123;@link SpringProxy&#125;. * @param object the object to check * @see ClassUtils#isCglibProxy(Object) */ public static boolean isCglibProxy(Object object) &#123; return (object instanceof SpringProxy &amp;&amp; ClassUtils.isCglibProxy(object)); &#125; /** * Determine the target class of the given bean instance which might be an AOP proxy. * &lt;p&gt;Returns the target class for an AOP proxy or the plain class otherwise. * @param candidate the instance to check (might be an AOP proxy) * @return the target class (or the plain class of the given object as fallback; * never &#123;@code null&#125;) * @see org.springframework.aop.TargetClassAware#getTargetClass() * @see org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object) */ public static Class&lt;?&gt; getTargetClass(Object candidate) &#123; Assert.notNull(candidate, "Candidate object must not be null"); Class&lt;?&gt; result = null; if (candidate instanceof TargetClassAware) &#123; result = ((TargetClassAware) candidate).getTargetClass(); &#125; if (result == null) &#123; result = (isCglibProxy(candidate) ? candidate.getClass().getSuperclass() : candidate.getClass()); &#125; return result; &#125; /** * Select an invocable method on the target type: either the given method itself * if actually exposed on the target type, or otherwise a corresponding method * on one of the target type's interfaces or on the target type itself. * @param method the method to check * @param targetType the target type to search methods on (typically an AOP proxy) * @return a corresponding invocable method on the target type * @throws IllegalStateException if the given method is not invocable on the given * target type (typically due to a proxy mismatch) * @since 4.3 * @see MethodIntrospector#selectInvocableMethod(Method, Class) */ public static Method selectInvocableMethod(Method method, Class&lt;?&gt; targetType) &#123; Method methodToUse = MethodIntrospector.selectInvocableMethod(method, targetType); if (Modifier.isPrivate(methodToUse.getModifiers()) &amp;&amp; !Modifier.isStatic(methodToUse.getModifiers()) &amp;&amp; SpringProxy.class.isAssignableFrom(targetType)) &#123; throw new IllegalStateException(String.format( "Need to invoke method '%s' found on proxy for target class '%s' but cannot " + "be delegated to target bean. Switch its visibility to package or protected.", method.getName(), method.getDeclaringClass().getSimpleName())); &#125; return methodToUse; &#125; /** * Determine whether the given method is an "equals" method. * @see java.lang.Object#equals */ public static boolean isEqualsMethod(Method method) &#123; return ReflectionUtils.isEqualsMethod(method); &#125; /** * Determine whether the given method is a "hashCode" method. * @see java.lang.Object#hashCode */ public static boolean isHashCodeMethod(Method method) &#123; return ReflectionUtils.isHashCodeMethod(method); &#125; /** * Determine whether the given method is a "toString" method. * @see java.lang.Object#toString() */ public static boolean isToStringMethod(Method method) &#123; return ReflectionUtils.isToStringMethod(method); &#125; /** * Determine whether the given method is a "finalize" method. * @see java.lang.Object#finalize() */ public static boolean isFinalizeMethod(Method method) &#123; return (method != null &amp;&amp; method.getName().equals("finalize") &amp;&amp; method.getParameterTypes().length == 0); &#125; /** * Given a method, which may come from an interface, and a target class used * in the current AOP invocation, find the corresponding target method if there * is one. E.g. the method may be &#123;@code IFoo.bar()&#125; and the target class * may be &#123;@code DefaultFoo&#125;. In this case, the method may be * &#123;@code DefaultFoo.bar()&#125;. This enables attributes on that method to be found. * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; In contrast to &#123;@link org.springframework.util.ClassUtils#getMostSpecificMethod&#125;, * this method resolves Java 5 bridge methods in order to retrieve attributes * from the &lt;i&gt;original&lt;/i&gt; method definition. * @param method the method to be invoked, which may come from an interface * @param targetClass the target class for the current invocation. * May be &#123;@code null&#125; or may not even implement the method. * @return the specific target method, or the original method if the * &#123;@code targetClass&#125; doesn't implement it or is &#123;@code null&#125; * @see org.springframework.util.ClassUtils#getMostSpecificMethod */ public static Method getMostSpecificMethod(Method method, Class&lt;?&gt; targetClass) &#123; Method resolvedMethod = ClassUtils.getMostSpecificMethod(method, targetClass); // If we are dealing with method with generic parameters, find the original method. return BridgeMethodResolver.findBridgedMethod(resolvedMethod); &#125; /** * Can the given pointcut apply at all on the given class? * &lt;p&gt;This is an important test as it can be used to optimize * out a pointcut for a class. * @param pc the static or dynamic pointcut to check * @param targetClass the class to test * @return whether the pointcut can apply on any method */ public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass) &#123; return canApply(pc, targetClass, false); &#125; /** * Can the given pointcut apply at all on the given class? * &lt;p&gt;This is an important test as it can be used to optimize * out a pointcut for a class. * @param pc the static or dynamic pointcut to check * @param targetClass the class to test * @param hasIntroductions whether or not the advisor chain * for this bean includes any introductions * @return whether the pointcut can apply on any method */ public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123; Assert.notNull(pc, "Pointcut must not be null"); if (!pc.getClassFilter().matches(targetClass)) &#123; return false; &#125; MethodMatcher methodMatcher = pc.getMethodMatcher(); if (methodMatcher == MethodMatcher.TRUE) &#123; // No need to iterate the methods if we're matching any method anyway... return true; &#125; IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null; if (methodMatcher instanceof IntroductionAwareMethodMatcher) &#123; introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher; &#125; Set&lt;Class&lt;?&gt;&gt; classes = new LinkedHashSet&lt;Class&lt;?&gt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass)); classes.add(targetClass); for (Class&lt;?&gt; clazz : classes) &#123; Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz); for (Method method : methods) &#123; if ((introductionAwareMethodMatcher != null &amp;&amp; introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) || methodMatcher.matches(method, targetClass)) &#123; return true; &#125; &#125; &#125; return false; &#125; /** * Can the given advisor apply at all on the given class? * This is an important test as it can be used to optimize * out a advisor for a class. * @param advisor the advisor to check * @param targetClass class we're testing * @return whether the pointcut can apply on any method */ public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass) &#123; return canApply(advisor, targetClass, false); &#125; /** * Can the given advisor apply at all on the given class? * &lt;p&gt;This is an important test as it can be used to optimize out a advisor for a class. * This version also takes into account introductions (for IntroductionAwareMethodMatchers). * @param advisor the advisor to check * @param targetClass class we're testing * @param hasIntroductions whether or not the advisor chain for this bean includes * any introductions * @return whether the pointcut can apply on any method */ public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123; if (advisor instanceof IntroductionAdvisor) &#123; return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass); &#125; else if (advisor instanceof PointcutAdvisor) &#123; PointcutAdvisor pca = (PointcutAdvisor) advisor; return canApply(pca.getPointcut(), targetClass, hasIntroductions); &#125; else &#123; // It doesn't have a pointcut so we assume it applies. return true; &#125; &#125; /** * Determine the sublist of the &#123;@code candidateAdvisors&#125; list * that is applicable to the given class. * @param candidateAdvisors the Advisors to evaluate * @param clazz the target class * @return sublist of Advisors that can apply to an object of the given class * (may be the incoming List as-is) */ public static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) &#123; if (candidateAdvisors.isEmpty()) &#123; return candidateAdvisors; &#125; List&lt;Advisor&gt; eligibleAdvisors = new LinkedList&lt;Advisor&gt;(); for (Advisor candidate : candidateAdvisors) &#123; if (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123; eligibleAdvisors.add(candidate); &#125; &#125; boolean hasIntroductions = !eligibleAdvisors.isEmpty(); for (Advisor candidate : candidateAdvisors) &#123; if (candidate instanceof IntroductionAdvisor) &#123; // already processed continue; &#125; if (canApply(candidate, clazz, hasIntroductions)) &#123; eligibleAdvisors.add(candidate); &#125; &#125; return eligibleAdvisors; &#125; /** * Invoke the given target via reflection, as part of an AOP method invocation. * @param target the target object * @param method the method to invoke * @param args the arguments for the method * @return the invocation result, if any * @throws Throwable if thrown by the target method * @throws org.springframework.aop.AopInvocationException in case of a reflection error */ public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) throws Throwable &#123; // Use reflection to invoke the method. try &#123; ReflectionUtils.makeAccessible(method); return method.invoke(target, args); &#125; catch (InvocationTargetException ex) &#123; // Invoked method threw a checked exception. // We must rethrow it. The client won't see the interceptor. throw ex.getTargetException(); &#125; catch (IllegalArgumentException ex) &#123; throw new AopInvocationException("AOP configuration seems to be invalid: tried calling method [" + method + "] on target [" + target + "]", ex); &#125; catch (IllegalAccessException ex) &#123; throw new AopInvocationException("Could not access method [" + method + "]", ex); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homebrew安装、启动、停止NGINX]]></title>
    <url>%2Fffce7a36.html</url>
    <content type="text"><![CDATA[12345678#安装brew install nginx#启动brew services start nginx#停止brew services stop nginx]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud与微服务学习笔记-服务调用（上）]]></title>
    <url>%2Ffe76b270.html</url>
    <content type="text"><![CDATA[前言在上一篇文章「Spring Cloud与微服务学习笔记-注册与发现」中，我们知道了怎样发现服务。既然已经发现了服务，那么接下来就轮到去调用了。服务调用会分为上、下两篇文章，在上篇中，我们来学习Spring Cloud服务调用的基本操作和基本概念，在下篇中我们会进一步深入分析Spring Cloud实现服务调用的原理。 例子关于服务调用，没有太多新的概念需要理解，因此，我们直接先来从实践入手，写一个小例子，在这个例子里我们会负载均衡的从一个服务去调用另一个服务。通过这个例子我们可以体验一下在Spring Cloud平台下进行服务调用的过程。（例子全部代码在我的Github上） 仍然像上篇文章中一样，我们来建立一个多模块的Gradle工程，分为3个模块：eureka-server、service-a、service-b。工程结构和前篇文章中的例子工程基本一致：eureka-server是注册与发现服务器，service-a和service-b是两个服务。但是这一次，我们会让service-a来调用service-b提供的服务。 eureka-server怎样写请参看前篇文章，在此不再复述，我们来写service-a。先来写好配置： 12345//构建配置dependencies &#123; compile group: 'org.springframework.cloud', name: 'spring-cloud-starter-netflix-eureka-client', version: '1.4.0.RELEASE' compile group: 'org.springframework.cloud', name: 'spring-cloud-starter-openfeign', version: '1.4.4.RELEASE'&#125; 12345678910//主配置package com.github.since1986.learn.cloud.service.a;import org.springframework.cloud.netflix.feign.EnableFeignClients;import org.springframework.context.annotation.Configuration;@EnableFeignClients@Configurationpublic class AppConfig &#123;&#125; 1234567891011121314151617181920212223242526#application.ymlspring: profiles: peer1 application: name: com-github-since1986-learn-cloud-service-aserver: port: 8010eureka: client: serviceUrl: defaultZone: http://localhost:8001/eureka/---spring: profiles: peer2 application: name: com-github-since1986-learn-cloud-service-aserver: port: 8011eureka: client: serviceUrl: defaultZone: http://localhost:8001/eureka/ 配置写好后，就可以开始写逻辑了，在service-a中写一个Model、一个Service（Service里有些注解比较陌生，先不用管它是什么意思，后面我们会讲到）和一个Controller： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//Modelpackage com.github.since1986.learn.cloud.service.a;import java.io.Serializable;public class Echo implements Serializable &#123; private long id; private String content; private long timestamp; public Echo() &#123; &#125; private Echo(Builder builder) &#123; setId(builder.id); setContent(builder.content); setTimestamp(builder.timestamp); &#125; public static Builder newBuilder() &#123; return new Builder(); &#125; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public long getTimestamp() &#123; return timestamp; &#125; public void setTimestamp(long timestamp) &#123; this.timestamp = timestamp; &#125; public static final class Builder &#123; private long id; private String content; private long timestamp; private Builder() &#123; &#125; public Builder withId(long id) &#123; this.id = id; return this; &#125; public Builder withContent(String content) &#123; this.content = content; return this; &#125; public Builder withTimestamp(long timestamp) &#123; this.timestamp = timestamp; return this; &#125; public Echo build() &#123; return new Echo(this); &#125; &#125;&#125; 1234567891011121314//Servicepackage com.github.since1986.learn.cloud.service.a;import org.springframework.cloud.netflix.feign.FeignClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;@FeignClient("com-github-since1986-learn-cloud-service-b")public interface B &#123; @RequestMapping(method = RequestMethod.GET, value = "/echo") Echo getEcho(@RequestParam("id") long id, @RequestParam("showTimestamp") boolean showTimestamp);&#125; 12345678910111213141516171819202122232425//Controllerpackage com.github.since1986.learn.cloud.service.a;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RequestMapping("/call")@RestControllerpublic class CallServiceBController &#123; private final B b; @Autowired public CallServiceBController(B b) &#123; this.b = b; &#125; @GetMapping public ResponseEntity get() &#123; return ResponseEntity.ok(b.getEcho(System.nanoTime(), true)); &#125;&#125; service-a到此就写完了，我们再来接着写service-b。service-b与service-a的配置只有application.yml不同。 1234567891011121314151617181920212223242526#application.ymlspring: profiles: peer1 application: name: com-github-since1986-learn-cloud-service-bserver: port: 8020eureka: client: serviceUrl: defaultZone: http://localhost:8001/eureka/---spring: profiles: peer2 application: name: com-github-since1986-learn-cloud-service-bserver: port: 8021eureka: client: serviceUrl: defaultZone: http://localhost:8001/eureka/ 业务： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//Modelpackage com.github.since1986.learn.cloud.service.b;import java.io.Serializable;public class Echo implements Serializable &#123; private long id; private String content; private long timestamp; public Echo() &#123; &#125; private Echo(Builder builder) &#123; setId(builder.id); setContent(builder.content); setTimestamp(builder.timestamp); &#125; public static Builder newBuilder() &#123; return new Builder(); &#125; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public long getTimestamp() &#123; return timestamp; &#125; public void setTimestamp(long timestamp) &#123; this.timestamp = timestamp; &#125; public static final class Builder &#123; private long id; private String content; private long timestamp; private Builder() &#123; &#125; public Builder withId(long id) &#123; this.id = id; return this; &#125; public Builder withContent(String content) &#123; this.content = content; return this; &#125; public Builder withTimestamp(long timestamp) &#123; this.timestamp = timestamp; return this; &#125; public Echo build() &#123; return new Echo(this); &#125; &#125;&#125; 1234567//Service接口package com.github.since1986.learn.cloud.service.b;public interface EchoService &#123; Echo get(long id, boolean showTimestamp);&#125; 12345678910111213141516171819202122232425262728//Service实现package com.github.since1986.learn.cloud.service.b;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Service;@Servicepublic class EchoServiceImpl implements EchoService, ApplicationContextAware &#123; private ApplicationContext applicationContext; @Override public Echo get(long id, boolean showTimestamp) &#123; return Echo .newBuilder() .withId(id) .withContent("当前Profile为：" + applicationContext.getEnvironment().getActiveProfiles()[0]) .withTimestamp(showTimestamp ? System.currentTimeMillis() : -1L) .build(); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125;&#125; 12345678910111213141516171819202122232425//Controllerpackage com.github.since1986.learn.cloud.service.b;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RequestMapping("/echo")@RestControllerpublic class EchoController &#123; private final EchoService echoService; @Autowired public EchoController(EchoService echoService) &#123; this.echoService = echoService; &#125; @GetMapping public ResponseEntity get(long id, boolean showTimestamp) &#123; return ResponseEntity.ok(echoService.get(id, showTimestamp)); &#125;&#125; 大致说明下这个例子： service-a的Controller对外暴露了/call这个地址，并返回Echo service-a的Controller调用B这个Service中的Echo getEcho(@RequestParam(&quot;id&quot;) long id, @RequestParam(&quot;showTimestamp&quot;) boolean showTimestamp);方法，这个getEcho()方法实际上是通过@FeignClient(&quot;com-github-since1986-learn-cloud-service-b&quot;)以及@RequestMapping(method = RequestMethod.GET, value = &quot;/echo&quot;)这两个注解所提供的规则调用服务名为com-github-since1986-learn-cloud-service-b的服务实例提供的路径为/echo的服务 我们看service-b的application.yml中的定义，service-b的服务名就是com-github-since1986-learn-cloud-service-b（同时注意application.yml中的定义，service-b定义有两个节点peer1和peer2，这是为了验证Spring Cloud提供给我们的客户端负载均衡，为了能够看出负载均衡是否生效，我们把被调用的服务service-b的两个节点都启动起来，调用者service-a可以只启一个节点） service-b的Controller暴露了地址为/echo的服务，并且输出Echo 在service-b的/echo调用的本地的Service方法Echo get(long id, boolean showTimestamp);中，我们会将service-b当前激活的profile的名字放在返回的Echo对象的content属性中，这样，我们在service-a调用时，就能知道我们调用的是service-b的哪一个实例了 回过头来整体看一下，其实整个例子就是service-a的/call去负载均衡的调用了service-b提供的/echo 运行这个例子，访问service-a中Controller暴露的地址 /call，查看结果： 可以看到service-a成功调用了service-b中提供的服务，输出了由Echo解码而成的json，并且，如果我们多次运行会发现返回的json结果中&quot;content&quot;属性会在peer1和peer2之间变换，前面说到了这个属性记录的是service-b当前激活的profile，其实也就是标识了当前调用的是service-b的哪个实例（实际上我们也可以直接看响应的header，Spring Cloud已经在其中给我们加上了调用的是哪个实例的标识了：X-Application-Context →com-github-since1986-learn-cloud-service-a:peer1:8010），被调用的实例是变化的，也就是表明了调用时是有负载均衡的。 这个例子我们已经看完了，然后我们来根据例子总结一下在如何在Spring Cloud中做服务调用吧，实际上也非常简单： 调用端与被调用端定义好调用契约，简单的理解就是约定好REST接口的定义 被调用端将服务暴露为REST 调用端写一个interface，并用@FeignClient注解声明为调用客户端，interface中写好具体的调用方法，这个方法通过使用Spring MVC的注解来与定义好的契约做对应 概念实践完了，我们回过头来再来了解一下概念。看前边的例子，会发现，在Spring Cloud中做服务调用只需要写一个interface，加一个注解，就搞定了，而且调用时是支持负载均衡的。整个调用的代码量相当少，对于程序员来说十分便利。实际上这其中的便利是Spring Cloud中的Feign与Ribbon带给我们的，那么Feign和Ribbon都是什么呢？ 先来说Feign。”Feign”，发音为 [feɪn]，意为”捏造”。回想前面实验中的代码，我们在service-a中写了一个interface，然后加上了@FeignClient和@RequestMapping这两个注解，就可以调用service-b中暴露的/echo这个Http API了（在Spring Cloud中，最一般的服务调用是通过REST API的方式来进行的，也就是Http API，所以，不严谨的说，可以把服务调用理解为是Http API调用），在这个过程中，我们根本没写任何Http客户端（诸如URLConnection或者HttpClient）调用的实现，实际上，是Feign给我们用JDK动态代理’捏造’出了这些代码，因此，把Feign理解为”通过interface与注解自动生成Http客户端调用实现的工具”就好了，用官方的话来说就是：”Feign makes writing java http clients easier”，更详细的介绍请看官网。 再来看Ribbon。我们直接来看官网的介绍： Ribbon is a client side IPC library that is battle-tested in cloud. It provides the following features Load balancing Fault tolerance Multiple protocol (HTTP, TCP, UDP) support in an asynchronous and reactive model Caching and batching 简单地说，Ribbon就是一个远程调用工具。它支持负载均衡、容错，支持多种协议，支持异步以及reactive编程模型（RxJava），还支持缓存和batching。也就是说，Spring Cloud服务调用中的负载均衡是Ribbon提供的。 总结在本篇文章中，我们通过一个例子来实践了Spring Cloud中的服务调用，并且了解了一些相关的概念。在下篇文章Spring Cloud与微服务学习笔记-服务调用（下）中我们会深入分析Spring Cloud服务调用背后的原理。]]></content>
      <tags>
        <tag>spring-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次java.lang.NoSuchMethodError的解决]]></title>
    <url>%2Fb99ec4d4.html</url>
    <content type="text"><![CDATA[我的一个项目，线上出现了java.lang.NoSuchMethodError，本地调了一下什么问题也没有，我先重新部署了两遍，未解决，然后问了问领导，领导提示说改个名试试，其实我也想到可能重名了，然后先改了方法名，重新部署，依旧，然后又把类名也改了，这次OK了。事后我想了想，该找出来到底谁重名了，于是把服务器上的lib整个下了下来，放到一个空工程里，double shift搜了一下那个类名，果然是和同事的一个包里的类重名了，哈哈。总结一下其实以后像这种问题最快的解决办法就是直接下载lib然后找出重复就好了。]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用sed、tail、egrep、less在日志中定位异常]]></title>
    <url>%2F20aae457.html</url>
    <content type="text"><![CDATA[静态定位第一步，用sed来初步筛选： 12#sed是按行的，可以支持大日志文件；单引号中是正则：过滤2018-04-08 10开头到2018-04-08 11开头的行，也就是过滤出大致一个小时左右的日志，这样初筛后去掉了大部分噪音 sed -n '/^2018-04-08 10/,/^2018-04-08 11/p' /your/log/file/path 第二步，用egrep二次过滤： 12#egrep是能使用扩展正则的grep | egrep '.*(exception|error|ERROR).*' | egrep 'anthor keyword' 第三步，用less优化显示（less是可以搜索结果高亮的，在less中用/keyword来搜索，用q来退出）： 1| less 连起来： 1sed -n '/^2018-04-08 10/,/^2018-04-08 11/p' /your/log/file/path | egrep '.*(exception|error|ERROR).*' | egrep 'anthor keyword' | less 动态定位第一步，用tail来初步筛选： 12#-f 可以滚动显示追加到文件内的内容，下面的命令是滚动显示目标文件倒数30行tail -n 30 -f /your/log/file/path 第二步：静态定位的一二步任意组合第三步：同静态定位第三步连起来： 123tail -n 30 -f /your/log/file/path | sed -n '/^2018-04-08 10/,/^2018-04-08 | egrep '.*(exception|error|ERROR).*' | egrep 'anthor keyword' 11/p' | less#或者tail -n 30 -f /your/log/file/path | egrep '.*(exception|error|ERROR).*' | egrep 'anthor keyword' 11/p' | less 总结定位日志其实就是用sed、tail、head、cat、egrep、grep、more、less等等这些命令用管道组合起来就好了。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud与微服务学习笔记-注册与发现]]></title>
    <url>%2F17601ed9.html</url>
    <content type="text"><![CDATA[前言在上一篇文章「Spring Cloud与微服务学习笔记-基本概念」中，我们简要介绍了微服务和Spring Cloud的概念。在本篇文章中，我们将介绍微服务中不可或缺的组成部分：服务注册与发现，并且使用Spring Cloud Netflix中的Eureka组件来搭建一组服务注册与发现服务器。 什么是服务注册与发现关于这个问题，咱们来设想一个生活中的场景：小张晚上下班回家，饿了就要饿了么，然后拿起了手机，点开美团外卖软件，从中翻了一翻，在饭店列表中看到了一家新店：“老李肉夹馍”，心想，刚好要吃肉夹馍，就这家吧，下单，等吃；另一边，前不久，老板老李，新开了一家店：老李肉夹馍，老李知道外卖能给自己的店带来生意，于是在外卖平台上注册了自己的店，这几天果然生意兴隆，刚刚老李看到了小明下的单，然后接单，做饭。这个场景中，老张是服务的提供方，而小张是服务的消费方，而老李向外卖平台注册后，小张就能够发现并消费老李提供的服务了，这个外卖平台其实就是提供了“服务注册与发现”。 为什么要有“服务注册与发现”那么，为什么微服务需要服务注册与发现呢？因为没有服务注册与发现会很麻烦的，还是以一个例子来说明吧：平常我们经常会访问各种各样的网站，试想一下，如果访问每一个网站都需要记住很长的一串IP地址的话，那访问起来会有多不方便，况且，网站的IP也不可能自始至终就那莫一个，一旦变化了，难道作为网站的经营者要通知所有忠实的用户新的IP地址是多少吗，好在，我们有DNS这种注册与发现服务，前边说的那些情况，DNS这种注册与发现服务就默默的帮我们处理了。对于微服务也是如此，假如A会消费B的服务，你可以A中硬编码B服务的调用地址的方式来记住调用的路径，但是一旦B的部署环境发生改变，A岂不是也要跟着改，这样变来变去会烦死的，更何况B有可能会有多个实例，A想要消费B就需要从B的众多实例中选出一个来消费，就更不可能用硬编码记住地址这种方式调用了，所以需要有类似于DNS能注册与发现IP地址这样的注册与发现服务来帮助我们去处理这些繁琐的细节。 Eureka那么，在Spring Cloud体系中，是如何实现注册与发现的呢？Spring Cloud复用了现有的解决方案，支持接入三种成熟的注册与发现的解决方案：Zookeeper、Consul和Eureka，这三种解决方案可以按照需要自己选择（Spring Cloud推荐Eureka），并且Spring Cloud提供了统一的接口来屏蔽他们的区别。 由于我们选择了使用Spring Cloud Netflix体系来实现微服务，而Eureka是包含在Spring Cloud Netflix体系中的，所以我们选择使用Eureka来做注册与发现。 Eureka的概念什么是Eureka呢？来看官方的介绍： What is Eureka? Eureka is a REST (Representational State Transfer) based service that is primarily used in the AWS cloud for locating services for the purpose of load balancing and failover of middle-tier servers. We call this service, the Eureka Server. Eureka also comes with a Java-based client component,the Eureka Client, which makes interactions with the service much easier. The client also has a built-in load balancer that does basic round-robin load balancing. At Netflix, a much more sophisticated load balancer wraps Eureka to provide weighted load balancing based on several factors like traffic, resource usage, error conditions etc to provide superior resiliency. 大致的意思是Eureka是基于REST的，主要目的用于AWS云服务（Amazon Web Services）上服务注册与发现、负载均衡和故障转移的中间层服务器。Eureka包含了服务器端和客户端两部分，其中客户端内置了负载均衡。 如何使用Eureka如何使用Eureka呢？如果没有Spring Cloud，我们需要配置好一组Eureka服务器，然后在我们的服务中加入Eureka客户端,然后调用客户端API就行了（可以看官方给的例子）。当然，有了Spring Cloud后，我们不用这么做了，Spring Cloud给Eureka做了一层包装，服务器端可以以Spring Boot程序的形式来跑，而客户端则不需显式调用API了，由Spring Cloud提供了统一的声明式接入的方法接入就可以了。 用Eureka来做服务注册与发现的demo说归说，练归连，想要用的起来，还得实际动手，我们开始吧。我会做两个demo，一个是最基本的单实例eureka server + 单实例service的例子，另一个是多实例eureka server + 多实例service的例子。 单实例eureka server + 单实例service我们来新建一个多模块的Gradle工程，包含3个模块：eureka-sever、service-a、service-b，分别对应了Eureka服务器和两个服务。（全部代码在我的Github上） 先来写Eureka服务器，Spring Cloud对Eureka进行了包装，可以将eureka server做成一个Spring Boot应用，代码如下： 1234//eureka-server模块构建配置dependencies &#123; compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-eureka-server&apos;, version: &apos;1.4.0.RELEASE&apos;&#125; 12345678910111213//eureka-server模块主启动package com.github.since1986.learn.cloud.eureka.server;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(App.class).web(true).run(args); &#125;&#125; 12345678910//eureka-server模块主配置package com.github.since1986.learn.cloud.eureka.server;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;import org.springframework.context.annotation.Configuration;@EnableEurekaServer@Configurationpublic class AppConfig &#123;&#125; 12345678910111213141516# Spring Cloud配置spring: application: name: com-github-since1986-learn-cloud-eureka-server #注意命名要符合RFC 2396，否则会影响服务发现 详见https://stackoverflow.com/questions/37062828/spring-cloud-brixton-rc2-eureka-feign-or-rest-template-configuration-not-worserver: port: 8001eureka: #这里配置eureka相关 instance: hostname: localhost #服务器实例主机名 client: #客户端配置 registerWithEureka: false #由于只有一个服务器实例，我们没必要自己注册自己了 fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 至此，我们已经配置好了一个Eureka服务器的实例，大家注意主配置中的@EnableEurekaServer，在Java中我们只需要加这一个注解就好了，一行代码也不用写，其他的都是starter和application.yml配置中的事了，是不是很方便。 再来看service（我们以service-a为例，service-b与service-a类似，就不复述了） 1234//service-a 构建配置dependencies &#123; compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-netflix-eureka-client&apos;, version: &apos;1.4.0.RELEASE&apos;&#125; 1234567891011121314151617181920212223242526272829303132//service-a主启动package com.github.since1986.learn.cloud.service.a;import com.netflix.appinfo.InstanceInfo;import com.netflix.discovery.EurekaClient;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;import org.springframework.scheduling.annotation.Scheduled;@EnableScheduling@SpringBootApplicationpublic class App &#123; private final EurekaClient eurekaClient; @Autowired public App(EurekaClient eurekaClient) &#123; this.eurekaClient = eurekaClient; &#125; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125; @Scheduled(initialDelay = 1000 * 60 * 3, fixedRate = 1000 * 30) public void printInstanceInfo() &#123; InstanceInfo instanceInfo = eurekaClient.getNextServerFromEureka("com-github-since1986-learn-cloud-service-b", false); System.out.println(String.format("发现了 服务名为 %s IP为 %s 的服务.", instanceInfo.getAppName(), instanceInfo.getIPAddr())); &#125;&#125; 123456789101112#Spring Cloud配置spring: application: name: com-github-since1986-learn-cloud-service-aserver: port: 8002eureka: client: serviceUrl: defaultZone: http://localhost:8001/eureka/ 同样，我们还来看主启动，由于我们想测试一下是否能发现别的服务，所以在住启动文件里，我们写了一些调用EurekaClient来做发现的代码，除去这些代码，实际上作为一个普通service，我们在Java中不用写任何特殊的代码，只要配置好starter和application.yml就自动会注册与发现了，太省心了😆 写好了Eureka服务器和两个service，我们来启动，看一下效果吧，如下图所示我们把三个模块分别建立启动配置： 然后启动，访问我们在application.yml中设置好的Eureka服务器的地址，然后可以看到Spring Cloud为Eureka服务器做的内置的UI，上边可以看到在服务器上注册了哪些service实例。 然后，回过头来，我们来看service-a中我们写的测试服务发现的代码： 12345@Scheduled(initialDelay = 1000 * 60 * 3, fixedRate = 1000 * 30)public void printInstanceInfo() &#123; InstanceInfo instanceInfo = eurekaClient.getNextServerFromEurek("com-github-since1986-learn-cloud-service-b", false); System.out.println(String.format("发现了 服务名为 %s IP为 %s 的服务.", instanceInfo.getAppName(), instanceInfo.getIPAddr()));&#125; 在这段代码中，我们每30秒尝试发现名为com-github-since1986-learn-cloud-service-b的服务的名字和IP，其中com-github-since1986-learn-cloud-service-b是服务service-b在Eureka中注册的名字，如果正确的话，会在标准输出中输出发现的service-b的名字与IP 至此，我们就完成了一个初步的注册与发现了，在Spring Boot/Cloud体系中的注册与发现是不是非常简单啊😜 多实例eureka server + 多实例service完成了单实例的注册与发现，我们再来看一下多实例的（全部代码在我的Github上） 多个实例与单实例只在application.yml中有所不同，其他的代码区别不大，就不贴了，看一下application.yml吧。 eureka-server的application.yml： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647spring: profiles: eureka1 application: name: com-github-since1986-learn-cloud-eureka-server #注意命名要符合RFC 2396，否则会影响服务发现 详见https://stackoverflow.com/questions/37062828/spring-cloud-brixton-rc2-eureka-feign-or-rest-template-configuration-not-worserver: port: 8001eureka: instance: hostname: eureka1 client: serviceUrl: defaultZone: http://eureka2:8002/eureka/,http://eureka3:8003/eureka/ register-with-eureka: true #需要配置这一项才生效（虽然默认这个配置是true，但是可能默认配置被覆盖掉了所以未生效）---spring: profiles: eureka2 application: name: com-github-since1986-learn-cloud-eureka-server #注意命名要符合RFC 2396，否则会影响服务发现 详见https://stackoverflow.com/questions/37062828/spring-cloud-brixton-rc2-eureka-feign-or-rest-template-configuration-not-worserver: port: 8002eureka: instance: hostname: eureka2 client: serviceUrl: defaultZone: http://eureka1:8001/eureka/,http://eureka3:8003/eureka/ register-with-eureka: true #需要配置这一项才生效（虽然默认这个配置是true，但是可能默认配置被覆盖掉了所以未生效）---spring: profiles: eureka3 application: name: com-github-since1986-learn-cloud-eureka-server #注意命名要符合RFC 2396，否则会影响服务发现 详见https://stackoverflow.com/questions/37062828/spring-cloud-brixton-rc2-eureka-feign-or-rest-template-configuration-not-worserver: port: 8003eureka: instance: hostname: eureka3 client: serviceUrl: defaultZone: http://eureka1:8001/eureka/,http://eureka2:8002/eureka/ register-with-eureka: true #需要配置这一项才生效（虽然默认这个配置是true，但是可能默认配置被覆盖掉了所以未生效） 这段配置比较长，仔细看一下，这其实包含了三段类似重复的配置，中间以---分割，并且每一段中都有profiles: eureka&lt;n&gt;这个配置项，这其实是配置了一个Spring Cloud的profile，这个配置文件里有3个profile，实际上也就是配置了3个实例节点，在idea的运行配置中我们选择激活某一个profile，就会启动对用的节点，这样，我们只要配置多个启动项就可以在一套工程里启动3个实力节点了。 然后再来注意每一个profile中defaultZone这一配置项，在多实例的情境下，我们让每一个Eureka服务器都在集群中的其他服务器上注册，集群中的所有服务器会相互同步状态，这样即便一台服务器掉了，还有其他的服务器顶着，这样就保证了注册与发现服务的可用性，这也是我们要配置多实例的原因。 另外还有一点需要注意的，由于咱们是在本地机器上做测试，所以所有Eureka服务器的机器名是相同的，然而要想让多个实例跑起来主机名是不能相同的，参见hostname配置项，这就很矛盾了，但是我们也有办法解决，修改本机的hosts文件就好了，让本机新加出三个不同的host name出来： 1234#hosts配置127.0.0.1 eureka1127.0.0.1 eureka2127.0.0.1 eureka3 做好了这些，3个Eureka服务器实例就可以跑起来了，service-a和service-b也是如法炮制就好了。最后，我们会一共跑起来3*3=9个实例（我的机子内存小，一下跑起来9个实例感觉机子会卡 😅） 启动起来我们照样，看一下Eureka的UI： 可以看到，连上服务器自身，所有service都被注册了上去，同时，3个Eureka实例也是相互备份的：（可以停掉某个服务，然后刷新这个UI看看变化） 我们还可以操作Eureka服务器提供的REST API来手工控制注册与发现.（API列表见官方文档） 调用/eureka/apps可以看到所有注册的服务的信息 同时，我们再来注意测试服务发现的代码，这里略有不同了： 12345678@Scheduled(initialDelay = 1000 * 10, fixedRate = 1000 * 30)public void printInstanceInfo() &#123; List&lt;InstanceInfo&gt; instanceInfos = eurekaClient.getInstancesByVipAddress("com-github-since1986-learn-cloud-service-b", false); instanceInfos.forEach(instanceInfo -&gt; &#123; System.out.printf("发现了 %s: %s \n", instanceInfo.getAppName(), instanceInfo.getIPAddr()); &#125;); System.out.println();&#125; 这回由于是多实例了，所以我们由一个服务注册名能发现多个实例，作为实验，你可以停掉其中某个实例，来看看会有什么变化。 深入了解EurekaEureka为我们的微服务提供了注册与发现服务，大多数情况下，我们只要用就好了，但是，一旦在使用过程中遇到了问题，如果不知道其运作的机理，我们肯定会两眼一抹黑，不知道解决问题的方向。因此，让我们来通过阅读官方文档大致了解一下Eureka运作的机理吧。 Eureka高层架构我们来看官方给出的High level architecture，也就是高层架构（所谓高层架构我理解的就是相对于源码级实现的架构，在逻辑层面的架构）的说明： High level architecture The architecture above depicts how Eureka is deployed at Netflix and this is how you would typically run it. There is one eureka cluster per region which knows only about instances in its region. There is at the least one eureka server per zone to handle zone failures. Services register with Eureka and then send heartbeats to renew their leases every 30 seconds. If the client cannot renew the lease for a few times, it is taken out of the server registry in about 90 seconds. The registration information and the renewals are replicated to all the eureka nodes in the cluster. The clients from any zone can look up the registry information (happens every 30 seconds) to locate their services (which could be in any zone) and make remote calls. 先来看第一段，大致意思是：在每一个region（AWS”区域”）中只跑一个Eureka的cluster（集群），每个region中的Eureka cluster只负责自己region中的instance（实例）（？这一点官方没说的太明白是什么实例，我理解的是”服务实例”），在region中下分的每一个zone（AWS”可用区域”）里至少包含一个eureka server，来保证可用性（因为zone是AWS中保证可用性的单元，也就是说在同一个region下各个zone可用性是相互独立的，一个zone掉线了不会影响另一个zone，这样就保证了可用性）。 在这段官方文档里面出现的region和zone的概念都是AWS中的概念。因为Eureka设计之初就是为了跑在AWS上的，所以会有这些AWS的概念，我们在开发自己的服务时，想必不会跑在AWS上的，也不必过于纠结与具体概念，这一点，Spring Cloud通过提供默认值的方式替我们处理好了，在Spring Cloud的Eureka客户端集成处理中，为region默认设置提供了”us-east-1”这个值，为zone默认提供了了”defaultZone”这个值，也就是说除非你十分需要，否则不再用手动设置region和zone了，用默认值就好了，这也体现了”约定先于配置”的理念（参看源码org.springframework.cloud.netflix.eureka.EurekaClientConfigBean）。如果实在需要保证极高的可用性的话，大可以参照AWS的region和zone的概念来设计架构并且自行配置eureka的region和zone。（在官方给出的架构图实例说明中，只用到了一个region：us-east-1，分为了3个zone：us-east-1c、us-east-1d、us-east-1e，每一个zone上都是一个eureka server实例） 再来看第二段，大致的意思是：服务注册到eureka server上以后，每30秒发送一次心跳以刷新租约，如果发现在90内没有心跳发送了，服务器会注销此服务的注册信息。注册信息每30秒会在eureka server集群中的各个节点复制。另外服务的发现可以跨zone进行。这一段里没有什么晦涩的概念，大致告诉我们了服务注册是以怎样的模式运作的，知道就好了。 了解服务消费端与服务提供端的通讯 How does the application client and application server communicate? The communication technology could be anything you like. Eureka helps you find the information about the services you would want to communicate with but does not impose any restrictions on the protocol or method of communication. For instance, you can use Eureka to obtain the target server address and use protocols such as thrift, http(s) or any other RPC mechanisms. 从上边的官方文档中，我们可以看到：Eureka并不会干预服务之间的通讯协议的选择，随便你用RPC、http还是什么方式，Eureka只管帮一个服务发现想要通讯的另一个目标服务，至于发现之后两者之间怎样建立通讯，Eureka就不管了。 扩展阅读我们在前面做实例时，会发现，Eureka包含了多实例集群的配置启动方式，实际上，在生产环境中，我们一般也不会只跑单实例的，可是，为什么要这样设计呢？是为了预防“单点故障”，那么，“单点故障”是什么呢。 关于“单点故障”single point of failure，（单点故障，缩写SPOF）是指系统中某一部件一旦失效，就会让整个系统都无法运作，换句话说，单点故障即会导致整体故障。其实通俗一点，就是“把所有鸡蛋都放在了一个篮子里”。 那么如何解决“单点故障”问题？“不要把鸡蛋放在一个篮子里”就好了。“一个篮子”就是单点，而一个篮子变成多个篮子就是“冗余”（“replicate”），而冗余则是解决单点问题的核心思路。我们可以回想一下在做demo时，多实例Eureka服务器UI界面中available-replicas，这个就是现实的当前这个服务器的冗余。 总结本篇文章中我们学习了在Spring Cloud中怎样做服务注册与发现，并且以两个demo来实践了一下，在下一篇文章「Spring Cloud与微服务学习笔记-服务调用（上）」中，我们会学习怎样调用已经发现的服务。 参考资料：Spring Cloud技术分析（2）—— 服务治理实践 消除小型 Web 站点单点故障(Single Point of Failure) 单点故障 Understanding eureka client server communication Spring Cloud技术分析（1）——服务治理 有没有什么单词让你心里一动？ 服务注册与发现 基于 Eureka 的服务注册与发现调研 Spring Cloud Eureka — 服务发现 Spring Cloud Eureka：服务注册与发现 Eureka at a glance 深入理解Eureka之源码解析 彩蛋有没有想过，为什么网飞给自己的服务发现与注册组件起名为“Eureka”呢？，一个很文艺的名字。其实这里边是有一个梗的。 Eureka（希腊语：εὕρηκα；拉丁化：Eureka；词义：“我发现了”）据传，阿基米德在洗澡时发现浮力原理，高兴得来不及穿上裤子，跑到街上大喊：“Eureka(我发现了)！”（实际上这个梗是演绎的，真实情况是这样的：The real story behind Archimedes’ Eureka!）。 网飞的开发人员取了这个“发现”的典故来为自己的产品命名，不得不说还挺有才学和浪漫精神的。这里插一句题外话：其实不只是网飞用过“Eureka”这个梗，在前两年的一部影视作品《星际穿越》中也使用了“Eureka”这个桥段，在影片中，墨菲解出了方程式后，挥洒稿纸，激动地喊出了：“Eureka”，感兴趣的同学可以回去重温一下这部经典的片子，并且留意一下这个桥段。]]></content>
      <tags>
        <tag>spring-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发现一个讲解Raft协议的动画]]></title>
    <url>%2F1b3b8e8b.html</url>
    <content type="text"><![CDATA[http://thesecretlivesofdata.com/raft/]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud与微服务学习笔记-基本概念]]></title>
    <url>%2F8b1aa30e.html</url>
    <content type="text"><![CDATA[前言在上一篇文章「Spring Cloud与微服务学习笔记-关于Spring Boot」中，我们对Spring Cloud的依赖项：Spring Boot做了简要的介绍，算是我们学习Spring Cloud的预科班吧，然后从本篇文章开始，我们开始进入正题了。 「Spring Cloud与微服务学习笔记」系列文章包含了两个主题：”Spring Cloud”和”微服务”，那么，什么是”Spring Cloud”？，什么又是”微服务”？。在本系列文章中的开头，我们就先来简要介绍一下”微服务”和”Spring Cloud”这两个基本概念吧。 关于微服务什么是“微服务”呢，关于这一点，我个人认为，“微服务”是一个组合的概念，它是由开发、部署、架构等等各个环节中很多具体的概念共同形成的，很难一次性理解清楚。作为初学者的我们，可以先通过阅读来了解一些成型的概念，先形成一个感性认识，然后再随着不断地实践与思考，慢慢对“微服务”的概念产生更透彻的理性认识。 关于“Microservices”（微服务）这个概念最著名的一篇文章应该是 马丁·福勒的《Microservices》这篇文章了（中文译文1 中文译文2），这篇文章对微服务进行了定义，并将微服务架构与传统单体架构进行了对比，阐述了微服务的优势与劣势。这篇文章比较长，而且涉及到了不少概念，阅读起来会比较吃力，我们可以先参看“敖小剑的博客”写的一篇对应的学习笔记，来简要了解一下这篇文章的骨架，在这里我们截取最容易理解的一段关于微服务应用和单体应用对比来从一个侧面大致的了解一下微服务的概念吧。以下引用自学习笔记 微服务定义: 微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制(通常用HTTP资源API)。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。 和单体服务器的对比: 单体服务器是构建这样一个系统最自然的方式。处理请求的所有逻辑都运行在一个单一进程中，允许你使用编程语言的基本特性将应用程序划分类、函数和命名空间。你认真的在开发机上运行测试应用程序，并使用部署管道来保证变更已被正确地测试并部署到生产环境中。该单体的水平扩展可以通过在负载均衡器后面运行多个实例来实现。 以我个人现阶段的理解，微服务就是将我们原来写的一个“大应用”中的一系列提供某一类服务的模块，拆分成相互独立的小“应用”，每个小应用都对外提供一种服务，然后将这些“小应用”通过接口契约或远程调用的方式组合起来再构成原来的“大应用”。每一个“小应用”都对应了一系列同类业务逻辑、可由不同的编程语言编写、数据存储相互独立、部署相互独立。 关于Spring Cloud什么又是Spring Cloud呢？关于Spring Cloud，我觉得没有必要给他一个精确地定义了，把它理解为”微服务一站式解决方案”就好了。它提供了众多组件，涵盖了微服务的方方面面。以下是Spring Cloud包含的组件： Spring Cloud Config Centralized external configuration management backed by a git repository. The configuration resources map directly to Spring Environment but could be used by non-Spring applications if desired. *Spring Cloud Netflix Integration with various Netflix OSS components (Eureka, Hystrix, Zuul, Archaius, etc.). Spring Cloud Bus An event bus for linking services and service instances together with distributed messaging. Useful for propagating state changes across a cluster (e.g. config change events). Spring Cloud for Cloud Foundry Integrates your application with Pivotal Cloud Foundry. Provides a service discovery implementation and also makes it easy to implement SSO and OAuth2 protected resources. Spring Cloud Open Service Broker Provides a starting point for building a service broker that implements the Open Service Broker API. Spring Cloud Cluster Leadership election and common stateful patterns with an abstraction and implementation for Zookeeper, Redis, Hazelcast, Consul. Spring Cloud Consul Service discovery and configuration management with Hashicorp Consul. Spring Cloud Security Provides support for load-balanced OAuth2 rest client and authentication header relays in a Zuul proxy. Spring Cloud Sleuth Distributed tracing for Spring Cloud applications, compatible with Zipkin, HTrace and log-based (e.g. ELK) tracing. Spring Cloud Data Flow A cloud-native orchestration service for composable microservice applications on modern runtimes. Easy-to-use DSL, drag-and-drop GUI, and REST-APIs together simplifies the overall orchestration of microservice based data pipelines. Spring Cloud Stream A lightweight event-driven microservices framework to quickly build applications that can connect to external systems. Simple declarative model to send and receive messages using Apache Kafka or RabbitMQ between Spring Boot apps. Spring Cloud Stream App Starters Spring Cloud Stream App Starters are Spring Boot based Spring Integration applications that provide integration with external systems. Spring Cloud Task A short-lived microservices framework to quickly build applications that perform finite amounts of data processing. Simple declarative for adding both functional and non-functional features to Spring Boot apps. Spring Cloud Task App Starters Spring Cloud Task App Starters are Spring Boot applications that may be any process including Spring Batch jobs that do not run forever, and they end/stop after a finite period of data processing. Spring Cloud Zookeeper Service discovery and configuration management with Apache Zookeeper. Spring Cloud for Amazon Web Services Easy integration with hosted Amazon Web Services. It offers a convenient way to interact with AWS provided services using well-known Spring idioms and APIs, such as the messaging or caching API. Developers can build their application around the hosted services without having to care about infrastructure or maintenance. Spring Cloud Connectors Makes it easy for PaaS applications in a variety of platforms to connect to backend services like databases and message brokers (the project formerly known as “Spring Cloud”). Spring Cloud Starters Spring Boot-style starter projects to ease dependency management for consumers of Spring Cloud. (Discontinued as a project and merged with the other projects after Angel.SR2.) Spring Cloud CLI Spring Boot CLI plugin for creating Spring Cloud component applications quickly in Groovy Spring Cloud Contract Spring Cloud Contract is an umbrella project holding solutions that help users in successfully implementing the Consumer Driven Contracts approach. Spring Cloud Gateway Spring Cloud Gateway is an intelligent and programmable router based on Project Reactor. Spring Cloud OpenFeign Spring Cloud OpenFeign provides integrations for Spring Boot apps through autoconfiguration and binding to the Spring Environment and other Spring programming model idioms. 可以看到，组件相当的齐全，配置中心、安全、CLI等等组件一应俱全，作为初学，我们不用一下子学习这么多组件，只关注最主要的就好了，黑体星号标注的Spring Cloud Netflix是我们当前这个阶段学习的重点，这个组件可以说是所有组件中最基础、最核心的了，其他组件大可以以后按需学习。 关于Spring Cloud NetflixSpring Cloud Netflix可以说是Spring Cloud的基础组件了，实际上它本身也是由很多子组件构成的，初学我们先掌握服务注册与发现(Eureka)、断路器(Hystrix)、声明式REST客户端(Feign)、客户端负载均衡(Ribbon)、Api网关(Zuul)，这几个就好啦，用这些组件就已经能够搭建出简单的微服务了。Spring Cloud Netflix的全部组件如下，先学几个基础的，其他的以后用到了，现学就好： Spring Cloud Netflix features: Service Discovery: Eureka instances can be registered and clients can discover the instances using Spring-managed beans Service Discovery: an embedded Eureka server can be created with declarative Java configuration Circuit Breaker: Hystrix clients can be built with a simple annotation-driven method decorator Circuit Breaker: embedded Hystrix dashboard with declarative Java configuration Declarative REST Client: Feign creates a dynamic implementation of an interface decorated with JAX-RS or Spring MVC annotations Client Side Load Balancer: Ribbon External Configuration: a bridge from the Spring Environment to Archaius (enables native configuration of Netflix components using Spring Boot conventions) Router and Filter: automatic regsitration of Zuul filters, and a simple convention over configuration approach to reverse proxy creation 在以后的文章中，我们会就服务注册与发现、声明式REST客户端、客户端负载均衡以及Api网关这几个组件着重的介绍。 总结在本篇文章中，我们大致了解了”微服务”和Spring Cloud的基本概念，让我们不至于对于Spring Cloud和”微服务”过于生疏，起码知道是什么，然后在下一篇文章「Spring Cloud与微服务学习笔记-注册与发现」中我们会介绍服务注册与发现的概念，eureka是什么，以及怎样自己动手搭建一个服务注册中心出来。 参考资料microservices Spring Cloud技术分析（序） Netflix OSS Spring Cloud Netflix 彩蛋文中我们提到了Spring Cloud Netflix，这里面有个词Netflix，经常看美剧的同学想必很熟悉这个词了，没错，就是那家Netflix（网飞）。《纸牌屋》、《黑镜》、《怪奇物语》等等名剧均出自于它，没想到出了这么多高质量美剧的公司做技术也是如此了得，给开源社区做出了如此大的贡献，在此向网飞致敬。 网飞的剧，有一个很有意思的特点，有的剧是会一次性发布一整季内容而不是一季中一集一集发布的，这一点和别家不太一样，让你一次看过瘾😆，想当初看《怪奇物语》的时候我就是一天看完了一整季。 在这里再给大家安利一下《怪奇物语》这部剧吧，此剧初看感觉还是老套路但是编剧相当优秀，越往后越有意思，编剧神啊，老套路也能出新感觉，十分值得一看。]]></content>
      <tags>
        <tag>spring-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud与微服务学习笔记-关于Spring Boot]]></title>
    <url>%2F37ba2479.html</url>
    <content type="text"><![CDATA[背景虽然「Spring Cloud与微服务学习笔记」系列文章是针对Spring Cloud这一主题的，但是，由于Spring Cloud是依赖于Spring Boot的，而且，Spring Boot也为构建基于Spring Cloud的微服务程序提供了很多基础性的支持，因此，可以说，Spring Boot是Spring Cloud必不可少的基石，同时也是Spring Cloud背后的英雄。所以，在开始介绍Spring Cloud之前，我们专门拿出一篇文章的篇幅来简要介绍一下Spring Boot。 理论知识“那么，我以前已经用Spring + Spring MVC用的很6了，这个Spring Boot又是什么鬼，我为什么要花时间来了解它、学习它呢？” 其一，正如前文所讲，Spring Cloud依赖于Spring Boot，所以要想开发基于Spring Cloud的程序，不得不用Spring Boot；其二，即便你说：“我用不着开发Spring Cloud程序”，那我也还是建议你了解一下Spring Boot，因为，它能彻底改变你开发与部署web应用的思路。闲言少叙，Spring Boot是什么呢，他又能提供给我什么好处呢？关于这一点，我们来看官方的介绍吧： Spring Boot makes it easy to create Spring-powered, production-grade applications and services with absolute minimum fuss. It takes an opinionated view of the Spring platform so that new and existing users can quickly get to the bits they need. You can use Spring Boot to create stand-alone Java applications that can be started using java -jar or more traditional WAR deployments. We also provide a command line tool that runs spring scripts. Our primary goals are: Provide a radically faster and widely accessible getting started experience for all Spring development Be opinionated out of the box, but get out of the way quickly as requirements start to diverge from the defaults Provide a range of non-functional features that are common to large classes of projects (e.g. embedded servers, security, metrics, health checks, externalized configuration) Absolutely no code generation and no requirement for XML configuration 我在这里大致翻译一下（意译），请对应原文查看： 用Spring Boot，你能够轻松创建基于Spring的、约定大于配置的、独立运行的，生产级应用。 你可以用Spring Boot来写基于jar部署启动的应用或者是传统的war应用。 同时我们还提供给你一个运行“spring scripts”的命令行工具。 我们的主要愿景是： 提供给所有的Spring开发者更爽的”getting started”体验。 开箱即用，精简配置过程。 内置好了一些在很多项目中都会需要的通用特性，如嵌入式服务器，安全，指标，健康检查，外部化配置。 绝对不用代码生成和XML配置。 其实归根结底，用一张图就可以说明了： 我自己从去年11月份开始接触Spring Boot，到现在大约5个月的时间，我自己直观的感受就是：”我再也不想用回到原来的Spring + Spring MVC了”，这5个月时间我大概也体会到了Spring Boot的一些特点： 配置的确简化了相当多，无论是代码中的配置还是构建工具的配置，都简化了 彻底打破了开发与部署时的思维定式，原来搞得都是war，需要繁琐的，配置服务器与部署的过程，现在咱开发的产品都是jar了，或者说是一个独立的进程的命令行程序了，再不依赖于应用服务器了，这一点可以说是web开发的一个飞跃 自己掌控main()方法，基于这一点我们可以玩出很多花样来，main()大法好啊 (关于这一点，可以参考我的另一篇文章) 实际操作“夸归夸，卖归卖，你说了这莫多Spring Boot的好处，倒是写一个看看啊。” 作为程序员，我们最关心的就是怎样上手了，那么我们就通过简单的例子来演示一下Spring Boot的基本使用吧。就拿一个最普通的CRUD来做演示吧，在开始Spring Boot之前，我们先来温习一下Spring + Spring MVC，温故而知新，同时也是拿它来做一个对比的基准。 “CRUD” 之 Spring + Spring MVC版限于篇幅，过多的代码我就不贴出来了，我将这个demo工程放到了github上，到那里去看吧。我在这里简要介绍一下我习惯的普通的Spring + Spring MVC工程开发的一般路数吧： 我一般会用的全Java配置的方式，并且使用Gradle构建。所以我会首先集齐所有依赖项放入Gradle的dependencies（集齐七个依赖可以召唤神龙 😀） 1234567891011121314151617181920212223242526272829group &apos;com.githu.since1986.learn.boot&apos;version &apos;1.0-SNAPSHOT&apos;apply plugin: &apos;java&apos;apply plugin: &apos;war&apos;sourceCompatibility = 1.8repositories &#123; maven &#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; &#125; mavenCentral()&#125;dependencies &#123; compile group: &apos;org.springframework&apos;, name: &apos;spring-webmvc&apos;, version: &apos;4.3.14.RELEASE&apos; compile group: &apos;org.springframework&apos;, name: &apos;spring-tx&apos;, version: &apos;4.3.14.RELEASE&apos; compile group: &apos;org.springframework&apos;, name: &apos;spring-jdbc&apos;, version: &apos;4.3.14.RELEASE&apos; compile group: &apos;org.mybatis&apos;, name: &apos;mybatis-spring&apos;, version: &apos;1.3.2&apos; compile group: &apos;org.mybatis&apos;, name: &apos;mybatis&apos;, version: &apos;3.4.6&apos; compile group: &apos;org.apache.tomcat&apos;, name: &apos;tomcat-servlet-api&apos;, version: &apos;8.5.29&apos; compile group: &apos;org.apache.commons&apos;, name: &apos;commons-dbcp2&apos;, version: &apos;2.2.0&apos; compile group: &apos;com.fasterxml.jackson.core&apos;, name: &apos;jackson-databind&apos;, version: &apos;2.9.4&apos; compile group: &apos;mysql&apos;, name: &apos;mysql-connector-java&apos;, version: &apos;5.1.46&apos;&#125; 然后，配置好所有配置项，我一般按照这样的路数配置： 1234567891011121314151617181920212223242526272829303132333435.├── java│ └── com│ └── github│ └── since1986│ └── learn│ └── boot│ └── step1│ ├── AppConfig.java 根配置│ ├── AppConstants.java 全局常量│ ├── AppInitializer.java Mvc初始化器│ ├── MyBatisConfig.java MyBatis根配置│ ├── controller 控制器包│ │ ├── AppExceptionHandler.java Mvc全局异常处理│ │ ├── ServletConfig.java Mvc配置│ │ └── TestController.java│ ├── mapper Mapper接口包│ │ ├── MapperConfig.java Mapper配置│ │ └── TestMapper.java Mapper接口│ ├── model Model类包│ │ └── TestModel.java│ └── service Service包│ ├── ServiceConfig.java Service配置│ ├── TestService.java│ └── TestServiceImpl.java└── resources ├── com │ └── github │ └── since1986 │ └── learn │ └── boot │ └── step1 │ └── mapper │ └── TestMapper.xml Mapper接口对应的配置文件 └── import.sql #数据库初始化脚本 再然后，调试、打包、部署tomcat，这几个步骤可由各类开发、调试、部署、构建工具来进行，在此不仔细展开了。到此基本上就完成了传统的基于Spring + Spring MVC的项目的初始化工作 “CRUD” 之 Spring Boot版我们再来看Spring Boot版的CRUD，同样，代码在github上 基于Spring Boot开发与传统的Spring —— Spring MVC开发的一个不同点是在构建工具中提供了组合型依赖项，也就是所谓”starter”，一个”starter”就能替代原来许多个独立的依赖项，这样我们就不用刻意去凑这些依赖了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647group &apos;com.github.since1986.learn.boot&apos;version &apos;1.0-SNAPSHOT&apos;apply plugin: &apos;application&apos;apply plugin: &apos;org.springframework.boot&apos;apply plugin: &apos;propdeps&apos;apply plugin: &apos;propdeps-maven&apos;apply plugin: &apos;propdeps-idea&apos;sourceCompatibility = 1.8buildscript &#123; repositories &#123; maven &#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; &#125; maven &#123; url &apos;http://repo.spring.io/plugins-release&apos; &#125; mavenCentral() &#125; dependencies &#123; classpath &quot;org.springframework.boot:spring-boot-gradle-plugin:1.5.9.RELEASE&quot; classpath &quot;io.spring.gradle:propdeps-plugin:0.0.9.RELEASE&quot; &#125;&#125;repositories &#123; maven &#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; &#125; mavenCentral()&#125;dependencies &#123; optional group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-configuration-processor&apos; compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-web&apos;, version: &apos;1.5.9.RELEASE&apos; #注意这里的starter，可以和上边的传统MVC工程对比一下 compile group: &apos;org.mybatis.spring.boot&apos;, name: &apos;mybatis-spring-boot-starter&apos;, version: &apos;1.3.1&apos; compile group: &apos;mysql&apos;, name: &apos;mysql-connector-java&apos;, version: &apos;5.1.46&apos;&#125;compileJava.dependsOn(processResources)jar &#123; manifest &#123; attributes( &quot;Manifest-Version&quot;: &quot;1.0&quot;, &quot;Class-Path&quot;: &apos;. &apos; + configurations.compile.collect &#123; it.getName() &#125;.join(&apos; &apos;) ) &#125;&#125; 我们再来看Spring Boot的配置项,可以看到，有一个名为”application.yml”的配置文件，这个是Spring Boot”约定优先于配置”的一个很好体现，在这个约定好的配置文件中，使用约定好的配置项进行配置，能省去原来很多需要自己定义的Java配置类，比如dbcp的DataSource，这一点是Spring Boot与传统Spring + Spring MVC程序在配置上的最大不同，其他的配置类的模式你仍然可以保持原样 1234567891011121314151617181920212223242526272829303132333435.├── java│ └── com│ └── github│ └── since1986│ └── learn│ └── boot│ └── step1│ ├── App.java Boot主启动类│ ├── AppConfig.java 主配置│ ├── AppProperties.java 自定义属性配置类│ ├── MvcConfig.java Mvc配置│ ├── controller 控制器包│ │ ├── AppExceptionHandler.java Mvc全局异常处理│ │ └── TestController.java│ ├── mapper Mapper包│ │ ├── MapperConfig.java Mapper配置│ │ └── TestMapper.java Mapper接口│ ├── model Model包│ │ └── TestModel.java│ └── service Service包│ ├── ServiceConfig.java Service配置│ ├── TestService.java│ └── TestServiceImpl.java└── resources ├── application.yml Boot主配置文件 ├── com │ └── github │ └── since1986 │ └── learn │ └── boot │ └── step1 │ └── mapper │ └── TestMapper.xml Mapper接口对应的配置文件 └── import.sql 数据库初始化文件 然后再来看部署方面，注意我在构建脚本里的apply plugin: &#39;application&#39;这个Gradle plugin，这是一个用来将普通的带有main()方法的Java应用打成带有操作系统适应的启动脚本的命令行程序的插件，也就是我们的应用是能以独立进程的方式跑的，这一点是个很大的进步，无需关心宿主应用服务器的配置是怎样的了，因为压根就没有宿主环境了。同时，请注意App.java： 123456789101112package com.github.since1986.learn.boot.step1;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 这么多年的web开发，我们几乎都忘记了那曾经拥有main()方法的纯真快乐时光了，只记住了一直霸气的老黄猫😆，现在main()又回到了我们的身边，善待它吧，因为有了它，我们能做出很多了不起的事。 总结在这篇文章中，我们简要的介绍了一下Spring Cloud的基石Spring Boot的概念与使用，为以后了解Spring Cloud打好了基础，在下一篇文章「Spring Cloud与微服务学习笔记-基本概念」中，我们将真正开始Spring Cloud之旅。 参考资料用Spring Boot颠覆Java应用开发 Spring Boot 官方文档]]></content>
      <tags>
        <tag>spring-boot</tag>
        <tag>spring-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[早春的云-Spring Cloud与微服务学习笔记系列文章]]></title>
    <url>%2F67e55e6b.html</url>
    <content type="text"><![CDATA[正值早春，是写文章的好时节，从今天开始，我会陆续更新一系列关于Spring Cloud的文章，敬请期待。 目录 Spring Cloud与微服务学习笔记-关于Spring Boot Spring Cloud与微服务学习笔记-基本概念 Spring Cloud与微服务学习笔记-注册与发现 Spring-Cloud与微服务学习笔记-服务调用（上）]]></content>
      <tags>
        <tag>spring-boot</tag>
        <tag>spring-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio手动下载系统镜像]]></title>
    <url>%2Fae8eb356.html</url>
    <content type="text"><![CDATA[在Android Studio中创建虚拟设备时，Android Studio会自动从Google的系统镜像库中下载Android系统镜像并完成虚拟设备的创建，但是由于有些时候网络的限制会导致下载系统镜像这个步骤变得很慢，甚至会报错中断，这时会导致整个虚拟设备创建过程无法顺利完成。比如我司就限制了下载速度上限300k/s，今天在尝试创建虚拟Android设备时就卡在下载镜像这步了，我回忆了一下原来创建虚拟设备时的过程，Android Studio大致是先下载镜像然后解压，下载镜像的地址会在控制台显示，那么只要我自己手工从这个地址下好镜像包并解压到正确的位置就好了，然后翻了一下home目录，找到了Android系统镜像的默认下载存放地址为/Users/&lt;用户名&gt;/Library/Android/sdk/system-images/android-&lt;Api版本号&gt;/google_apis_playstore/&lt;cpu架构&gt;这个目录下(我用的是macOS High Sierra，请根据自己的操作系统找对应的目录，另外这个目录不用自己创建，运行过一遍创建虚拟设备并下载系统镜像的过过程后就会自动创建的)，然后我用迅雷把镜像包下好，手动解压到位，再打开创建虚拟设备的窗口，发现已经不用再下载Android系统镜像了，直接可以进入创建虚拟设备的过程了。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次java.net.UnknownHostException的解决过程]]></title>
    <url>%2F71f3f6d0.html</url>
    <content type="text"><![CDATA[今天写的代码用到了调用webservice的方法，在本地调试没问题，但是部署到测试服务上会爆java.net.UnknownHostException,一开始我觉得可能是webservice所在的服务器与当前这台测试服务器的防火墙拦截了webservice所在的8081端口的通信导致的，所以试了一下telnet &lt;webservice-host-ip&gt; &lt;webservice-port&gt;后发现通的，那么应该没问题才对啊，问了同事，查了资料，都没解决，卡在这里一段时间，然后我觉得不如问问领导吧，然后问了领导，他说你telnet是用的域名吗，我这才醒悟过来，我telnet的是ip而代码中的调用却是通过域名调用的，这样试是没有还原调用环境的。领导说完过来帮忙调了一下，发现telnet &lt;webservice-host-name&gt; &lt;webservice-port&gt;是连不上的，然后改了一下这台测试服务器上的hosts文件，增加了解析域名到webservice服务器的规则后，再重试就没问题了。通过今天的调错过程，总结了一个涉及java.net.UnknownHostException的调试经验:如果代码中是通过域名而不是ip调用webservice接口的，telnet要用域名来试: telnet &lt;被调用接口域名&gt; &lt;被调用接口端口&gt;，注意尽量还原代码中的网络环境。]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制十进制整数的转换]]></title>
    <url>%2F668b5e27.html</url>
    <content type="text"><![CDATA[进制转换在上大学时就学了，时到现在忘得已经差不多了，正好这两天看了几篇关于二进制的文章，顺便也就复习了一下，整数的十进制转二进制用辗转相处，二进制转十进制用按位乘与2的位数次方。另外在将二进制转为十进制时需要用到power运算，我是直接用的位运算，当然也可以用Math.pow()，一样能实现。 1234567891011121314151617181920212223242526272829303132333435363738394041public class Test4 &#123; public static void main(String[] args) &#123; /* 十进制转二进制 辗转相除： 666 / 2 = 333 余 0 333 / 2 = 166 余 1 166 / 2 = 83 余 0 依次类推直到相除结果为0 */ int decimal = 666; while (decimal != 0) &#123; // System.out.print(decimal % 2); decimal /= 2; &#125; System.out.println(); /* 二进制转十进制 从最低位开始，每一位 * 基数(二进制基数就是2)的位数次方 累加 0101100101 从最右侧开始 (1 * 2的0次方) + (0 * 2的1次方) + (1 * 2的2次方) + ... */ int[] binary = &#123;0, 1, 0, 1, 1, 0, 0, 1, 0, 1&#125;; int result = 0; for (int index = 0; index &lt; binary.length; index++) &#123; /* Java中 2的n次方实际上就是1左移n位 00000000000000000000000000000001 也就是int型的1 左移0位后(也就是没移动) 00000000000000000000000000000001 还是int型的1 00000000000000000000000000000001 左移一位后变为 00000000000000000000000000000010 也就是int型的2 00000000000000000000000000000001 左移2位后变为 00000000000000000000000000000100 也就是int型的4 以此类推 */ result += binary[index] * (1 &lt;&lt; index); &#125; System.out.println(result); &#125;&#125;]]></content>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手，在macOS High Sierra中编译一个可debug的JDK]]></title>
    <url>%2F41a7068f.html</url>
    <content type="text"><![CDATA[背景由于最近想分析几个native方法，所以需要手头有一个可以debug的JDK，因此，这两天折腾了折腾，踩了10+个坑，看了10+篇文章，尝试了10+次，最后总算把JDK给编出来了，当在自己编译出来的JDK上运行javac -version输出了那熟悉的文字后，感觉已是老泪纵横还是很有成就感的。 前期准备 了解一下OpenJDK的相关知识: 我们要编译的是Open JDK 9u 安装Homebrew(可选) 番羽土啬: 因为假如编译出错需要查询错误的解决方案时需要通过一个不存在的网站来进行 准备一个好用的源码编辑器: 因为运气好的话[滑稽]我们可能需要修改JDK源码中的八阿哥(我用的 mscode) 安装一个Boot JDK: 因为JDK中有不少代码是Java写的，所以想要编译JDK就需要用到另一个JDK来辅助(鸡生蛋、蛋生鸡/自己拽自己的头发把自己拽起来)，我安装的是Oracle官方的JDK 安装freetype:这是个依赖项brew install freetype 安装Xcode 环境描述 操作系统: macOS High Sierra Version: 10.13.3 (17D47) Boot JDK: 1.8.0_161 freetype: 2.9 Xcode: Version 9.2 (9C40b) Open JDK源码: jdk9u-2e265b4b8622 corba-2ef36e70f490 hotspot-bb73b31e70e3 jaxp-95a71f690b44 jaxws-f4f878b5f01c jdk-a779673ab57d langtools-e2bf77b3f002 nashorn-fb3f7ae74bf6 前人蹚过的坑/我蹚过的坑 不要编译JDK 8: 因为编译8需要Xcode 4现在Xcode版本已远高于4了(这个坑是前人蹚出来的，当然我不信邪，然后自己蹚了一遍，然后发现确实是个坑) 尽量不要使用Mercurial来下Open JDK的源码，而用浏览器直接下载打包好的源码: 因为你要用Mercurial下载了Open JDK的顶层工程后，还需要执行其中的get_source.sh来下载其子工程的源码，这个过程漫长而且失败率高(关键还没有执行百分比提示，干等)，用浏览器自己下载所有子工程的压缩包要快很多，而且成功率100%(我自己蹚出来的，前人的几篇文章中全告诉我用Mercurial，结果坑了) 编译JDK 9u而不是JDK 9因为我当时编译9的时候出了一堆error，所以我想带个u的是不是会好些，当然这个有很大程度是我臆测的，我后期就都拿9u搞了，没试9，如果各位有兴趣可以自己蹚蹚这个 configure的时候一定要带上--disable-warnings-as-errors这个参数，否则编译过程中的warning也会中断编译的进程，实际上这些warning并不影响编译后的目标JDK的运行 走流程如果前面几点 该准备的你都准备了，该注意的你也注意了，那么开始走流程编译吧，如果报错（有很大几率会）不要摔键盘，用前面我们提到的不可描述存在的网站来找答案，我自己摸着石头过河，反复试了2天才搞定，鲁迅先生说的好：“只要功夫深，铁杵磨成针”，祝你好运！！ step0所有前文提到的准备工作 step1下载源码压缩包 并将下载好的源码压缩包解压后按官方源码库的层级码放好 step2在源码顶层目录上执行sh configure --with-debug-level=slowdebug --disable-warnings-as-errors --with-freetype-include=/usr/local/Cellar/freetype/2.9/include/freetype2 --with-freetype-lib=/usr/local/Cellar/freetype/2.9/lib(带版本号的地方自己注意根据实际情况换)如果这一步没问题的话应当看到这样的输出： step3如果你的编译环境以及源码版本跟我的完全一样，那么先别make all，先来修一个bug：(patch在此) 这个bug会导致make报这个:error: ordered comparison between pointer and zero (&#39;char *&#39; and &#39;int&#39;) 。。。此处省略 打开hotspot目录中的 src/share/vm/memory/virtualspace.cpp 搜索其中if (base() &gt; 0) {改为if (base() != NULL) { src/share/vm/opto/lcm.cpp 搜索其中if (Universe::narrow_oop_base() &gt; 0) { 改为 if (Universe::narrow_oop_base() != NULL) { src/share/vm/opto/loopPredicate.cpp 搜索其中assert(rng-&gt;Opcode() == Op_LoadRange || _igvn.type(rng)-&gt;is_int() &gt;= 0, &quot;must be&quot;); 改为 assert(rng-&gt;Opcode() == Op_LoadRange || iff-&gt;is_RangeCheck() || _igvn.type(rng)-&gt;is_int()-&gt;_lo &gt;= 0, &quot;must be&quot;); step4make all编译时间略长，我的机子是2017款的 MacBook Pro大概用了20分钟+(没仔细计)，而且编译过程中风扇狂转，笔记本的话注意剩余电量以及散热，编译若成功，指定javac全路径运行一下javac -version看看 如果报了error，具体error具体分析，因为编译环境不同，可能error也不同，去不存在的网站找找解决方案，耐心+运气你就一定能成功的。 总结原以为编一个JDK能有多难，事实证明：是不难，但是坑多，麻烦，前前后后试了10多次，一共花了两天时间，从尝试编译JDK 8再到9中间出了各样问题，之中一度想放弃，但是由于想用它来实现更远的目标，所以还是坚持弄下来了，最终在搜索引擎和前人的帮助下成功了，所以还是那句话：“只要功夫深铁杵磨成针”，按正确的方向，反复尝试，终能成功。 参考资料Building OpenJDK 8 on Mac OS X Mavericks Building and Packaging OpenJDK9 for OSX Compilation errors with clang-4.0 OpenJDK / jdk10 / jdk10 / hotspotchangeset 13502:316854ef2fa2 Ordered comparison between pointer and zero (‘char *’ and ‘int’) error #5 MAC编译OpenJDK8 Compile&amp;Debug openjdk openjdk code compilation/ IDE setup 使用Clion(GDB)调试小型JVM源码 解决GDB在Mac下不能调试的问题 xcode-select active developer directory error Mac OsX Sierra - Stuck on binaryTreeDictionary.hpp compilation]]></content>
      <tags>
        <tag>JDK</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为基于spring-boot的应用添加根据运行时操作系统环境来提示用户选择active profile的功能]]></title>
    <url>%2Fb2e13457.html</url>
    <content type="text"><![CDATA[spring-boot有一个根据JVM变量-Dspring.profiles.active来设置运行时的active profile的功能，但是有些时候我们也许会不小心忘记设置这个变量，这样在生产环境中会带来一定的困扰，所以我想了一个办法，来给忘记设置-Dspring.profiles.active的程序员一次“secend chance”。 先来讲一下思路： step0 约定好profiles的命名，“development”代表开发环境(也可以将默认的profile设为开发环境)，“production”代表生产环境 step1 判断是否设置了-Dspring.profiles.active，如果已经设置，直接跳转step3 step2 判断当前操作系统环境，如果不是Linux环境则认定为开发环境，自动倒计时激活开发的profile；如果是Linux环境则认定为生产环境，输出选择profile的控制台信息，并等待用户控制台输入进行选择，并依据用户选择来激活profile step3 SpringApplication.run() 代码如下： spring-boot配置文件(使用了默认profile作为开发环境)： 123456789101112131415161718192021222324252627282930313233spring: application: name: comchangyoueurekaserver #注意命名要符合RFC 2396，否则会影响服务发现 详见https://stackoverflow.com/questions/37062828/spring-cloud-brixton-rc2-eureka-feign-or-rest-template-configuration-not-worserver: port: 8001eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;---spring: profiles: production application: name: comchangyoueurekaserverserver: port: 8001eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125; BootStarter封装了step1-step3的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import org.apache.commons.lang3.StringUtils;import java.util.Scanner;import java.util.Timer;import java.util.TimerTask;import java.util.regex.Pattern;public class BootStarter &#123; //用于后续Spring Boot操作的回调 public interface Callback &#123; void bootRun(); &#125; private boolean enableAutomaticallyStart = true; private int automaticallyStartDelay = 10; public boolean isEnableAutomaticallyStart() &#123; return enableAutomaticallyStart; &#125; public void setEnableAutomaticallyStart(boolean enableAutomaticallyStart) &#123; this.enableAutomaticallyStart = enableAutomaticallyStart; &#125; public int getAutomaticallyStartDelay() &#123; return automaticallyStartDelay; &#125; public void setAutomaticallyStartDelay(int automaticallyStartDelay) &#123; this.automaticallyStartDelay = automaticallyStartDelay; &#125; public void startup(boolean enableAutomaticallyStart, int automaticallyStartDelay, Callback callback) &#123; if (StringUtils.isBlank(System.getProperty(&quot;spring.profiles.active&quot;))) &#123; //如果没有通过参数spring.profiles.active设置active profile则让用户在控制台自己选择 System.out.println(&quot;***Please choose active profile:***\n\tp: production\n\td: development&quot;); final boolean[] started = &#123;false&#125;; Timer timer = new Timer(); if (enableAutomaticallyStart &amp;&amp; System.getProperty(&quot;os.name&quot;).lastIndexOf(&quot;Linux&quot;) == -1) &#123; //如果当前操作系统环境为非Linux环境(一般为开发环境)则automaticallyStartDelay秒后自动设置为开发环境 System.out.printf(&quot;\nSystem will automatically select &apos;d&apos; in %d seconds.\n&quot;, automaticallyStartDelay); final int[] count = &#123;automaticallyStartDelay&#125;; timer.scheduleAtFixedRate(new TimerTask() &#123; @Override public void run() &#123; if (count[0]-- == 0) &#123; timer.cancel(); started[0] = true; System.setProperty(&quot;spring.profiles.active&quot;, &quot;development&quot;); callback.bootRun(); &#125; &#125; &#125;, 0, 1000); &#125; Scanner scanner = new Scanner(System.in); Pattern pattern = Pattern.compile(&quot;^p|d$&quot;); //如果是Linux系统(一般为生产环境)则强制等待用户输入(一般是忘记设置spring.profiles.active了，这等于给了设置active profile的&quot;second chance&quot;) while (scanner.hasNextLine()) &#123; if (started[0]) &#123; break; &#125; String line = scanner.nextLine(); if (!pattern.matcher(line).find()) &#123; System.out.println(&quot;INVALID INPUT!&quot;); &#125; else &#123; timer.cancel(); System.setProperty(&quot;spring.profiles.active&quot;, line.equals(&quot;d&quot;) ? &quot;development&quot; : &quot;production&quot;); callback.bootRun(); break; &#125; &#125; &#125; else &#123; //如果已经通过参数spring.profiles.active设置了active profile直接启动 callback.bootRun(); &#125; &#125; public void startup(Callback callback) &#123; startup(this.enableAutomaticallyStart, this.automaticallyStartDelay, callback); &#125;&#125; main()： 12345678910111213141516171819202122import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;import org.springframework.context.ApplicationContext;@EnableEurekaServer@SpringBootApplicationpublic class App &#123; private static final Logger LOGGER = LoggerFactory.getLogger(App.class); public static void main(String[] args) &#123; new BootStarter().startup(() -&gt; &#123; ApplicationContext applicationContext = SpringApplication.run(App.class, args); for (String activeProfile : applicationContext.getEnvironment().getActiveProfiles()) &#123; LOGGER.warn(&quot;***Running with profile: &#123;&#125;***&quot;, activeProfile); &#125; &#125;); &#125;&#125; 运行效果(开发环境Mac OS)： 扩展：其实在这里我们还可以发散一下思维，基于spring-boot的应用比起传统spring应用的一大优势是自己可以掌控main()方法，有了这一点，我们是能玩出很多花样来的，思路不要被局限在tomcat时代了。 main法在手，天下我有。 2017-1-22更新：增加了线程安全的处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import org.apache.commons.lang3.StringUtils;import java.util.Scanner;import java.util.Timer;import java.util.TimerTask;import java.util.regex.Pattern;public class BootStarter &#123; private volatile boolean started; //用于后续Spring Boot操作的回调 public interface Callback &#123; void bootRun(); &#125; private boolean enableAutomaticallyStart = true; private int automaticallyStartDelay = 3; public boolean isEnableAutomaticallyStart() &#123; return enableAutomaticallyStart; &#125; public void setEnableAutomaticallyStart(boolean enableAutomaticallyStart) &#123; this.enableAutomaticallyStart = enableAutomaticallyStart; &#125; public int getAutomaticallyStartDelay() &#123; return automaticallyStartDelay; &#125; public void setAutomaticallyStartDelay(int automaticallyStartDelay) &#123; this.automaticallyStartDelay = automaticallyStartDelay; &#125; public void startup(boolean enableAutomaticallyStart, int automaticallyStartDelay, Callback callback) &#123; if (StringUtils.isBlank(System.getProperty(&quot;spring.profiles.active&quot;))) &#123; //如果没有通过参数spring.profiles.active设置active profile则让用户在控制台自己选择 System.out.println(&quot;***Please choose active profile:***\n\tp: production\n\td: development&quot;); Timer timer = new Timer(); if (enableAutomaticallyStart &amp;&amp; System.getProperty(&quot;os.name&quot;).lastIndexOf(&quot;Linux&quot;) == -1) &#123; //如果当前操作系统环境为非Linux环境(一般为开发环境)则automaticallyStartDelay秒后自动设置为开发环境 System.out.printf(&quot;\nSystem will automatically select &apos;d&apos; in %d seconds.\n&quot;, automaticallyStartDelay); timer.scheduleAtFixedRate(new TimerTask() &#123; private ThreadLocal&lt;Integer&gt; countDown = ThreadLocal.withInitial(() -&gt; automaticallyStartDelay); @Override public void run() &#123; if (countDown.get() == 0) &#123; timer.cancel(); started = true; System.setProperty(&quot;spring.profiles.active&quot;, &quot;development&quot;); callback.bootRun(); &#125; countDown.set(countDown.get() - 1); &#125; &#125;, 0, 1000); &#125; Scanner scanner = new Scanner(System.in); Pattern pattern = Pattern.compile(&quot;^p|d$&quot;); //如果是Linux系统(一般为生产环境)则强制等待用户输入(一般是忘记设置spring.profiles.active了，这等于给了设置active profile的&quot;second chance&quot;) while (scanner.hasNextLine()) &#123; if (started) &#123; break; &#125; String line = scanner.nextLine(); if (!pattern.matcher(line).find()) &#123; System.out.println(&quot;INVALID INPUT!&quot;); &#125; else &#123; timer.cancel(); System.setProperty(&quot;spring.profiles.active&quot;, line.equals(&quot;d&quot;) ? &quot;development&quot; : &quot;production&quot;); callback.bootRun(); break; &#125; &#125; &#125; else &#123; //如果已经通过参数spring.profiles.active设置了active profile直接启动 callback.bootRun(); &#125; &#125; public void startup(Callback callback) &#123; startup(this.enableAutomaticallyStart, this.automaticallyStartDelay, callback); &#125;&#125; 2017-01-25更新： 补上了 try-with-resource 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import org.apache.commons.lang3.StringUtils;import java.util.Scanner;import java.util.Timer;import java.util.TimerTask;import java.util.regex.Pattern;public class BootStarter &#123; private volatile boolean started; //用于后续Spring Boot操作的回调 public interface Callback &#123; void bootRun(); &#125; private boolean enableAutomaticallyStart = true; private int automaticallyStartDelay = 3; public boolean isEnableAutomaticallyStart() &#123; return enableAutomaticallyStart; &#125; public void setEnableAutomaticallyStart(boolean enableAutomaticallyStart) &#123; this.enableAutomaticallyStart = enableAutomaticallyStart; &#125; public int getAutomaticallyStartDelay() &#123; return automaticallyStartDelay; &#125; public void setAutomaticallyStartDelay(int automaticallyStartDelay) &#123; this.automaticallyStartDelay = automaticallyStartDelay; &#125; public void startup(boolean enableAutomaticallyStart, int automaticallyStartDelay, Callback callback) &#123; if (StringUtils.isBlank(System.getProperty(&quot;spring.profiles.active&quot;))) &#123; //如果没有通过参数spring.profiles.active设置active profile则让用户在控制台自己选择 System.out.println(&quot;***Please choose active profile:***\n\tp: production\n\td: development&quot;); Timer timer = new Timer(); if (enableAutomaticallyStart &amp;&amp; System.getProperty(&quot;os.name&quot;).lastIndexOf(&quot;Linux&quot;) == -1) &#123; //如果当前操作系统环境为非Linux环境(一般为开发环境)则automaticallyStartDelay秒后自动设置为开发环境 System.out.printf(&quot;\nSystem will automatically select &apos;d&apos; in %d seconds.\n&quot;, automaticallyStartDelay); timer.scheduleAtFixedRate(new TimerTask() &#123; private ThreadLocal&lt;Integer&gt; countDown = ThreadLocal.withInitial(() -&gt; automaticallyStartDelay); @Override public void run() &#123; if (countDown.get() == 0) &#123; timer.cancel(); started = true; System.setProperty(&quot;spring.profiles.active&quot;, &quot;development&quot;); callback.bootRun(); &#125; countDown.set(countDown.get() - 1); &#125; &#125;, 0, 1000); &#125; try (Scanner scanner = new Scanner(System.in)) &#123; Pattern pattern = Pattern.compile(&quot;^p|d$&quot;); //如果是Linux系统(一般为生产环境)则强制等待用户输入(一般是忘记设置spring.profiles.active了，这等于给了设置active profile的&quot;second chance&quot;) while (scanner.hasNextLine()) &#123; if (started) &#123; break; &#125; String line = scanner.nextLine(); if (!pattern.matcher(line).find()) &#123; System.out.println(&quot;INVALID INPUT!&quot;); &#125; else &#123; timer.cancel(); System.setProperty(&quot;spring.profiles.active&quot;, line.equals(&quot;d&quot;) ? &quot;development&quot; : &quot;production&quot;); callback.bootRun(); break; &#125; &#125; &#125; &#125; else &#123; //如果已经通过参数spring.profiles.active设置了active profile直接启动 callback.bootRun(); &#125; &#125; public void startup(Callback callback) &#123; startup(this.enableAutomaticallyStart, this.automaticallyStartDelay, callback); &#125;&#125;]]></content>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口式分页的实现]]></title>
    <url>%2F6d4ff8c1.html</url>
    <content type="text"><![CDATA[我的一个工程里需要用到滑动窗口式分页这个效果，我没有直接使用现成的库，而是尝试自己实现了一下，我把实现的过程和大家分享一下吧，希望能对需要的朋友有所帮助。先来看要实现的效果： 大家可以看到，滑动窗口式的分页解决了分页索引过多时显示过长的问题，中间部分的索引超过了索引“窗口”的大小时，则会以省略号来替代索引值，从而达到减少索引显示长度的目的；并且，我们可以观察到，随着用户的点击，中间的索引窗口是会移动的；另外，对于分页索引开头和结尾处，滑动窗口是需要特殊处理的。下面是我具体的分析过程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//条件一：无论窗口怎么移动，第一个和最后一个无论如何都需要显示 1 100//窗口起始位置=当前number-1,窗口末尾位置=(窗口起始位置+窗口大小)-1 如果当前number-1=0则窗口起始位置=number 如果当前number+1&gt;当前数列最后一个值(也就是等于当前数列的size)则窗口末尾=当前数列的size 窗口起始=(窗口末尾位置-窗口长度)+1//条件二：如果整个数列中只有0个或1个&apos;...&apos;则下一轮需要remove操作，而如果数列中有2个&apos;...&apos;则无需remove只需要窗口中所有数+1或-1即可(这里的remove是逻辑上的，实际操作就是splice)//条件三：如果窗口的起始位置的值=1或=2 则remove窗口左侧的&apos;...&apos;(其实也就是remove数列中第一个&apos;...&apos;)//条件四：如果窗口的结尾位置=数列最后一个值或=数列最后一个值-1 则remove窗口右侧的&apos;...&apos;(其实也就是remove数列中第二个&apos;...&apos;)//设定窗口大小为3var windowSize = 3;//向右移动的情况//当前初始值:var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100];//↓//↓ 输入参数(inputNumber)为1 窗口位置(windowStart-windowEnd)为1-3 现在数列中有0个&apos;...&apos;满足条件1 remove除了第一个和最后一个以外的窗口以外的所有值并向窗口末尾和数列末尾之间填充一个&quot;...&quot;//↓var numberWindow1 = [1, 2, 3, &apos;...&apos;, 100];//↓//↓ 当前点击(inputNumber)为2 窗口位置(windowStart-windowEnd)为1-3 没有到达窗口末尾不用右移 现在数列中有1个&apos;...&apos;满足条件1 remove除了第一个和最后一个以外的窗口以外的所有值并向窗口末尾和数列末尾之间填充一个&quot;...&quot;//↓var numberWindow2 = [1, 2, 3, &apos;...&apos;, 100];//↓//↓ 当前点击(inputNumber)为3 窗口位置(windowStart-windowEnd)为1-3 已到达窗口末尾 窗口右移1位(其实就是窗口中所有值 + 1) 新的窗口位置为2-4 现在数列中有1个&apos;...&apos;满足条件一 remove除了第一个和最后一个以外的窗口以外的所有值并向窗口末尾和数列末尾之间填充一个&quot;...&quot;//↓var numberWindow3 = [1, 2, 3, 4, &apos;...&apos;, 100];//↓//↓ 当前点击(inputNumber)为4 窗口位置(windowStart-windowEnd)为2-4 已到达窗口末尾 窗口右移1位(其实就是窗口中所有值 + 1) 新的窗口位置为3-5 现在数列中有1个&apos;...&apos;满足条件一 remove除了第一个和最后一个以外的窗口以外的所有值并向窗口末尾和数列末尾之间填充一个&quot;...&quot;//↓var numberWindow4 = [1, &apos;...&apos;, 3, 4, 5, &apos;...&apos;, 100];//↓//↓ 当前点击(inputNumber)为5 窗口位置(windowStart-windowEnd)为3-5 已到达窗口末尾 窗口右移1位(其实就是窗口中所有值 + 1) 新的窗口位置为4-6 现在数列中有2个&apos;...&apos;满足条件二 无需remove//↓var numberWindow5 = [1, &apos;...&apos;, 4, 5, 6, &apos;...&apos;, 100];//向左移动的情况//现在的数列:var numberWindow6 = [1, &apos;...&apos;, 4, 5, 6, &apos;...&apos;, 100];//↓//↓ 当前点击(inputNumber)为4 已到达窗口起始 窗口左移一位(其实就是窗口中所有值 - 1) 新的窗口位置为3-5 现在数列中有2个&apos;...&apos;满足条件二 无需remove//↓var numberWindow7 = [1, &apos;...&apos;, 3, 4, 5, &apos;...&apos;, 100];//↓//↓ 当前点击(inputNumber)为3 已到达窗口起始 窗口左移一位(其实就是窗口中所有值 - 1) 新的窗口位置为2-4 现在数列中有2个&apos;...&apos;满足条件二 无需remove 满足条件三 remove数列中第一个&apos;...&apos;//↓var numberWindow8 = [1, 2, 3, 4, &apos;...&apos;, 100];//↓//↓ 当前点击(inputNumber)为2 已到达窗口起始 窗口左移一位(其实就是窗口中所有值 - 1) 新的窗口位置为1-3 现在数列中有1个&apos;...&apos;满足条件二 remove除了第一个和最后一个以外的窗口以外的所有值并向窗口起始和数列起始之间填充一个&quot;...&quot; 满足条件三 remove数列中第一个&apos;...&apos;//↓var numberWindow9 = [1, 2, 3, &apos;...&apos;, 100]; 上边的分析过程是我想通过前端实现时进行的分析过程，后来感觉实现起来会很繁琐，要考虑很多细节，然后我想了想，要在后端实现，会简单很多，把这些分页索引看做数据从后端暴露接口，然后前端模板循环输出就好了，这样在逻辑上比较简单。思路有了，来看具体实现吧： 后端定义一个输出分页列表信息和分页索引信息的VO（基本上是从spring-data中摘出来的，getPageNumbers()这个是我自己加的）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import java.util.LinkedList;import java.util.List;public class JsonPage&lt;T&gt; &#123; private long totalElements; private int number; private int size; private List&lt;T&gt; content = new LinkedList&lt;&gt;(); private static final int PAGE_NUMBERS_WINDOW_SIZE = 3; //分页索引列表窗口大小(只能为奇数，否则下面方法中计算窗口半长会时会引起迷惑) public long getTotalElements() &#123; return totalElements; &#125; public int getNumber() &#123; return number; &#125; public int getSize() &#123; return size; &#125; public List&lt;T&gt; getContent() &#123; return content; &#125; public int getTotalPages() &#123; return getSize() == 0 ? 1 : (int) Math.ceil((double) totalElements / (double) getSize()); &#125; //计算窗口化分页列表 public List&lt;Object&gt; getPageNumbers() &#123; List&lt;Object&gt; pageNumbers = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; getTotalPages(); i++) &#123; //注意这里为了逻辑清晰 pageIndexes 是0 base的 pageNumbers.add(i); &#125; //是否达到了窗口化的条件 if (pageNumbers.size() &lt;= PAGE_NUMBERS_WINDOW_SIZE) return pageNumbers; //不满足窗口化条件直接返回原数列 // 注意number(当前是第几页)是0 base的 // 窗口起始位置 = number - 窗口半长 (窗口半长 = (PAGE_NUMBERS_WINDOW_SIZE - 1) / 2) // 窗口末尾位置 = number + 窗口半长 // 如果 number - 窗口半长 &lt;= 0 则 窗口起始位置 = 0 // 如果 number + 窗口半长 &gt;= 数列末尾值 则 窗口末尾位值 = 数列末尾值 int pageNumbersStartPosition = 0; //数列起始(注意是索引不是元素，当然如果是0 base的话索引和元素是值相同的) int pageNumbersEndPosition = pageNumbers.size() - 1; //数列末尾 int windowHalfSize = (PAGE_NUMBERS_WINDOW_SIZE - 1) / 2; int windowStartPosition = number - windowHalfSize &lt;= pageNumbersStartPosition ? pageNumbersStartPosition : number - windowHalfSize; int windowEndPosition = number + windowHalfSize &gt;= pageNumbersEndPosition ? pageNumbersEndPosition : number + windowHalfSize; //remove 除了 窗口中元素、数列首、尾元素 以外的所有元素(也就是从 数列起始 + 1 到 窗口起始 - 1 以及 窗口末尾 + 1 到 数列末尾 - 1 的所有元素)，并在窗口两边填补&quot;...&quot; List&lt;Object&gt; removeElementLeft = new LinkedList&lt;&gt;(), removeElementRight = new LinkedList&lt;&gt;(); if ((windowStartPosition - 1) - (pageNumbersStartPosition + 1) &gt;= 1) //如果 从 数列起始 + 1 到 窗口起始 - 1 之间有元素 removeElementLeft.addAll(pageNumbers.subList(1, windowStartPosition)); //注意sublist(from, to)是不包含to的，想要连to一起的话需要sublist(from, to + 1) if ((pageNumbersEndPosition - 1) - (windowEndPosition + 1) &gt;= 1) //如果 从窗口末尾 + 1 到 数列末尾 - 1 之间有元素 removeElementRight.addAll(pageNumbers.subList(windowEndPosition + 1, pageNumbersEndPosition)); if (removeElementLeft.size() != 0) &#123; pageNumbers.removeAll(removeElementLeft); pageNumbers.add(pageNumbersStartPosition + 1, &quot;...&quot;); // 虽然在remove后pageNumbers的大小已经变化了，但是pageNumbersEndPosition是不变的，这一点与pageNumbersEndPosition不同 &#125; if (removeElementRight.size() != 0) &#123; pageNumbers.removeAll(removeElementRight); pageNumbers.add(pageNumbers.size() - 1, &quot;...&quot;); //注意 在remove后pageNumbers的大小已经变化了就不能用原来的pageNumbersEndPosition了 ；add(index, element) 中 index指的是插入前的，插入后整个size会+1 &#125; return pageNumbers; &#125; public boolean hasPrevious() &#123; return getNumber() &gt; 0; &#125; public boolean hasNext() &#123; return getNumber() + 1 &lt; getTotalPages(); &#125; public boolean isFirst() &#123; return !hasPrevious(); &#125; public boolean isLast() &#123; return !hasNext(); &#125; public boolean hasContent() &#123; return !content.isEmpty(); &#125; public void setTotalElements(long totalElements) &#123; this.totalElements = totalElements; &#125; public void setNumber(int number) &#123; this.number = number; &#125; public void setSize(int size) &#123; this.size = size; &#125; public void setContent(List&lt;T&gt; content) &#123; this.content = content; &#125;&#125; 前端用handlebars循环输出就好了： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class=&quot;page-box&quot;&gt; &#123;&#123;#if (-gt? totalPages 1)&#125;&#125; &#123;&#123;#if first&#125;&#125; &lt;a class=&quot;page-btn1 page-item&quot; disabled=&quot;disabled&quot; href=&quot;javascript:&quot; data-page=&quot;&#123;&#123;n-subtract number 1&#125;&#125;&quot;&gt; &lt;span&gt;&lt;i class=&quot;iconfont icon-zuoyouqiehuan-&quot;&gt;&lt;/i&gt;&lt;/span&gt; 上一页 &lt;/a&gt; &#123;&#123;else&#125;&#125; &lt;a class=&quot;page-btn1 page-item&quot; href=&quot;javascript:&quot; data-page=&quot;&#123;&#123;n-subtract number 1&#125;&#125;&quot;&gt; &lt;span&gt;&lt;i class=&quot;iconfont icon-zuoyouqiehuan-&quot;&gt;&lt;/i&gt;&lt;/span&gt; 上一页 &lt;/a&gt; &#123;&#123;/if&#125;&#125; &#123;&#123;#each pageNumbers&#125;&#125; &#123;&#123;#if (-equal? this ../number)&#125;&#125; &lt;a href=&quot;javascript:&quot; class=&quot;cur&quot; data-page=&quot;&#123;&#123;this&#125;&#125;&quot;&gt;&#123;&#123;n-add this 1&#125;&#125;&lt;/a&gt; &#123;&#123;else&#125;&#125; &#123;&#123;#if (-equal? this &apos;...&apos;)&#125;&#125; &lt;i class=&quot;iconfont icon-hengsangedian&quot;&gt;&lt;/i&gt; &#123;&#123;else&#125;&#125; &lt;a class=&quot;page-item&quot; href=&quot;javascript:&quot; data-page=&quot;&#123;&#123;this&#125;&#125;&quot;&gt;&#123;&#123;n-add this 1&#125;&#125;&lt;/a&gt; &#123;&#123;/if&#125;&#125; &#123;&#123;/if&#125;&#125; &#123;&#123;/each&#125;&#125; &#123;&#123;#if last&#125;&#125; &lt;a class=&quot;page-btn2 page-item&quot; disabled=&quot;disabled&quot; href=&quot;javascript:&quot; data-page=&quot;&#123;&#123;n-add number 1&#125;&#125;&quot;&gt; 下一页 &lt;span&gt;&lt;i class=&quot;iconfont icon-zuoyouqiehuan-&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/a&gt; &#123;&#123;else&#125;&#125; &lt;a class=&quot;page-btn2 page-item&quot; href=&quot;javascript:&quot; data-page=&quot;&#123;&#123;n-add number 1&#125;&#125;&quot;&gt; 下一页 &lt;span&gt;&lt;i class=&quot;iconfont icon-zuoyouqiehuan-&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/a&gt; &#123;&#123;/if&#125;&#125; &#123;&#123;/if&#125;&#125;&lt;/div&gt; 这样实现起来简单了很多。]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从今天的新员工培训中学到的技术之外的技能]]></title>
    <url>%2F6d6043cc.html</url>
    <content type="text"><![CDATA[今天上午去参加了新员工培训，本以为新员工培训是上来HR讲一大堆PPT，没想到去了以后是HR带着大家做活动，分小组让每个人自己画一张画来作自我介绍，画上自己是谁、什么岗位、来自哪里、擅长什么、不擅长什么、害怕什么，让后照着画来介绍。感觉挺好玩，像进了幼儿园一样。。。不过我感觉通过这次培训还是学了点技能的，起码以后不用再为怎么自我介绍犯愁了，可以像HR给的方法那样，画出个大纲，照着大纲走就可以了，其实等于是个图形版的思维导图，感觉HR还是很有一套方法的。]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何通过反射获得方法的真实参数名（以及扩展研究）]]></title>
    <url>%2Fafedab58.html</url>
    <content type="text"><![CDATA[前段时间，在做一个小的工程时，遇到了需要通过反射获得方法真实参数名的场景，在这里我遇到了一些小小的问题，后来在部门老大的指导下，我解决了这个问题。通过解决这个问题，附带着我了解到了很多新的知识，我觉得有必要和大家分享交流一下。 咱们先来看这样一个小的demo： 这是一个很简单的小demo，里面就是一个简简单单的类Test1，Test1有一个包含两个参数的方法test，在Test1的main方法中通过射来获得test方法的所有参数的名字，并将其输出到标准流。我本以为这个demo的运行结果会得到方法的参数名，结果： 惊不惊喜，意不意外？和说好的不一样啊！ 咱们先停一下，先把为什么反射没有拿到正确的值放到一边，先说说我为什么要研究“通过反射原理获得方法参数的实际名称”这件事呢：是因为我想仿照并实现Spring MVC中的“自动绑定”功能。大家知道Spring MVC里有一个“自动绑定”的功能，能够自动绑定请求参数的值到@RequestMapping方法的参数上的，而不用任何额外的操作。 这个功能我觉得很方便，所以我想尝试自己仿造这个功能，然后用在公司的项目开发中。我猜测Spring是通过反射获得方法的参数名后根据参数名到request中getParam(String name)来获得实际的值然后绑定的。因此我就尝试着按照这个思路做，结果就遇到了上边提到的反射获得不了参数实际名称的问题。我将这个问题请教了老大，老大了解到我的意图后，经过验证，得出结论：Spring MVC能不能正常使用自动绑定是与java编译器编译时加不加-g参数有关的，而这个-g参数是代表着java编译器在编译时是否会输出调试信息。 其实也就是说：Spring是通过读取java编译器生成的调试信息从而获得的方法中参数的真实名称的。说到这里，这个问题基本也解决了，但是我还是想再多说一点我后续的学习结果。后续我研究了一下Spring对于方法参数这块的处理逻辑，也就是对于“自动绑定”功能的底层的实现。 那么，Spring 到底是用了什么“黑科技”来做到获得方法实际参数名的呢，咱们不妨就看Spring的源码吧，看看Spring到底是如何实现的。 Spring海量的源代码，从何看起呢，这里，我是这样解决的：我大体知道这个获得方法实际参数名的操作应当和Method的getParameters()方法有关，或者说它的方法里或许会调用到这个方法，那么好了，我们可以使用idea提供的“查看调用栈”的功能，来顺藤摸瓜，看看在Spring中有没有调用到这个方法，如果有，那么解决方案应当就在调用方法的附近。 我们可以看到，果不其然，在调用栈里就有org.spring包中的方法，其中有两个方法都是StandardReflectionParameterNameDiscoverer类的方法，其实我们已经找到了，看这个类的名字就能知道，它是处理ParameterName的Discoverer的（在这里我想再说点题外话，我个人非常赞同Spring这种全命名的编码风格，看到命名就能看明白这个类是在干什么，所以说代码应当是能“自描述”的） 好，我们再回到代码中来，继续看这个类：发现它有一段简要的注释： 大意就是这个类是针对使用了JDK8基于-parameters编译参数的ParameterNameDiscoverer的实现，这里这个-parameters参数是怎么回事咱们先放一边，继续向上看StandardReflectionParameterNameDiscoverer所实现的这个接口ParameterNameDiscoverer，打开ParameterNameDiscoverer这个接口，我们用idea的查看子类的功能，能够看到它一共有包括StandardReflectionParameterNameDiscoverer在内的8个子类 其中有一个名字里带“Default”的子类DefaultParameterNameDiscoverer，按照一般套路来说，带Default的都是默认的实现，那么好了我们优先看它吧。 打开DefaultParameterNameDiscoverer，我们发现，他做的大体就是通过判断standardReflectionAvailable这个值来走向不同分支流程：一个是走向刚才提到的利用JDK8编译参数的StandardReflectionParameterNameDiscoverer另一个是走向了LocalVariableTableParameterNameDiscoverer 好，现在又出现了熟悉的StandardReflectionParameterNameDiscoverer了，那么我们返回去看吧，一会再看另一个分支的LocalVariableTableParameterNameDiscoverer。 我们回到StandardReflectionParameterNameDiscoverer中，再来看刚才那个-parameters编译参数，这是个什么黑科技？既然他是个编译参数，那么咱们不妨试着用它编译一下咱们的代码试一下吧。 我们将idea设置上-parameters编译参数从新运行刚才的demo，发现这回的输出结果是： 已经能够拿到参数的真实名称了。那么，这个-parameters到底是什么呢：我们可以来看一下oracle官方提供的javac文档： 通过文档可以看出加上这个参数后，编译器会生成元数据，从而使方法参数的反射能够拿到参数的信息。这个功能是jdk8的新特性，我们就不仔细展开了，详情可以查看这两篇文档：JDK 8 Features JEP 118: Access to Parameter Names at Runtime -parameters这个黑科技咱们已经了解了，利用这个编译参数是可以获得方法参数的真实名称的，但是这个参数是jdk8之后才有的，那么之前的版本如何获得呢？我们继续看Spring源代码吧。现在我们来看另一个分支：LocalVariableTableParameterNameDiscoverer，打开这个类： 其实看注释就明白了，这个LocalVariableTableParameterNameDiscoverer是通过ASM library分析LocalVariableTable来实现获得参数实际名称的，ASM是一个第三方的字节码操纵库，用这个库可以读取写入class文件，这个库有很广泛的应用，具体的我不展开介绍了。 我们重点说一下这个LocalVariableTable吧，这个LocalVariableTable是什么呢？我们不用文字来说明了，直接来看代码吧：我们这次不看源文件了，来直接看编译后的class文件。用idea打开Test1.class： 然后在View菜单中点选Show Bytecode： 在弹出窗口中，我们可以看到，idea以大纲的方式把class文件的信息列了出来，而在其中就有LocalVariableTable存在，而且在“LocalVariableTable”附近我们可以看到我们定义方法的参数的真实名称。现在我们也就明白了，对于8以下的jdk编译环境，Spring是使用ASM来读取class文件中LocalVariableTable信息从而获得参数真实名称的。到此为止，我们已经基本了解了Spring中自动绑定背后的黑科技了。 这里我还想继续再多说一点，有关LocalVariableTable和Java class文件：class文件可以说是Java实现跨平台特性的根本！不管在什么平台下，只要编译出来的class文件符合规范，虚拟机就能够正常的执行。了解一下class文件的相关知识其实对于理解各类class文件操纵库以及基于class操纵的AOP等等编程模式的原理是很有帮助的，所以我们可以了解一下class文件是什么样的结构的。想要了解class文件的结构，最权威的莫过于官方的《Java虚拟机规范了》，在Java虚拟机规范中，第四章是有关class文件结构的内容，我们可以大致过一遍。通过阅读，我们可以大致了解到class的结构： A class file consists of a stream of 8-bit bytes. All 16-bit, 32-bit, and 64-bitquantities are constructed by reading in two, four, and eight consecutive 8-bitbytes, respectively. Multibyte data items are always stored in big-endian order,where the high bytes come first. In the Java SE platform, this format is supportedby interfaces java.io.DataInput and java.io.DataOutput and classes such asjava.io.DataInputStream and java.io.DataOutputStream. class文件可以用一个结构来表示： 这个结构中每一项大致的含义我们来简单说明一下吧（详情请查看虚拟机规范）： 开头的magic u4叫做“魔数”，Java虚拟器通过读取这个数来判断当前文件是不是有效的u4代表它是无符号的4个byte，这个数始终应该是0xCAFEBABE； minor_version、major_version分别是class文件的次版本和主版本； u2 constant_pool_count 、cp_info constant_pool[constant_pool_count-1]代表常量池中项目数和代表了常量池本身； u2 access_flags : 代表class访问标记，例如：public protected； u2 this_class : 代表放置类名在常量池中的索引； u2 super_class : 代表父类名称在常量池中的索引； u2 interfaces_count; u2 interfaces[interfaces_count]; 代表所实现的接口集合的大小，及接口集合本身； u2 fields_count; field_info fields[fields_count]; 代表属性集合大小以及属性集合本身； u2 methods_count; method_info methods[methods_count]; 代表方法集合大小以及方法集合本身； u2 attributes_count; attribute_info attributes[attributes_count]; java class文件内部属性信息集合大小和内部属性信息集合本身。这里提一下，我们前面的提到的LocalVariableTable的信息就存储在这里。 到了这里我们大致回顾一下吧，我们从尝试解决反射获得方法参数真实名称开始，了解了Java编译参数、Spring自动绑定相关处理原理、jdk8编译参数新特性、以及Java class文件的结构。通过这个过程，我们看到，就一个“自动绑定”这个平常都感觉不到它存在的小功能背后，还有这莫多深层次的技术在里面，由此可见，Spring之所以如此强大而且易用，离不开各类底层技术的支持，这就让我想起以前看到过的一位技术博主的标语：“只有深入，方能浅出”，想想确实是这个道理。 注：在研究过程中我参考以下几位的文章，在此表示感谢： 反射获取一个方法中的参数名（不是类型） Java 运行时获取方法参数名 java Class文件内部结构解析 深入理解JVM : class文件结构之常量池(1) 深入理解JVM : class文件结构之类信息描述、字段表、方法表(2) 触摸java常量池 实现一个Java Class解析器的实力代码分享 Java class file Tutorial: Java Class file format, revealed… The Java Class File Format The Java class file lifestyle An introduction to the basic structure and lifestyle of the Java class file]]></content>
      <tags>
        <tag>Java基础</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多次字符串相加一定要用StringBuilder而不用 + 吗？]]></title>
    <url>%2Fc45b5759.html</url>
    <content type="text"><![CDATA[今天在写一个读取Java class File并进行分析的Demo时，偶然发现了下面这个场景(基于oracle jdk 1.8.0_144)： 12345678910package test;public class Test8 &#123; String s1 = &quot;111&quot;, s2 = &quot;222&quot;, s3 = &quot;333&quot;, s4 = &quot;444&quot;; public String test() &#123; return s1 + s2 + s3 + s4 + &quot;5555&quot; + &quot;66666666666666666666666666&quot; + &quot;777&quot; + new String(&quot;测试测试&quot;) + String.valueOf(&quot;test test&quot;) + &quot;长字符串长字符串长字符串长字符串长字符串长字符串长字符串长字符串长字符串长字符串长字符串长字符串&quot;; &#125;&#125; 这是一个很简单的类，只完成了字符串的 + 操作，我们查看对应生成的class文件的outline： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// class version 52.0 (52)// access flags 0x21public class test/Test8 &#123; // compiled from: Test8.java // access flags 0x0 Ljava/lang/String; s1 // access flags 0x0 Ljava/lang/String; s2 // access flags 0x0 Ljava/lang/String; s3 // access flags 0x0 Ljava/lang/String; s4 // access flags 0x1 public &lt;init&gt;()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V L1 LINENUMBER 5 L1 ALOAD 0 LDC &quot;111&quot; PUTFIELD test/Test8.s1 : Ljava/lang/String; ALOAD 0 LDC &quot;222&quot; PUTFIELD test/Test8.s2 : Ljava/lang/String; ALOAD 0 LDC &quot;333&quot; PUTFIELD test/Test8.s3 : Ljava/lang/String; ALOAD 0 LDC &quot;444&quot; PUTFIELD test/Test8.s4 : Ljava/lang/String; RETURN L2 LOCALVARIABLE this Ltest/Test8; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 // access flags 0x1 public test()Ljava/lang/String; L0 LINENUMBER 8 L0 NEW java/lang/StringBuilder DUP INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; ()V ALOAD 0 GETFIELD test/Test8.s1 : Ljava/lang/String; INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; ALOAD 0 GETFIELD test/Test8.s2 : Ljava/lang/String; INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; ALOAD 0 GETFIELD test/Test8.s3 : Ljava/lang/String; INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; ALOAD 0 GETFIELD test/Test8.s4 : Ljava/lang/String; INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; LDC &quot;555566666666666666666666666666777&quot; INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; NEW java/lang/String DUP LDC &quot;\u6d4b\u8bd5\u6d4b\u8bd5&quot; INVOKESPECIAL java/lang/String.&lt;init&gt; (Ljava/lang/String;)V INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; LDC &quot;test test&quot; INVOKESTATIC java/lang/String.valueOf (Ljava/lang/Object;)Ljava/lang/String; INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; LDC &quot;\u957f\u5b57\u7b26\u4e32\u957f\u5b57\u7b26\u4e32\u957f\u5b57\u7b26\u4e32\u957f\u5b57\u7b26\u4e32\u957f\u5b57\u7b26\u4e32\u957f\u5b57\u7b26\u4e32\u957f\u5b57\u7b26\u4e32\u957f\u5b57\u7b26\u4e32\u957f\u5b57\u7b26\u4e32\u957f\u5b57\u7b26\u4e32\u957f\u5b57\u7b26\u4e32\u957f\u5b57\u7b26\u4e32&quot; INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String; ARETURN L1 LOCALVARIABLE this Ltest/Test8; L0 L1 0 MAXSTACK = 4 MAXLOCALS = 1&#125; 请注意这段： 1234567891011// access flags 0x1 public test()Ljava/lang/String; L0 LINENUMBER 8 L0 NEW java/lang/StringBuilder DUP INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; ()V ALOAD 0 GETFIELD test/Test8.s1 : Ljava/lang/String; INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; ALOAD 0 我们可以看到，即便我们没有显式的使用StringBuilder，实际上编译器也会隐式的将我们的 + 运算符优化为StringBuilder的append()操作；另外，其中字符串常量的相加这里，也就是 &quot;5555&quot; + &quot;66666666666666666666666666&quot; + &quot;777&quot; 这里对应的操作是： 123GETFIELD test/Test8.s4 : Ljava/lang/String; INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; LDC &quot;555566666666666666666666666666777&quot; 直接被合并在了一次(具体这是什么操作我不是很明白) 这时候我就想起来，原来一直被教导的“字符串相加一定要用StringBuilder而不要用 + ”真的正确吗？这个值得深思。 2017-01-22更新： 123GETFIELD test/Test8.s4 : Ljava/lang/String; INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; LDC &quot;555566666666666666666666666666777&quot; 直接被合并在了一次(具体这是什么操作我不是很明白) 这里可能是编译器做了“公共子表达式消除”这个优化操作 2017-01-25更新： 在循环+=的情况下，编译器也会做优化工作的，但是IDE仍然会给出警告，不知道编译器的优化是否在所有情况下均会触发（有待继续学习） 12345678public static void main(String[] args) &#123; String s = &quot;&quot;; for (int i = 0; i &lt; 10000; i++) &#123; int int_ = new Random().nextInt(); s += int_; &#125; System.out.println(s);&#125; 更新与勘误2019-08-13 更新当在循环中对字符串进行 += 操作时，会在每一次迭代中都创建一个StringBuilder，这种在循环内进行字符串 += 操作会被idea提示用 StringBuilder 替代的 123456789101112package io.since1986.demo;public class Test10 &#123; public static void main(String[] args) &#123; String s = "1111DDDDFFFGGGGG"; for (int i = 0; i &lt; 99; i++) &#123; s += "3fghjl"; &#125; System.out.println(s); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// class version 52.0 (52)// access flags 0x21public class io/since1986/demo/Test10 &#123; // compiled from: Test10.java // access flags 0x1 public &lt;init&gt;()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V RETURN L1 LOCALVARIABLE this Lio/since1986/demo/Test10; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 6 L0 LDC &quot;1111DDDDFFFGGGGG&quot; ASTORE 1 L1 LINENUMBER 7 L1 ICONST_0 ISTORE 2 L2 FRAME APPEND [java/lang/String I] ILOAD 2 BIPUSH 99 IF_ICMPGE L3 L4 LINENUMBER 8 L4 NEW java/lang/StringBuilder // 注意这里是在循环内创建 StringBuilder DUP INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; ()V ALOAD 1 INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; LDC &quot;3fghjl&quot; INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String; ASTORE 1 L5 LINENUMBER 7 L5 IINC 2 1 GOTO L2 L3 LINENUMBER 10 L3 FRAME CHOP 1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 1 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L6 LINENUMBER 11 L6 RETURN L7 LOCALVARIABLE i I L2 L3 2 LOCALVARIABLE args [Ljava/lang/String; L0 L7 0 LOCALVARIABLE s Ljava/lang/String; L1 L7 1 MAXSTACK = 2 MAXLOCALS = 3&#125; 2019-08-15 更新123GETFIELD test/Test8.s4 : Ljava/lang/String; INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; LDC &quot;555566666666666666666666666666777&quot; “5555” + “66666666666666666666666666” + “777” 直接被合并在了一块，这个操作叫 常量折叠 Java中，关于String类型的变量和常量做“+”运算时发生了什么？]]></content>
      <tags>
        <tag>JDK</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享一下我在Windows平台下的一些使用习惯]]></title>
    <url>%2Ff6e0adc6.html</url>
    <content type="text"><![CDATA[回想这十几年使用PC的经历当中，大部分时间都是在和Windows平台打交道，在十几年的使用当中，也逐渐形成了一些自己的使用习惯和经验，拿出来分享一下吧，也许大家也有各自的习惯与经验也不妨分享出来。 “桌面”就要来当桌面来用我个人有个习惯，我的桌面上只保留“回收站”一个常驻的图标，不长时间放任何其他图标(包括“我的电脑”，等，以及各类快捷方式)。我为什么这样做？既然微软把桌面(desktop)命名为“桌面”那么我想微软的意图就是想让我们把它当做三维空间中的物理桌面一样来使用。平常在物理桌面上我就不会摆放任何用不到的东西，所以这个习惯我也把它带到了二维空间里了。我虽然不会在桌面上摆放快捷方式，但是我会把最近手头上需要用到的文件临时放到上边，等不需要的时候我就会把它拽到回收站里（这也是我为什保留回收站在桌面右下角的部分原因），说到这里我觉得有必要提一下“快捷方式”这个东西，这个东西经营好了是会快捷便利，但是不注意经营维护（比如安装各类程序一般最后有个选项“是否生成桌面快捷方式”，一般默认都是“是”）桌面上一大堆快捷方式在那里，你真的觉得这样“快捷”吗？ 善用任务栏、开始菜单上面提到了，我不在桌面上摆放快捷方式，那么，我怎么样使用一些常用的软件呢？我是用快速启动栏和“固定到开始菜单”来实现的，我会把最常用的软件放入快速启动栏，而次常用的固定到开始菜单（尤其win10的开始菜单相当高效），不常用的，就到安装时生成的菜单项里找吧，反正用它的几率很低，现用现找。对于快速启动栏，我同样不会在上边放过多的快捷方式，如果过多，那就不叫“快速”了。 善用搜索提到搜索就必须要提Everything这款神器，不多说了，谁用谁知道，另外win10中自带的搜索已经很好用了，尤其还有科塔娜，那么就善加利用吧。 善用默认值我在Windows平台安装软件时，有个习惯：从不主动改变软件的安装位置（总是使用安装程序提供的默认值），除非不得已，为什么这样做？套用开发当中的一句话吧：“约定优先于配置”。 尽量避免对磁盘进行分区或少分区记得早些年的时候，都流行一上来就给硬盘分出个D、E、F、G、H来，不分不舒服，但是后来买笔记本的时候我惊奇的发现厂商只给了两个区（一个极大地C和一个很小的D），有的甚至不分区，其实想想，这样做才是对的，要那么多分区的意义何在？如果是一个分区的话剪切粘贴是秒的，跨分区的话就。。。（当然，现在一般都不再是一块硬盘了，大部分都是固态+若干机械了，这更没必要分区了）。 善用右键菜单很多软件在安装时会询问是否添加右键菜单项，一般我习惯于只保留必要的右键菜单项，不过多安装，另外WinRAR或者BandZip都是可以层叠右键菜单项的；还有，操作系统其实还内置了一个非常实用的功能：当你按住shift在文件夹上使用右键菜单时，会多出一项“在此处打开命令窗口(W)”，而在文件或文件夹上按住shift打开右键菜单时会多出一项“复制为路径(A)”，不用说也知道，这个功能对于程序员来说太实用了，不用cd N层路径了。]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于面试题“ArrayList循环remove()要用Iterator”的研究]]></title>
    <url>%2F7c4f41d7.html</url>
    <content type="text"><![CDATA[两个月前我在参加一场面试的时候，被问到了ArrayList如何循环删除元素，当时我回答用Iterator,当面试官问为什么要用Iterator而不用foreach时，我没有答出来，如今又回想到了这个问题，我觉得应该把它搞一搞，所以我就写了一个小的demo并结合阅读源代码来验证了一下。 下面是我验证的ArrayList循环remove()的4种情况,以及其结果(基于oracle jdk1.8)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//List&lt;Integer&gt; list = new ArrayList&lt;&gt;();//list.add(1);//list.add(2);//list.add(3);//list.add(4);//循环remove()的4种情况的代码片段：//#1for (Integer integer : list) &#123; list.remove(integer);&#125;结果：Exception in thread &quot;main&quot; java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851)-----------------------------------------------------------------------------------//#2Iterator&lt;Integer&gt; iterator = list.iterator();while(iterator.hasNext()) &#123; Integer integer = iterator.next(); list.remove(integer);&#125;结果：Exception in thread &quot;main&quot; java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851)-----------------------------------------------------------------------------------//#3for (int i = 0; i &lt; list.size(); i++) &#123; list.remove(i);&#125;System.out.println(list);结果：[2, 4]-----------------------------------------------------------------------------------//#4Iterator&lt;Integer&gt; iterator = list.iterator();while (iterator.hasNext())&#123; iterator.next(); iterator.remove();&#125;System.out.println(list.size());结果：(唯一一个得到期望值的)0 可以看出来这几种情况只有最后一种是得到预期结果的，其他的要么异常要么得不到预期结果，下面咱们一个一个进行分析。 #1123456789//#1for (Integer integer : list) &#123; list.remove(integer);&#125;结果：Exception in thread &quot;main&quot; java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) 通过异常栈，我们可以定位是在ArrayList的内部类Itr的checkForComodification方法中爆出了ConcurrentModificationException异常(关于这个异常是怎么回事咱们暂且不提)我们打开ArrayList的源码，定位到901行处： 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 这个爆出异常的方法实际上就做了一件事，检查modCount != expectedModCount因为满足了这个条件，所以抛出了异常，继续查看modCount和expectedModCount这两个变量，发现modCount是继承自AbstractList的一个属性，这个属性有一大段注释 123456789101112131415161718192021222324252627/** * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * Structural modifications are those that change the size of the * list, or otherwise perturb it in such a fashion that iterations in * progress may yield incorrect results. * * &lt;p&gt;This field is used by the iterator and list iterator implementation * returned by the &#123;@code iterator&#125; and &#123;@code listIterator&#125; methods. * If the value of this field changes unexpectedly, the iterator (or list * iterator) will throw a &#123;@code ConcurrentModificationException&#125; in * response to the &#123;@code next&#125;, &#123;@code remove&#125;, &#123;@code previous&#125;, * &#123;@code set&#125; or &#123;@code add&#125; operations. This provides * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in * the face of concurrent modification during iteration. * * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass * wishes to provide fail-fast iterators (and list iterators), then it * merely has to increment this field in its &#123;@code add(int, E)&#125; and * &#123;@code remove(int)&#125; methods (and any other methods that it overrides * that result in structural modifications to the list). A single call to * &#123;@code add(int, E)&#125; or &#123;@code remove(int)&#125; must add no more than * one to this field, or the iterators (and list iterators) will throw * bogus &#123;@code ConcurrentModificationExceptions&#125;. If an implementation * does not wish to provide fail-fast iterators, this field may be * ignored. */protected transient int modCount = 0; 大致的意思是这个字段用于有fail-fast行为的子集合类的，用来记录集合被修改过的次数，我们回到ArrayList可以找到在add(E e)的调用链中的一个方法ensureExplicitCapacity(int minCapacity) 中会对modCount自增： 1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 我们在初始化list时调用了4次add(E e)所以现在modCount的值为4 再来找expectedModCount：这个变量是定义在ArrayList的Iterator的实现类Itr中的，它默认被赋值为modCount 知道了这两个变量是什么了以后，我们开始走查吧，在Itr的相关方法中加好断点(编译器会将foreach编译为使用Iterator的方式，所以我们看Itr就可以了)，开始调试： 循环： 在迭代的每次next()时都会调用checkForComodification() list.remove()： 在ArrayList的remove(Object o)中又调用了fastRemove(index)： fastRemove(index)中对modCount进行了自增,刚才说过modCount经过4次add(E e)初始化后是4所以++后现在是5： 继续往下走，进入下次迭代： 又一次执行next()，next()调用checkForComodification()，这时在上边的过程中modCount由于fastRemove(index)的操作已经变成了5而expectedModCount则没有人动，所以很快就满足了抛出异常的条件modCount != expectedModCount(也就是前面提到的fail-fast)，程序退出。 #21234567891011//#2Iterator&lt;Integer&gt; iterator = list.iterator();while(iterator.hasNext()) &#123; Integer integer = iterator.next(); list.remove(integer);&#125;结果：Exception in thread &quot;main&quot; java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) 其实这个#2和#1是一样的，foreach会在编译期被优化为Iterator调用，所以看#1就好啦。 #312345678//#3for (int i = 0; i &lt; list.size(); i++) &#123; list.remove(i);&#125;System.out.println(list);结果：[2, 4] 这种一本正经的胡说八道的情况也许在写代码犯困的情况下会出现… 不做文字解释了，用println()来说明吧： 123456789101112131415161718192021222324第0次循环开始remove(0)前的list: [1, 2, 3, 4]remove(0)前的list.size()=4执行了remove(0)remove(0)后的list.size()=3remove(0)后的list: [2, 3, 4]下一次循环的i=1下一次循环的list.size()=3第0次循环结束是否还有条件进入下次循环?: true第1次循环开始remove(1)前的list: [2, 3, 4]remove(1)前的list.size()=3执行了remove(1)remove(1)后的list.size()=2remove(1)后的list: [2, 4]下一次循环的i=2下一次循环的list.size()=2第1次循环结束是否还有条件进入下次循环?: falseProcess finished with exit code 0 实际上ArrayList中Itr用游标和最后一次返回值索引来解决了这种size越删越小，但是要删除元素的index越来越大的尴尬局面，这个将在#4里说明。 #4这个才是正儿八经能够正确执行的方式，用了ArrayList中迭代器Itr的remove()而不是用ArrayList本身的remove()，我们调试一下吧看看到底经历了什么： 迭代： Itr初始化：游标 cursor = 0; 最后一次返回值索引 lastRet = -1; 期望修改次数 expectedModCount = modCount = 4; 迭代的hasNext()：检查游标是否已经到达当前list的size，如果没有则说明可以继续迭代： 迭代的next()： checkForComodification() 此时expectedModCount和modCount是相等的，不会抛出ConcurrentModificationException，然后取到游标(第一次迭代游标是0)对应的list的元素，再将游标+1，也就是游标后移指向下一个元素，然后将游标原值0赋给最后一次返回值索引，也就是最后一次返回的是索引0对应的元素 iterator.remove()：同样checkForComodification()然后调用ArrayList的remove(lastRet)删除最后返回的元素,删除后modCount会自增 删除完成后，将游标赋值成最后一次返回值索引，其实也就是将游标回退了一格回到了上一次的位置，然后将最后一次返回值索引重新设置为了初始值-1,最后expectedModCount又重新赋值为了上一步过程完成后新的modCount 由上两个步骤可以看出来，虽然list的size每次remove()都会-1，但是由于每次remove()都会将游标回退，然后将最后一次返回值索引重置，所以实际上没回remove()的都是当前集合的第0个元素，就不会出现#3中size越删越小，而要删除元素的索引越来越大的情况了，同时由于在remove()过程中expectedModCount和modCount始终通过赋值保持相等，所以也不会出现fail-fast抛出异常的情况了。 以上是我通过走查源码的方式对面试题“ArrayList循环remove()要用Iterator”做的一点研究，没考虑并发场景，这篇文章写了大概3个多小时，写完这篇文章办公室就剩我一个人了，我也该回去了，今天1024程序员节，大家节日快乐！ 2017.10.25更新#1感谢@llearn的提醒，#3也可以用用巧妙的方式来得到正确的结果的(再面试的时候，我觉得可以和面试官说不一定要用Iterator了，感谢@llearn： //#3 我觉得可以这样for (int i = 0; i &lt; list.size(); ) { list.remove(0);} System.out.println(list); 2017.10.25更新#2感谢@ChinLong的提醒，提供了另一种不用Iterator的方法，也就是倒着循环(这种方案我写完文章时也想到了，但没有自己印证到demo上)，感谢@ChinLong： 然道就没有人和我一下喜欢倒着删的.听别人说倒着迭代速度稍微快一点???for (int i = list.size() -1; i &gt;= 0; i– ) { list.remove(i);} System.out.println(list);]]></content>
      <tags>
        <tag>Java基础</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一下在学习一个知识时产生的一点点发散性的思考]]></title>
    <url>%2F4538d809.html</url>
    <content type="text"><![CDATA[今天在看一系列关于并发的文章时，在一篇文章中有一个知识点我没有接触过，于是我将这个知识点作为关键字来搜索，搜索到了另一篇文章来学习这个知识点，然后在这篇包含那个知识点的文章中又出现了另一个新的我不了解的知识点，于是又搜索到了一篇文章来了解这个知识点，等最后没有特别需要了解的知识点了，就一步步倒推回到了开始的那篇文章。这时我突然意识到，之所以出现了刚才那个递归学习的过程，是因为这几个知识是之间是相互依赖的。 这让我想到了平常经常用到的maven和gradle，以及lib依赖的概念：一个lib依赖项会依赖另一个，另一个lib可能又会依赖另另一个。。。再往上层逻辑想，其实maven和gradle在某种程度上也是在处理知识之间的依赖（因为一个lib可以看作是一个解决特定问题的知识点），再继续往上层想，其实就一个软件系统（或者泛化为任何一种系统，不一定局限于软件系统）而言，是由一个个相互依赖的知识所构成的，或者说是由一个个相互依赖的智力结果所构成的，从某个方面来说，软件系统是人类的一部分思维在现实世界中的一种映射；还可以继续向上思考，整个人类社会的文明也是建立在一个又一个相互依赖的知识体系上的，这些知识体系有些是从上古时代一代一代更新演化的，有的是新的发现，他们之间或多或少也是有关联的，是一个个相互关联的智力结果所构成的；在这个层面上看软件系统体系和人类的文明体系是很像的；从这里我们还可以继续发散思维：当在一个层面或者说系统中遇到解决不了的问题时，可以跳到更大的上下文环境（context）里去想办法，也就是向上层逻辑思考然后将上层逻辑的思考进行向下的抽象然后解决下层的问题。其实想想面向对象这种编程模型的出现，不也是尝试将现实世界进行抽象，从而试图解决计算机系统中某个方面的问题吗。这样的例子应该还有很多。这让我想到了小时候经常听的单田芳评书，总会有这么样的一句话：“（某人）虚晃一招，跳出圈外。”也许当我们遇到某个解决不了的问题时，也应该“跳出圈外”，而不是仅仅着眼于问题本身，跳出圈外去更广阔的context中寻找解决问题的方案，然后将解决问题的办法抽象到下层的逻辑context中。 发散的比较远。。。算是一点点思考总结吧。]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重做一道Java面试题(Fork/Join)]]></title>
    <url>%2F111da3a8.html</url>
    <content type="text"><![CDATA[前几天参加了一场面试，当时有这莫一道题： 1如何充分利用多核CPU，计算很大List中所有整数的和？ 老实说，我当时并没有想出来具体该如何实现，只是有个大致的方向，肯定是分治法的思想；这两天我一直在尝试将这些当时没做出来的题想办法做出来，查了一些资料，看了若干文章，现在反过头来再来尝试解决一下这个题吧。 经过这两天的学习，我基本上搜集到了两种解这道题的思路：1.用CyclicBarrier这种方法，有网友给出了详尽的解释，在此不再复述。 2.用Fork/Join这个方法我是受到了这几篇文章的启发： JDK 7 中的 Fork/Join 模式 我的Java开发学习之旅——&gt;Java使用Fork/Join框架来并行执行任务 Java 多线程（5）：Fork/Join 型线程池与 Work-Stealing 算法 具体的看代码吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.github.since1986.test;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.Future;import java.util.concurrent.RecursiveTask;import java.util.stream.IntStream;/** * Created by since1986 on 2017/9/17. */public class ForkJoinTest &#123; public static void main(String... args) throws InterruptedException, ExecutionException &#123; int[] array = IntStream.rangeClosed(0, 1_00_000_000).toArray(); //模拟一个“很大”的List，这里用直接用数组代替了（题目里其实也没说明白“很大”到底是什么概念，实际上太大了会OOM，但我觉得这道题主要考查的是对并发编程的基本思路吧，应该不会考察太深的，所以不用在意了，要是确实是要把怎么样避免OOM也考虑到的话暂时还没想到应该怎样解决） //简单粗暴的做法 int sum = 0; for (int i = 0; i &lt; array.length; i++) &#123; sum += array[i]; &#125; System.out.println(sum); //Fork/Join的做法 ForkJoinPool forkJoinPool = new ForkJoinPool(); //起一个数量等于可用CPU核数的池子（对应题目中“充分利用多核”） Task task = new Task(0, array.length, 10_000, array); Future&lt;Integer&gt; future = forkJoinPool.submit(task); //提交Task System.out.println(future.get()); //获得返回值 forkJoinPool.shutdown(); //关闭池子 &#125; static class Task extends RecursiveTask&lt;Integer&gt; &#123; public static final int DEFAULT_THRESHOLD = 1000; private int high, low; private int threshold; private int[] array; Task(int low, int high, int threshold, int[] array) &#123; this.array = array; this.low = low; this.high = high; this.threshold = threshold; //任务划分的最小值（若为1000则含义是Fork到1000大小时就不再继续Fork了） &#125; @Override protected Integer compute() &#123; //System.out.println(&quot;low: &quot; + low + &quot; high: &quot; + high); if (high - low &lt;= threshold) &#123; //到了不能再Fork的阈值后直接循环累加返回 int sum = 0; for (int i = low; i &lt; high; i++) &#123; sum += array[i]; &#125; //System.out.println(&quot;sum: &quot; + sum); return sum; &#125; else &#123; //没有到阈值的话，继续递归拆分任务为左任务和右任务（分治法的思想） int middle = (high - low) / 2 + low; //System.out.println(&quot;middle: &quot; + middle); Task leftHandTask = new Task(low, middle, threshold, array); //左任务 Task rightHandTask = new Task(middle, high, threshold, array); //右任务 leftHandTask.fork(); //左任务还要继续拆，直到满足上边if里的阈值条件 rightHandTask.fork(); //右任务也要继续拆，直到满足上边if里的阈值条件 return leftHandTask.join() + rightHandTask.join(); //最后Join得到结果 &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GestureDetector实现双击Toolbar后将RecyclerView平缓滚动至顶部]]></title>
    <url>%2F861f3bbe.html</url>
    <content type="text"><![CDATA[现在很多的App都会有双击Toolbar后将内容列表RecyclerView平缓滚动至顶部的功能，这个功能大大提升了用户体验，那么，该如何实现呢 实现这个功能的关键可以分为两点 实现双击手势的监听 实现RecyclerView的平滑滚动 第一点，实现双击手势监听，这个我当时走了一点点弯路，我当时想在onTouch里自己手动实现双击的判断，但是写了一半突然想到，google不可能想不到双击手势处理的这种场景，必然会有相关的类来处理的，于是搜了一下，果不其然，sdk里有个GestureDetector就是专门干这个的，不光双击、还有甩动、单击等等几个手势的处理，google果然很贴心，都替我们想好了。然后，就是第二点，实现RecyclerView平滑滚动到顶部，这里也有一个需要注意的点，那就是平滑滚动的触发条件，可以想象一下，如果现在RecyclerView已经显示到了第9999条数据（举个例子，实际可能遇不到这么大的数），这时要触发平滑滚动，从第9999慢慢的平滑滚动回第0，用户会崩溃的，所以，我们需要设置一个阈值，到了某一个值才开始平滑滚动，没到这个值就直接瞬间滚动到这个值，然后再开始平滑滚动，这样在用户看来就像是整个在平滑滚动，而且不会太慢。说了这么多，最终我们还是要用代码来实现它，那么我们还是来上代码吧，看看怎么实现Toolbar的双击监听： 123456789101112131415161718192021//代码片段final GestureDetector gestureDetector = new GestureDetector(SomeActivity.this, new GestureDetector.SimpleOnGestureListener() &#123; //使用SimpleOnGestureListener可以只覆盖实现自己想要的手势 @Override public boolean onDoubleTap(MotionEvent e) &#123; //DoubleTap手势的处理 LinearLayoutManager linearLayoutManager = (LinearLayoutManager) recyclerView.getLayoutManager(); if (linearLayoutManager.findFirstCompletelyVisibleItemPosition() != 0) &#123; //判断一下，如果现在RecyclerView不是已经显示了最顶部条目时，才需要做滚动到顶部的处理 if (linearLayoutManager.getItemCount() &gt; SMOOTH_SCROLL_THRESHOLD) &#123; //SMOOTH_SCROLL_THRESHOLD就是上边我们说的那个触发平滑滚动的阈值，这里设置一个比较小的数就可以了，比如 10 ，当现在RecyclerView显示的数目大于这个阈值时就需要进行前边提到的“先瞬间滚动然后再平滑滚动的处理了” recyclerView.scrollToPosition(SMOOTH_SCROLL_THRESHOLD); //先瞬间滚动到THRESHOLD位置 &#125; recyclerView.smoothScrollToPosition(0); //然后再继续平滑滚动，这样既不会太慢又保留了平滑的效果 &#125; return super.onDoubleTap(e); &#125;&#125;);toolbar.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; //使用GestureDetector对Toolbar进行手势监听 return gestureDetector.onTouchEvent(event); &#125;&#125;);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧用枚举来处理UI中显示值与业务值不同的场景]]></title>
    <url>%2Fc36ec2a4.html</url>
    <content type="text"><![CDATA[在Android中，经常会遇到一些在UI上显示的值与实际业务需要的值不一致的场景，这时就是枚举发挥用武之地的时候了 看下图所示的这个场景： 这个场景是一个类似于web中&lt;select&gt;的场景（图中这个下拉组件是我自己写的一个自定义View，用于替换SDK内置的Spinner），从这个场景中不难看出，我们在UI中需要显示的值和业务逻辑中需要的值是不一样的（后端给的接口定义了一组数字来作为参数），我们不能直接把UI中的“正面”这两个字作为参数传给业务逻辑的方法，而应传递一个对应于“正面”的值，该如何实现这个场景呢，这时候枚举就该登场了 Talk is cheap. Show me the code. 1234567891011121314151617181920212223242526272829303132//代码片段1public enum Relativity &#123; //直接使用中文来给枚举命名，从而利用继承自父类的 .toString() 来返回UI需要的值 全部 &#123; @Override public String value() &#123; return &quot;&quot;; &#125; &#125;, 正面 &#123; @Override public String value() &#123; return &quot;1&quot;; &#125; &#125;, 中性 &#123; @Override public String value() &#123; return &quot;0&quot;; &#125; &#125;, 负面 &#123; @Override public String value() &#123; return &quot;-1&quot;; &#125; &#125;; public abstract String value(); //定义一个抽象方法让子类来实现，这个方法的返回值是业务逻辑中需要用到的值&#125; 12//代码片段2 （这个 bindData 是我自定义View里的绑定数据的方法，实际上里面是调用了ArrayAdapter的addAll(T... items)）spinnerRelativity.bindData(Relativity.values()); //直接使用枚举的 .values() 返回所有此类枚举所组成的数组作为参数传给UI 1234567891011//代码片段3 spinnerRelativity.setOnValueChangeListener(new OnValueChangeListener() &#123; @Override public void onValueChange(View view, CharSequence originalValue, CharSequence newValue) &#123; relativity = Relativity.valueOf((String) newValue) //onValueChange 是我自定义View里的一个回调方法，如图所示，当用户选中“全部”时方法的第二个CharSequence参数“newValue”的值就是一个字符串 &quot;全部&quot;， 这时，利用枚举的 valueOf(String s) 方法就可以从这个字符串得到对应的枚举对象 .value(); //得到枚举对象后再调用枚举中自定义的 .value() 获得业务逻辑所需要的值 //此处是你的业务逻辑 &#125;&#125;);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toolbar 的最基本使用]]></title>
    <url>%2F80327352.html</url>
    <content type="text"><![CDATA[Toolbar是ActionBar的替代者，对于刚刚入门的Android开发者，也许会对怎样使用Toolbar感到困惑(比如那时的我。。。)，所以我把Toolbar的最最基础的使用方法简单写一下，希望能帮到刚入门的朋友 **如何去掉默认的`ActionBar`：** 在`styles.xml`中创建一个主题`AppTheme.NoActionBar` 12345&lt;!-- NoActionBar --&gt;&lt;style name=&quot;AppTheme.NoActionBar&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;&lt;/style&gt; 将这个主题应用到application上，即可去除所有Activity默认的ActionBar 12345&lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt; &lt;!-- 去掉默认的ActionBar --&gt; **如何修改`Toolbar`默认的文字颜色：** 在`style.xml`中添加主题 12345678&lt;style name=&quot;AppTheme.Toolbar&quot;&gt; &lt;item name=&quot;colorControlNormal&quot;&gt;#FFEFEFEF&lt;/item&gt; &lt;item name=&quot;android:textColorPrimary&quot;&gt;#FFEFEFEF&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;AppTheme.Toolbar.Popup&quot;&gt; &lt;item name=&quot;android:textColorPrimary&quot;&gt;@android:color/black&lt;/item&gt;&lt;/style&gt; 然后将主题应用到Toolbar上 1234567&lt;!-- 改变文字颜色 --&gt;&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/your_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:popupTheme=&quot;@style/AppTheme.Toolbar.Popup&quot; app:theme=&quot;@style/AppTheme.Toolbar&quot; /&gt; **如何加上返回按钮并实现返回：** 123Toolbar toolbar = (Toolbar) findViewById(R.id.your_toolbar);setSupportActionBar(toolbar);getSupportActionBar().setDisplayHomeAsUpEnabled(true); //启用返回按钮 1234567891011//实现返回功能@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case android.R.id.home: //android.R.id.home是Android内置home按钮的id finish(); break; &#125; return super.onOptionsItemSelected(item);&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TabLayout 加载后默认选中某个 Tab]]></title>
    <url>%2Ff804f392.html</url>
    <content type="text"><![CDATA[在使用 TabLayout 时一般会有加载完成后立刻选中某个Tab的需求，如何实现呢，我曾经尝试过将Tab在XML中写成静态的然后用 getTabAt(i).select() 来选中，但是并不起作用，然后尝试了动态添加Tab的方式，也就是用 addTab(TabLayout.Tab tab, boolean setSelected) 的方式，这样就会默认的选中了，TODO 暂时没搞明白为什么 getTabAt(i).select() 不起作用，以后再研究]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Tag、 反射原理 和 findFragmentByTag 少写代码实现Tab 切换时实例化、显示、隐藏 Fragment]]></title>
    <url>%2F21c4e1a1.html</url>
    <content type="text"><![CDATA[在一些场景里， TabLayout 会对应一组Fragment，然后通过 onTabSelected(TabLayout.Tab tab) 来触发Tab所对应Fragment的 add() (实例化) show() 与 hide() ，那么如何尽量少写代码来实现这个场景呢？ 我的解决方案是用 Tag、 反射原理 以及 FragmentManager 的 findFragmentByTag(String tag) 方法 将Fragment的类的限定名作为 Tag 附加到 Tab 上 onTabSelected(TabLayout.Tab tab) 时获取 Tab 对应的 Tag这时获得的就是Fragment的限定名 利用反射通过限定名实例化Fragment并 add() show() 对应的Fragment hide() 也是同样的道理 代码片段： 1234567891011121314151617181920212223242526tabLayout = (TabLayout) findViewById(R.id.tab_layout); final TabLayout.Tab tab1 = tabLayout .newTab() .setText(R.string.text_1) .setTag(Tab1Fragment.class.getName()); //用Fragment的限定名作为Tag TabLayout.Tab tab2 = tabLayout .newTab() .setText(R.string.text_2) .setTag(Tab2Fragment.class.getName()); TabLayout.Tab tab3 = tabLayout .newTab() .setText(R.string.text_3) .setTag(Tab3Fragment.class.getName()); tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; FragmentUtils.showBeforeAddByTag(SomeActivity.this, R.id.frame_layout_fragment_container, (String) tab.getTag()); //用Tab的Tag来进一步完成Fragment的add show hide &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; FragmentUtils.hideByTag(SomeActivity.this, (String) tab.getTag()); &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; &#125; &#125;); FragmentUtils代码片段： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//通过反射实例化Fragment @Nullablepublic static Fragment reflectionNewInstance(@NonNull String fragmentClassName, Object... args) &#123; Class&lt;?&gt;[] parameterTypes; if (args == null) &#123; parameterTypes = new Class[0]; &#125; else &#123; parameterTypes = new Class[args.length]; for (int i = 0; i &lt; args.length; i++) &#123; parameterTypes[i] = args[i].getClass(); &#125; &#125; try &#123; Method method = Class.forName(fragmentClassName).getMethod(&quot;newInstance&quot;, parameterTypes); return (Fragment) method.invoke(null, args); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return null;&#125;//添加Fragmentpublic static Fragment addByTag(FragmentActivity fragmentActivity, int containerResourceId, String tag, Bundle arguments) &#123; FragmentManager fragmentManager = fragmentActivity.getSupportFragmentManager(); Fragment fragment = reflectionNewInstance(tag); fragment.setArguments(arguments); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.add(containerResourceId, fragment, tag); fragmentTransaction.commit(); return fragment;&#125;//显示Fragmentpublic static void showByTag(FragmentActivity fragmentActivity, String tag) &#123; FragmentManager fragmentManager = fragmentActivity.getSupportFragmentManager(); Fragment fragment = fragmentManager.findFragmentByTag(tag); //通过Tab上的tag查找Fragment实例 FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.show(fragment); fragmentTransaction.commit();&#125;//隐藏Fragmentpublic static void hideByTag(FragmentActivity fragmentActivity, String tag) &#123; FragmentManager fragmentManager = fragmentActivity.getSupportFragmentManager(); Fragment fragment = fragmentManager.findFragmentByTag(tag); if (fragment != null) &#123; FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.hide(fragment); fragmentTransaction.commit(); &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Installation error: Unknown failure 的解决]]></title>
    <url>%2Fc19c627d.html</url>
    <content type="text"><![CDATA[今天在开发时用Android studio debug方式往真机上安装app时爆出了Installation error: Unknown failure 后来试了很多种网上说的方法尝试解决，包括： 使用 adb kill-server 和 adb start-server 重启计算机 然后我甚至重装了SDK和Android studio 都无济于事 后来看到网上有人说关闭小米的MIUI优化就可以了，试了试果然行了！ 如果哪位是用小米真机调试的也出了这个错误可以试试，这个不大不小的坑害我填了一下午，浪费时间，而且很诡异的是前一阵我调试时这个MIUI优化一直开着，也没出问题，就是今天我把Android studio升级到了2.3以后问题就出现了，不知道具体是什么情况 另外我看还爆出了另一个警告，不知道和这个有无关系，先记录一下 12316:38 Instant Run detected that you are running on a target device that has a work profile or multiple user accounts. Launching the app under a work profile or another user account on the target device will result in a crash. Learn more about how to run your app under a work profile.]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text 2中关闭记住上次打开的文件]]></title>
    <url>%2Fd53c0d6c.html</url>
    <content type="text"><![CDATA[感觉sublime的记住上次打开文件的功能很烦，把他关掉吧 在”User/Preferences.sublime-settings”配置文件中增加条目： &quot;hot_exit&quot;: false, &quot;remember_open_files&quot;: false这样再打开就清爽多了。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[osx中让idea使用官方版的git]]></title>
    <url>%2F649b00b7.html</url>
    <content type="text"><![CDATA[idea安装好后默认的git是osx自带的那个git，版本应该比较久，而且打开会弹出一个什么Xcode的提示框，所以还是去官方下载最新的git并安装吧，安装后git的路径为/usr/local/git/bin/git在idea中配置好就可以使用了。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpstorm使用svn爆出“cannot load supported formats” 的解决]]></title>
    <url>%2Fe442e25e.html</url>
    <content type="text"><![CDATA[从这 http://subversion.apache.org/packages.html 下载svn客户端二进制包后修改phpstorm配置中 svn的指向到你的svn可执行程序即可解决]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-data-jpa中findOne与getOne的区别]]></title>
    <url>%2F95c6f649.html</url>
    <content type="text"><![CDATA[项目中用到了spring-data-jpa，今天在写一个update方法的时候报了个空指针，看了看是因为一个对象中的关联没有取出来，我用的是getOne取得这个对象，加断点看以一下这个对象是个hibernate的代理对象，而不是实体，里面基本没有值。 然后我又换成findOne试了一下，断点查看这个取出来的对象，这个对象是实体，关联也有。 findOne与getOne的注释中也有些帮助 /** * Retrieves an entity by its id. * * @param id must not be {@literal null}. * @return the entity with the given id or {@literal null} if none found * @throws IllegalArgumentException if {@code id} is {@literal null} */ T findOne(ID id); /** * Returns a reference to the entity with the given identifier. * * @param id must not be {@literal null}. * @return a reference to the entity with the given identifier. * @see EntityManager#getReference(Class, Object) */ T getOne(ID id);注意getOne是“Returns a reference“]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu中将java环境由安装版的openjdk替换为tar版的jdk]]></title>
    <url>%2Fd2972353.html</url>
    <content type="text"><![CDATA[1.安置好你的tar版的jdk 2.运行命令： sudo gedit ~/.bashrc 从而用gedit编辑～/.bashrc来设置环境变量： export JAVA_HOME=/your/path/to/jdk export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib export PATH=${JAVA_HOME}/bin:$PATH3.运行命令： sudo update-alternatives --install /usr/bin/java java /your/path/to/jdk/bin/java 300 sudo update-alternatives --install /usr/bin/javac javac /your/path/to/jdk/bin/javac 3004.运行命令按提示选择你的tar版jdk： sudo update-alternatives --config java]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu修改root密码]]></title>
    <url>%2Fe591e851.html</url>
    <content type="text"><![CDATA[sudo passwd]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让spring mvc支持put请求]]></title>
    <url>%2F844b7f17.html</url>
    <content type="text"><![CDATA[今天在写一个rest controller的时候发现接收不到put的ajax请求，搜了一下，只要加上HttpPutFormContentFilter就可以解决了]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[osx中让idea支持jdk8的方法]]></title>
    <url>%2F97e6e554.html</url>
    <content type="text"><![CDATA[osx中如果你安装的是7即以上版本的jdk，是无法正常打开idea的，需要修改idea的配置。 打开idea包下的info.plist文件，找到： &lt;key&gt;JVMVersion&lt;/key&gt; &lt;string&gt;1.6*&lt;/string&gt;并替换为： &lt;key&gt;JVMVersion&lt;/key&gt; &lt;string&gt;1.8*&lt;/string&gt;这样就可以正常打开了。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决开发环境与部属环境差异性的一种实践]]></title>
    <url>%2Ff5f866c1.html</url>
    <content type="text"><![CDATA[做spring web的同学可能都会遇到开发环境与部属环境不一致的情况，比如说数据库的用户名与密码，单点登录服务器的域名，等等，要是每回开发完成需要部署时都再去改一遍配置文件岂不是非常麻烦。 于是，我在我得一个项目中实践了一种能够在部署时无需修改配置文件的方法，他的关键就是使用spring的 &lt;util:properties&gt; ： &lt;context:property-placeholder properties-ref=&quot;app&quot;/&gt; &lt;!-- spring的&lt;util:properties&gt;有这样两点特性： 1.默认情况下spring会用外部properties文件中的properties替换掉“local”的properties(也就是使用&lt;prop&gt;配置的properties) 2.配置了“ignore-resource-not-found=true”就会忽略找不到的properties文件 利用这两点特性，将开发级的环境写在外部properties文件中，并设置成“ignore-resource-not-found=true”，同时将生产级的环境写在&lt;prop&gt;中，这样，当部署后因为忽略了找不到的外部properties文件，所以自然就使用了&lt;prop&gt;中定义的properties; 同时，在开发环境中，因为能够找到外部的properties文件，所以外部配置(开发级配置)就会覆盖掉local的配置(生产级配置)。 通过这样的方法在部署时就不需修改任何配置了。 --&gt; &lt;util:properties id=&quot;app&quot; ignore-resource-not-found=&quot;true&quot; location=&quot;file:C:/Dev/workspace/admin/user/src/main/resources/app-config.properties&quot;&gt; &lt;!-- 生产环境 --&gt; &lt;prop key=&quot;dataSource.url&quot;&gt;jdbc:mysql://localhost:3306/admin_user&lt;/prop&gt; &lt;prop key=&quot;dataSource.username&quot;&gt;dev&lt;/prop&gt; &lt;prop key=&quot;dataSource.password&quot;&gt;pass&lt;/prop&gt; &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;validate&lt;/prop&gt; &lt;prop key=&quot;hibernate.show_sql&quot;&gt;false&lt;/prop&gt; &lt;prop key=&quot;cas.service&quot;&gt;somedomain:8444/user&lt;/prop&gt; &lt;prop key=&quot;cas.server&quot;&gt;somedomain:8444/cas&lt;/prop&gt; &lt;prop key=&quot;cas.key&quot;&gt;CAS_KEY_ADMIN.USER&lt;/prop&gt; &lt;/util:properties&gt;]]></content>
      <tags>
        <tag>实践</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在linux中安装rpm版的mysql5.6的注意事项]]></title>
    <url>%2F5ad5f4e2.html</url>
    <content type="text"><![CDATA[建议先看看官方给出的安装文档 http://dev.mysql.com/doc/refman/5.7/en/linux-installation-rpm.html 安装完毕后会生成一个随机的root密码，密码保存在用户主目录下的.mysql_secret文件中 刚安装后使用/etc/init.d/下的名为mysql的脚本来启动mysql服务器 sh /etc/init.d/mysql start 启动后使用客户端连接，没修改root密码前只能使用 SET PASSWORD 命令SET PASSWORD = PASSWORD(&#39;your_new_root_password&#39;);]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.docx 文件是可以用winrar看到层级结构的]]></title>
    <url>%2Fa310293b.html</url>
    <content type="text"><![CDATA[今天偶尔在一个.zip文件里面的.docx文件上点了一下&ldquo;查看文件&rdquo;结果竟然打开了一个层级结构，有些出乎意料，也许以后能用得到这个特性。]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring security 中启用角色继承、ACL与CAS]]></title>
    <url>%2F947f7f30.html</url>
    <content type="text"><![CDATA[做项目时需要用到角色继承、ACL和CAS，在网上搜了几篇文章，写的实在是误人子弟，索性翻了翻源码、文档与官方示例，做了一份配置，供需要的朋友参考。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans:beans xmlns=&quot;http://www.springframework.org/schema/security&quot; xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd&quot;&gt; &lt;!-- 方法安全 --&gt; &lt;global-method-security secured-annotations=&quot;enabled&quot; pre-post-annotations=&quot;enabled&quot; jsr250-annotations=&quot;enabled&quot; access-decision-manager-ref=&quot;methodAccessDecisionManager&quot;&gt; &lt;expression-handler ref=&quot;methodSecurityExpressionHandler&quot;/&gt; &lt;after-invocation-provider ref=&quot;postInvocationAdviceProvider&quot;/&gt; &lt;/global-method-security&gt; &lt;!-- HTTP安全 --&gt; &lt;http pattern=&quot;/proxy.html&quot; security=&quot;none&quot; /&gt; &lt;http entry-point-ref=&quot;casEntryPoint&quot; use-expressions=&quot;true&quot; access-decision-manager-ref=&quot;webAccessDecisionManager&quot;&gt; &lt;expression-handler ref=&quot;webSecurityExpressionHandler&quot;/&gt; &lt;intercept-url pattern=&quot;/&quot; access=&quot;hasRole(&apos;ROLE_USER&apos;)&quot;/&gt; &lt;custom-filter ref=&quot;requestSingleLogoutFilter&quot; before=&quot;LOGOUT_FILTER&quot;/&gt; &lt;custom-filter ref=&quot;singleLogoutFilter&quot; before=&quot;CAS_FILTER&quot;/&gt; &lt;custom-filter ref=&quot;casFilter&quot; position=&quot;CAS_FILTER&quot;/&gt; &lt;/http&gt; &lt;!-- ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓授权(Authorization)配置↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ --&gt; &lt;beans:bean id=&quot;aclAuthorizationStrategy&quot; class=&quot;org.springframework.security.acls.domain.AclAuthorizationStrategyImpl&quot;&gt; &lt;beans:constructor-arg name=&quot;auths&quot;&gt; &lt;beans:list&gt; &lt;beans:ref bean=&quot;supervisor&quot;/&gt; &lt;beans:ref bean=&quot;supervisor&quot;/&gt; &lt;beans:ref bean=&quot;supervisor&quot;/&gt; &lt;/beans:list&gt; &lt;/beans:constructor-arg&gt; &lt;/beans:bean&gt; &lt;beans:bean id=&quot;permissionGrantingStrategy&quot; class=&quot;org.springframework.security.acls.domain.DefaultPermissionGrantingStrategy&quot;&gt; &lt;beans:constructor-arg name=&quot;auditLogger&quot;&gt; &lt;beans:bean class=&quot;org.springframework.security.acls.domain.ConsoleAuditLogger&quot;/&gt; &lt;/beans:constructor-arg&gt; &lt;/beans:bean&gt; &lt;beans:bean id=&quot;supervisor&quot; class=&quot;org.springframework.security.core.authority.SimpleGrantedAuthority&quot;&gt; &lt;beans:constructor-arg name=&quot;role&quot; value=&quot;ROLE_SUPERVISOR&quot;/&gt; &lt;/beans:bean&gt; &lt;beans:bean id=&quot;aclCache&quot; class=&quot;org.springframework.security.acls.domain.EhCacheBasedAclCache&quot;&gt; &lt;beans:constructor-arg name=&quot;cache&quot;&gt; &lt;beans:bean class=&quot;org.springframework.cache.ehcache.EhCacheFactoryBean&quot;&gt; &lt;beans:property name=&quot;overflowToDisk&quot; value=&quot;true&quot;/&gt; &lt;beans:property name=&quot;maxElementsInMemory&quot; value=&quot;1024&quot;/&gt; &lt;/beans:bean&gt; &lt;/beans:constructor-arg&gt; &lt;beans:constructor-arg name=&quot;permissionGrantingStrategy&quot; ref=&quot;permissionGrantingStrategy&quot;/&gt; &lt;beans:constructor-arg name=&quot;aclAuthorizationStrategy&quot; ref=&quot;aclAuthorizationStrategy&quot;/&gt; &lt;/beans:bean&gt; &lt;beans:bean id=&quot;lookupStrategy&quot; class=&quot;org.springframework.security.acls.jdbc.BasicLookupStrategy&quot;&gt; &lt;beans:constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;beans:constructor-arg name=&quot;aclCache&quot; ref=&quot;aclCache&quot;/&gt; &lt;beans:constructor-arg name=&quot;aclAuthorizationStrategy&quot; ref=&quot;aclAuthorizationStrategy&quot;/&gt; &lt;beans:constructor-arg name=&quot;grantingStrategy&quot; ref=&quot;permissionGrantingStrategy&quot;/&gt; &lt;/beans:bean&gt; &lt;beans:bean id=&quot;aclService&quot; class=&quot;org.springframework.security.acls.jdbc.JdbcMutableAclService&quot;&gt; &lt;beans:constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;beans:constructor-arg name=&quot;lookupStrategy&quot; ref=&quot;lookupStrategy&quot;/&gt; &lt;beans:constructor-arg name=&quot;aclCache&quot; ref=&quot;aclCache&quot;/&gt; &lt;beans:property name=&quot;classIdentityQuery&quot; value=&quot;select @@identity&quot;/&gt;&lt;!-- select @@identity用于获得刚刚插入的自增id select LAST_INSERT_ID() --&gt; &lt;beans:property name=&quot;sidIdentityQuery&quot; value=&quot;select @@identity&quot;/&gt; &lt;/beans:bean&gt; &lt;!-- 通过表达式使用ACL --&gt; &lt;beans:bean id=&quot;aclPermissionEvaluator&quot; class=&quot;org.springframework.security.acls.AclPermissionEvaluator&quot;&gt; &lt;beans:constructor-arg name=&quot;aclService&quot; ref=&quot;aclService&quot;/&gt; &lt;/beans:bean&gt; &lt;!-- 角色继承 --&gt; &lt;beans:bean id=&quot;roleHierarchy&quot; class=&quot;org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl&quot;&gt; &lt;beans:property name=&quot;hierarchy&quot;&gt; &lt;beans:value&gt; ROLE_DEVELOPER &gt; ROLE_SUPERVISOR ROLE_SUPERVISOR &gt; ROLE_ADMIN ROLE_ADMIN &gt; ROLE_USER &lt;/beans:value&gt; &lt;/beans:property&gt; &lt;/beans:bean&gt; &lt;!-- 用于web的ExpressionHandler --&gt; &lt;beans:bean id=&quot;webSecurityExpressionHandler&quot; name=&quot;webSecurityExpressionHandler&quot; class=&quot;org.springframework.security.web.access.expression.DefaultWebSecurityExpressionHandler&quot;&gt; &lt;beans:property name=&quot;roleHierarchy&quot; ref=&quot;roleHierarchy&quot;/&gt; &lt;beans:property name=&quot;permissionEvaluator&quot; ref=&quot;aclPermissionEvaluator&quot;/&gt; &lt;/beans:bean&gt; &lt;!-- 用于method的ExpressionHandler --&gt; &lt;beans:bean id=&quot;methodSecurityExpressionHandler&quot; class=&quot;org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler&quot;&gt; &lt;beans:property name=&quot;roleHierarchy&quot; ref=&quot;roleHierarchy&quot;/&gt; &lt;beans:property name=&quot;permissionCacheOptimizer&quot;&gt; &lt;beans:bean class=&quot;org.springframework.security.acls.AclPermissionCacheOptimizer&quot;&gt; &lt;beans:constructor-arg name=&quot;aclService&quot; ref=&quot;aclService&quot;/&gt; &lt;/beans:bean&gt; &lt;/beans:property&gt; &lt;beans:property name=&quot;permissionEvaluator&quot; ref=&quot;aclPermissionEvaluator&quot;/&gt; &lt;/beans:bean&gt; &lt;!-- 用于web(taglib以及url)的AccessDecisionManager --&gt; &lt;beans:bean id=&quot;webAccessDecisionManager&quot; class=&quot;org.springframework.security.access.vote.AffirmativeBased&quot;&gt; &lt;beans:constructor-arg&gt; &lt;beans:list&gt; &lt;beans:bean class=&quot;org.springframework.security.web.access.expression.WebExpressionVoter&quot;&gt; &lt;beans:property name=&quot;expressionHandler&quot; ref=&quot;webSecurityExpressionHandler&quot;/&gt; &lt;/beans:bean&gt; &lt;beans:bean class=&quot;org.springframework.security.access.vote.RoleHierarchyVoter&quot;&gt; &lt;beans:constructor-arg ref=&quot;roleHierarchy&quot;/&gt; &lt;/beans:bean&gt; &lt;beans:bean class=&quot;org.springframework.security.access.vote.AuthenticatedVoter&quot;/&gt; &lt;/beans:list&gt; &lt;/beans:constructor-arg&gt; &lt;/beans:bean&gt; &lt;!-- 用于method的AccessDecisionManager --&gt; &lt;beans:bean id=&quot;methodAccessDecisionManager&quot; class=&quot;org.springframework.security.access.vote.AffirmativeBased&quot;&gt; &lt;beans:constructor-arg&gt; &lt;beans:list&gt; &lt;beans:bean class=&quot;org.springframework.security.access.vote.RoleHierarchyVoter&quot;&gt; &lt;beans:constructor-arg ref=&quot;roleHierarchy&quot;/&gt; &lt;/beans:bean&gt; &lt;beans:bean class=&quot;org.springframework.security.access.vote.AuthenticatedVoter&quot;/&gt; &lt;beans:bean class=&quot;org.springframework.security.access.prepost.PreInvocationAuthorizationAdviceVoter&quot;&gt; &lt;beans:constructor-arg name=&quot;pre&quot;&gt; &lt;beans:bean class=&quot;org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice&quot;&gt; &lt;beans:property name=&quot;expressionHandler&quot; ref=&quot;methodSecurityExpressionHandler&quot;/&gt; &lt;/beans:bean&gt; &lt;/beans:constructor-arg&gt; &lt;/beans:bean&gt; &lt;beans:bean class=&quot;org.springframework.security.access.annotation.Jsr250Voter&quot;/&gt; &lt;/beans:list&gt; &lt;/beans:constructor-arg&gt; &lt;/beans:bean&gt; &lt;!-- 后置过滤 --&gt; &lt;beans:bean id=&quot;postInvocationAdviceProvider&quot; class=&quot;org.springframework.security.access.prepost.PostInvocationAdviceProvider&quot;&gt; &lt;beans:constructor-arg name=&quot;postAdvice&quot;&gt; &lt;beans:bean class=&quot;org.springframework.security.access.expression.method.ExpressionBasedPostInvocationAdvice&quot;&gt; &lt;beans:constructor-arg name=&quot;expressionHandler&quot; ref=&quot;methodSecurityExpressionHandler&quot;/&gt; &lt;/beans:bean&gt; &lt;/beans:constructor-arg&gt; &lt;/beans:bean&gt; &lt;!-- ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑/授权(Authorization)配置↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ --&gt; &lt;!-- ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓认证(Authentication)配置↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ --&gt; &lt;authentication-manager alias=&quot;authManager&quot;&gt; &lt;authentication-provider ref=&quot;casAuthProvider&quot;/&gt; &lt;/authentication-manager&gt; &lt;beans:bean id=&quot;userService&quot; class=&quot;org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl&quot;&gt; &lt;beans:property name=&quot;enableGroups&quot; value=&quot;true&quot;/&gt; &lt;beans:property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/beans:bean&gt; &lt;!-- This filter handles a Single Logout Request from the CAS Server --&gt; &lt;beans:bean id=&quot;singleLogoutFilter&quot; class=&quot;org.jasig.cas.client.session.SingleSignOutFilter&quot;/&gt; &lt;!-- This filter redirects to the CAS Server to signal Single Logout should be performed --&gt; &lt;beans:bean id=&quot;requestSingleLogoutFilter&quot; class=&quot;org.springframework.security.web.authentication.logout.LogoutFilter&quot;&gt; &lt;beans:property name=&quot;filterProcessesUrl&quot; value=&quot;/j_spring_cas_security_logout&quot;/&gt; &lt;beans:constructor-arg name=&quot;logoutSuccessUrl&quot; value=&quot;https://${cas.server}/logout&quot;/&gt; &lt;beans:constructor-arg name=&quot;handlers&quot;&gt; &lt;beans:bean class=&quot;org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler&quot;/&gt; &lt;/beans:constructor-arg&gt; &lt;/beans:bean&gt; &lt;beans:bean id=&quot;serviceProperties&quot; class=&quot;org.springframework.security.cas.ServiceProperties&quot;&gt; &lt;beans:property name=&quot;service&quot; value=&quot;https://${cas.service}/j_spring_cas_security_check&quot;/&gt; &lt;/beans:bean&gt; &lt;beans:bean id=&quot;casEntryPoint&quot; class=&quot;org.springframework.security.cas.web.CasAuthenticationEntryPoint&quot;&gt; &lt;beans:property name=&quot;serviceProperties&quot; ref=&quot;serviceProperties&quot;/&gt; &lt;beans:property name=&quot;loginUrl&quot; value=&quot;https://${cas.server}/login&quot;/&gt; &lt;/beans:bean&gt; &lt;beans:bean id=&quot;casFilter&quot; class=&quot;org.springframework.security.cas.web.CasAuthenticationFilter&quot;&gt; &lt;beans:property name=&quot;authenticationManager&quot; ref=&quot;authManager&quot;/&gt; &lt;beans:property name=&quot;serviceProperties&quot; ref=&quot;serviceProperties&quot;/&gt; &lt;beans:property name=&quot;authenticationDetailsSource&quot;&gt; &lt;beans:bean class=&quot;org.springframework.security.cas.web.authentication.ServiceAuthenticationDetailsSource&quot;/&gt; &lt;/beans:property&gt; &lt;beans:property name=&quot;authenticationFailureHandler&quot;&gt; &lt;beans:bean class=&quot;org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler&quot;/&gt; &lt;/beans:property&gt; &lt;/beans:bean&gt; &lt;!-- NOTE: In a real application you should not use an in memory implementation. You will also want to ensure to clean up expired tickets by calling ProxyGrantingTicketStorage.cleanup() --&gt; &lt;beans:bean id=&quot;casAuthProvider&quot; class=&quot;org.springframework.security.cas.authentication.CasAuthenticationProvider&quot;&gt; &lt;beans:property name=&quot;serviceProperties&quot; ref=&quot;serviceProperties&quot;/&gt; &lt;beans:property name=&quot;key&quot; value=&quot;${cas.key}&quot;/&gt; &lt;beans:property name=&quot;authenticationUserDetailsService&quot;&gt; &lt;beans:bean class=&quot;org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper&quot;&gt; &lt;beans:constructor-arg ref=&quot;userService&quot;/&gt; &lt;/beans:bean&gt; &lt;/beans:property&gt; &lt;beans:property name=&quot;ticketValidator&quot;&gt; &lt;beans:bean class=&quot;org.jasig.cas.client.validation.Cas20ProxyTicketValidator&quot;&gt; &lt;beans:constructor-arg value=&quot;https://${cas.server}&quot;/&gt; &lt;/beans:bean&gt; &lt;/beans:property&gt; &lt;/beans:bean&gt; &lt;!-- Configuration for the environment can be overriden by system properties --&gt; &lt;context:property-placeholder system-properties-mode=&quot;OVERRIDE&quot; properties-ref=&quot;environment&quot;/&gt; &lt;util:properties id=&quot;environment&quot;&gt; &lt;beans:prop key=&quot;cas.service&quot;&gt;localhost:8444/user&lt;/beans:prop&gt; &lt;beans:prop key=&quot;cas.server&quot;&gt;localhost:8443/cas&lt;/beans:prop&gt; &lt;beans:prop key=&quot;cas.key&quot;&gt;CAS_KEY_ADMIN.USER&lt;/beans:prop&gt; &lt;/util:properties&gt; &lt;!-- ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑/认证(Authentication)配置↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ --&gt; &lt;/beans:beans&gt;]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 发布到本地仓库]]></title>
    <url>%2Fc1c96e3c.html</url>
    <content type="text"><![CDATA[发布到本地仓库后就可以在项目中使用了。]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 打包成jar]]></title>
    <url>%2F87edb5b6.html</url>
    <content type="text"><![CDATA[&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/plugin&gt;]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webstorm 使用远程git仓]]></title>
    <url>%2Fbeb2f53f.html</url>
    <content type="text"><![CDATA[1.在项目上建立git仓（我是直接将项目地址作为git仓的地址的）： 2.使用Git Bash切换到刚才创建好的git仓中，然后使用下面的命令（如果你是用的Gitblit搭建的远程仓的话，新建好的仓库Gitblit会告诉你使用哪些命令的，在Gitblit的新建的空白仓库的主页面上可以看到） 3.然后刷新项目就可以push/pull了]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat启用远程调试]]></title>
    <url>%2F67a94c98.html</url>
    <content type="text"><![CDATA[使用jpda start的方式启动tomcat即可启用远程调试，可以写一个简单的脚本来控制： export JPDA_ADDRESS=8087 ./catalina.sh jpda start通过JPDA_ADDRESS指定jpda使用的端口，以防默认端口被占用。]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Eclipse的External Tools启动Mongodb]]></title>
    <url>%2F26d76230.html</url>
    <content type="text"><![CDATA[使用Eclipse的External Tools启动Mongodb比用cmd启动要好得多，因为它会将消息输出到Eclipse的控制台中，这样比较方便在开发时查看。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB 新建数据库用户例子]]></title>
    <url>%2F8a50509b.html</url>
    <content type="text"><![CDATA[use admin db.addUser( { user: &quot;&lt;username&gt;&quot;, pwd: &quot;&lt;password&gt;&quot;, roles: [ &quot;userAdminAnyDatabase&quot;, &quot;dbAdminAnyDatabase&quot;, &quot;readWriteAnyDatabase&quot; ] } )]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决局域网连接MySql奇慢无比的问题]]></title>
    <url>%2F2c317dd7.html</url>
    <content type="text"><![CDATA[[mysqld] skip-name-resolve]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改了一个开源的Bootstrap表单验证插件]]></title>
    <url>%2Fce9d724.html</url>
    <content type="text"><![CDATA[jqBootstrapValidation （版本1.3.7）是一个为Bootstrap增加表单验证功能的插件，本来想用在项目中，结果试了一下不管用。看了看源码才明白这个插件是针对Bootstrap2.x开发的，而我用的是Bootstrap3.x，由于插件中是用的硬编码的Bootstrap2.x的class名作为selector的所以肯定不起作用，于是我把里面的几个class名替换成Bootstrap3.x的类名，并且修改了几处逻辑错误后，就可以正常使用了。 主要的改动：1.error 改为 has-error, warning改为has-warning, success改为has-success, .control-group改为 .form-group2.去掉71行的 $form.addClass(“error”); 以及 78行的 $form.removeClass(“error”); 这两处都是逻辑错误3.修改94-99行代码为：（同样是逻辑错误） // create message container if not exists if ($helpBlock.length == 0 &amp;&amp; settings.options.autoAdd &amp;&amp; settings.options.autoAdd.helpBlocks) { $helpBlock = $(&apos;&lt;div class=&quot;help-block&quot; /&gt;&apos;); $controlGroup.append($helpBlock); createdElements.push($helpBlock[0]); }]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让log4j输出IDE友好的日志]]></title>
    <url>%2F1ccf0b4a.html</url>
    <content type="text"><![CDATA[log4j.appender.CONSOLE.layout.ConversionPattern=%l %m%n如上图所示，使用 %l 的方式输出后，eclipse会自动为对应的代码行加上链接，这样鼠标点击就可以跳转到相关的源码中，十分方便。]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Sonatype Nexus搭建Maven镜像的几点注意事项]]></title>
    <url>%2Fb1eaee26.html</url>
    <content type="text"><![CDATA[Maven在现在的Java开发中越来越重要了，我平常的项目基本全部使用Maven来管理依赖了，由于忍受不了Central Repo的速度，所以我使用Sonatype Nexus在单位的服务器上安装了一个Maven镜像，安装和使用过程中总结了几个注意事项，记录一下： Update Index的进度要从Scheduled Tasks中查看。 Sonatype Nexus内置的默认Central Repo的地址是一个过期的旧地址，用那个旧地址Update Index得到的Index少很多东西，比如spring4.x的最新的spring-context-support里面就没有。新的地址是http://repo.maven.apache.org/maven2/（以后也许还会变，留意就行了）。 admin的初始密码是admin123。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关闭ehcache的更新检查]]></title>
    <url>%2F79c7804c.html</url>
    <content type="text"><![CDATA[不知道ehcache玩的什么套路，竟然还做了个更新检查在核心里面，而且还是默认开启的，而且还会爆io异常，还是把它关了吧： &lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot; updateCheck=&quot;false&quot;&gt;updateCheck=”false”]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让slf4j接管commons-logging，并使用log4j实现]]></title>
    <url>%2Fad8d006e.html</url>
    <content type="text"><![CDATA[&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt;]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中使用指定用户运行命令]]></title>
    <url>%2F4549a801.html</url>
    <content type="text"><![CDATA[su username -c &apos;cmd&apos;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring mvc中启用MatrixVariable]]></title>
    <url>%2F2b0fad20.html</url>
    <content type="text"><![CDATA[@MatrixVariable 在Spring MVC中默认是不启用的，启用它需要设置 enable-matrix-variables=”true” &lt;annotation-driven enable-matrix-variables=&quot;true&quot; /&gt;]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决“is marked as crashed and should be repaired”]]></title>
    <url>%2F82484bbc.html</url>
    <content type="text"><![CDATA[由于服务器存储满了导致MySQL启动不起来了，清理了存储空间后再启动MySQL报了个“Table XX is marked as crashed and should be repaired”，看意思应该是表损坏了，搜了一下，解决这个用 myisamchk 就可以了（我的表都是ISAM引擎的）。 具体用法： myisamchk -r /your/table/data/path.MYI]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos上将Gitblit安装为服务]]></title>
    <url>%2Fc0048afd.html</url>
    <content type="text"><![CDATA[单位有些项目需要版本控制，想用Git来管理，习惯了Github这种方式，但是单位的项目放在Github的公共仓也不太合适，所以打算自己搭一个hub。类hub软件不少，我选择的是Gitblit（选择它是因为它是用Java写的）。在安装Gitblit时我大概看了几眼官方网站，没找到安装文档，然后就网搜了一下，另外看了看Gitblit里面的几个shell脚本，大致也明白是怎么回事了，然后就开始安装了。 说一下安装的步骤吧：（我安装的是Gitblit GO 这是一个Single-Stack Solution的版本，Gitblit也有WAR版的和其他的版本） 1.解压Gitblit压缩包到/opt/gitblit ，要想把Gitblit安装成服务，这个目录就是默认的目录，想放到别的目录下安装成服务应该还得改配置(改service-centos.sh文件)，没必要自找麻烦了 2.运行安装目录下的 install-service-centos.sh 脚本，这样就把Gitblit安装成服务了 再说一下基本的使用吧： Gitblit默认提供的是HTTPS协议下的访问，而不提供HTTP的，默认端口从上图可以看出来是 8443，所以只要访问https://yourdomain:8443 就可使用Gitblit了 Gitblit的默认帐号/密码是admin/admin，登录后自己修改密码就可以了，Gitblit的认证与授权信息保存在 Gitblit根目录/data/users.conf文件中]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决了一个cron任务执行后无效果的问题]]></title>
    <url>%2F50b4e0a7.html</url>
    <content type="text"><![CDATA[写了一个shell脚本放到crontab中，结果看了看，cron执行了脚本，但是却没有执行后应有的效果，手工执行这个脚本是正常的，脚本的权限也是755，没有问题，但是就是在任务中执行没有效果，不知道是怎么回事，后来在同事（网管）的帮助下解决了，解决方法很简单，在脚本最前面写上 cd到脚本所在目录就可以了。(后来试了试依旧不行，会出现一些莫名的错误，彻底的解决方法需要导入环境变量，看这篇文章) #定义脚本运行的目录 app_path="/your/app/path" #cd到运行目录(不这样做脚本不会正常执行) cd $app_path]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决手动运行脚本执行正常而放入crontab后不正常的方法]]></title>
    <url>%2F7ad46a54.html</url>
    <content type="text"><![CDATA[解决需要 导入环境变量 有两种导入方法： 在crontab -e编辑时加入 . /etc/profile;/bin/sh #主要&quot;.&quot;后要有个空格 0 12 * * * . /etc/profile;/bin/sh /your/sh/your_sh.sh在你要运行的脚本的开头加入 source /etc/profile]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.htaccess没有生效的解决]]></title>
    <url>%2Fdd32fb1b.html</url>
    <content type="text"><![CDATA[&lt;Directory &quot;/your/app/path&quot;&gt; AllowOverride ALL Order allow,deny Allow from all &lt;/Directory&gt;在apache配置文件中加入以上配置即可。]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zend Server安装后首次运行就出现Internal Server Error的解决]]></title>
    <url>%2Fc88826b2.html</url>
    <content type="text"><![CDATA[刚才安装了Zend Server，安装后首次运行就爆出了一个Internal Server Error，于是看了看日志 \Apache2\logs\error.log 中有这么一行记录： [Sun May 25 22:57:04 2014] [error] Zend Enabler cannot load because of a problem in its configuration file: XML parse error on line 1 column 1 - invalid byte &apos;?&apos; at position 3 of a 3-byte sequence然后找了找Zend Server安装目录，发现 \ZendServer\etc\ 中有个ZendEnablerConf.xml，日志里提到了“Zend Enabler”应该就是它了，打开看了看]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL Workbench不能输入中文的解决]]></title>
    <url>%2F34613f1d.html</url>
    <content type="text"><![CDATA[MySQL Workbench是MySQL官方的GUI工具，功能还是比较强大的，可是在使用时我发现里面不能输入中文，一开始我以为Workbench压根就不支持中文，后来又google了一下，才发现这可能是个Bug，我使用的是google输入法，好像只要使用google输入法就不能在Workbench中输入中文，然后我换了输入法试了试果然可以了。]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下安装jdk7出现unpacking of archive failed on file]]></title>
    <url>%2F7b8d56af.html</url>
    <content type="text"><![CDATA[今天在Linux上安装rpm版的jdk7，结果爆出了 unpacking of archive failed on file /usr/java/jdk1.7.0_55/lib/visualvm/profiler/modules/org-netbeans-modules-profiler.jar;537efea1: cpio: read最后试了一下，虽然没搞明白出现的具体原因，但是好歹也解决了，问题好像出在迅雷上，第一开始我用的迅雷下载的rpm包然后传到服务器上的，就出错了，后来我直接改用浏览器下载了一遍，安装成功了。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Spring Security中启用Group Authorities]]></title>
    <url>%2F5c1a4b42.html</url>
    <content type="text"><![CDATA[我的一个项目需要使用Spring Security的Group Authorities，但是按照默认的配置方式 &lt;authentication-manager&gt; &lt;authentication-provider&gt; &lt;jdbc-user-service data-source-ref=&quot;dataSource&quot;/&gt; &lt;password-encoder hash=&quot;bcrypt&quot; /&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt;Group Authorities并没有生效，所以我看了看配置项 &lt;jdbc-user-service&gt;对应的类 org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl 的源码： {% asset_img bVdn3y.png %} 其中有个“enableGroups”属性，默认值是“false”。好了，这样就明白了，Group Authorities默认是不生效的，看了看在 &lt;jdbc-user-service&gt;这个配置项中并没enableGroups这样的属性，看来只能自己配置jdbc-user-service的bean了，于是我配置好了jdbc-user-service的bean，试了试，果然生效了。 &lt;authentication-manager&gt; &lt;authentication-provider user-service-ref=&quot;jdbcUserDetailsService&quot;&gt; &lt;jdbc-user-service data-source-ref=&quot;dataSource&quot;/&gt; &lt;password-encoder hash=&quot;bcrypt&quot; /&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt; &lt;beans:bean id=&quot;jdbcUserDetailsService&quot; class=&quot;org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl&quot;&gt; &lt;beans:property name=&quot;enableGroups&quot; value=&quot;true&quot; /&gt; &lt;beans:property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot; /&gt; &lt;/beans:bean&gt;log: 2014/05/23 09:52:23:626 CST [DEBUG] DataSourceUtils - Returning JDBC Connection to DataSource 2014/05/23 09:52:23:627 CST [DEBUG] JdbcTemplate - Executing prepared SQL query 2014/05/23 09:52:23:627 CST [DEBUG] JdbcTemplate - Executing prepared SQL statement [select g.id, g.group_name, ga.authority from groups g, group_members gm, group_authorities ga where gm.username = ? and g.id = ga.group_id and g.id = gm.group_id] 2014/05/23 09:52:23:627 CST [DEBUG] DataSourceUtils - Fetching JDBC Connection from DataSource 2014/05/23 09:52:23:627 CST [TRACE] StatementCreatorUtils - Setting SQL statement parameter value: column index 1, parameter value [admin], value class [java.lang.String], SQL type unknown 2014/05/23 09:52:23:628 CST [DEBUG] DataSourceUtils - Returning JDBC Connection to DataSource]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Spring中配置使用commons-logging的simplelog来输出日志]]></title>
    <url>%2F662c0ce1.html</url>
    <content type="text"><![CDATA[烦透了log4j，最新版的包结构变动也不做下兼容，在spring项目中用会爆找不到class，maven仓中的老版又依赖了一大堆Java1.4的东西，实在是不爽，于是果断抛弃，改用commons-logging的simplelog来输出日志。 要在spring中使用simplelog输出日志，需要在classpath中放入两个properties：commons-logging.properties和simplelog.properties commons-logging.properties： org.apache.commons.logging.Log=org.apache.commons.logging.impl.SimpleLogsimplelog.properties： #Set to true if you want the Log instance name to be included in output messages. Defaults to false. org.apache.commons.logging.simplelog.showlogname=true #Set to true if you want the last component of the name to be included in output messages. Defaults to true. #org.apache.commons.logging.simplelog.showShortLogname=false #Set to true if you want the current date and time to be included in output messages. Default is false. org.apache.commons.logging.simplelog.showdatetime=true #The date and time format to be used in the output messages. The pattern describing the date and time format is the same that is used in java.text.SimpleDateFormat. If the format is not specified or is invalid, the default format is used. The default format is yyyy/MM/dd HH:mm:ss:SSS zzz. #org.apache.commons.logging.simplelog.dateTimeFormat=yyyy/MM/dd HH:mm:ss:SSS zzz #Default logging detail level for all instances of SimpleLog. Must be one of: trace debug info warn error fatal If not specified, defaults to info. #org.apache.commons.logging.simplelog.defaultlog=debug ## Configure logging levels org.apache.commons.logging.simplelog.log.org.springframework.jdbc=trace]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The use of filters=none is no longer supported]]></title>
    <url>%2F3b5f29e2.html</url>
    <content type="text"><![CDATA[org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: The use of &quot;filters=&apos;none&apos;&quot; is no longer supported. Please define a separate &lt;http&gt; element for the pattern you want to exclude and use the attribute &quot;security=&apos;none&apos;&quot;.上边是错误信息，按照信息中的提示建立一个独立的（以前的版本是在中）然后在其中定义pattern并且security=”none”就可以了。 &lt;http request-matcher=&quot;regex&quot; pattern=&quot;(/login){1}/?\S*$&quot; security=&quot;none&quot; /&gt;]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp中使用EL获得contextPath]]></title>
    <url>%2F1a703ea8.html</url>
    <content type="text"><![CDATA[${pageContext.request.contextPath}]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写了一个批量下载页面以及页面引用图片的脚本]]></title>
    <url>%2F412fa4b7.html</url>
    <content type="text"><![CDATA[#!/bin/bash # #批量下载页面以及页面引用图片的脚本 # #write by since1986 at 2014-05-12 #页面引用图片的目标下载目录 img_download_destination_folder=&quot;/opt/gbk/inc/wbts&quot; #页面引用图片的下载列表文件 img_download_list_file_path=&quot;/tmp/page_and_img_download.list&quot; #页面引用图片的引用方式的正则 img_regex=&quot;http://\S*(\.jpg|\.gif)&quot; #读取下载任务定义文件 下载任务定义文件使用 每行一段 “要下载的页面链接=下载目标路径” 的形式定义多个下载任务 page_src_url_map=`cat page_urls.map` #循环下载任务定义中的每一项下载任务 for line in $page_src_url_map do page_src_url=`echo $line | cut -d= -f1` #从下载定义中获得要下载页面的源地址 page_desc_path=`echo $line | cut -d= -f2` #从下载定义中获得要下载页面的目标路径 wget $page_src_url -c -O $page_desc_path #使用断点续传的方式下载页面 cat $page_desc_path | egrep -o $img_regex &gt; $img_download_list_file_path #提取下载好的页面中包含的引用图片的链接并保存为下载列表文件 wget -c -P ${img_download_destination_folder}/img/ -i $img_download_list_file_path #依据引用图片下载列表文件下载引用图片 rm -rf $img_download_list_file_path #删除引用图片下载列表文件 done]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux shell 下载某一http页面中引用的jpg和gif文件]]></title>
    <url>%2F9547e223.html</url>
    <content type="text"><![CDATA[主要使用 curl 与 wget 命令： curl -s &quot;your_url&quot; | egrep -o &apos;http://\S*(\.jpg|\.gif)&apos; &gt; download.list #&quot;your_url&quot;shi是包含图片url的页面地址 wget -i download.list]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中使用apache commons-net发送后台邮件的方法]]></title>
    <url>%2F5afc8d59.html</url>
    <content type="text"><![CDATA[上一篇文章中我介绍了使用Javamail-android在android中发送后台邮件的方法，但是，这个Javamail-android并不是一个靠谱的开源组织发布的，而且是修改过的Javaee，总觉得用起来别扭，所以我就一直搜寻一种更靠谱的解决方案。总算功夫不负有心人，看到了这两篇文章：Sending email without user interaction in Android，Sending a mail in Java (and Android) with Apache Commons Net SMTP : STARTTLS, SSL，在这两篇文章中介绍了使用 apache commons-net 来发送邮件的方法。这个就很对路了，apache出品，正规大厂，质量信得过产品，呵呵。 核心代码片段： // 建立发送邮件任务 new AsyncTask&lt;String, Integer, Boolean&gt;() { @Override protected Boolean doInBackground(String... params) { //使用commons-net中的AuthenticatingSMTPClient AuthenticatingSMTPClient client = new AuthenticatingSMTPClient(&quot;TLS&quot;, true); try { client.connect(&quot;smtp.gmail.com&quot;, 465); client.ehlo(&quot;localhost&quot;); //需要ehlo一下 client.sendCommand(&quot;AUTH XOAUTH2 &quot; + Base64.encodeBase64URLSafeString( String.format(&quot;user=%s\1auth=Bearer %s\1\1&quot;, me.name, oauthToken).getBytes()) ); //发送Google的XOAUTH2命令 client.setSender(me.name); //处理多个收件人 String[] recipientsArray = null; if(recipients.toString().contains(&quot;,&quot;)) { recipientsArray = recipients.toString().trim().split(&quot;,&quot;); for( String recipient : recipientsArray ) { client.addRecipient(recipient); } }else { recipientsArray = new String[]{recipients.toString()}; client.addRecipient(recipients.toString()); } //处理邮件主题与正文 Writer writer = client.sendMessageData(); if(null != writer) { //使用apache mime4j中的EncoderUtil来处理中文乱码的问题 String encodedSubject = EncoderUtil.encodeIfNecessary(subject, Usage.TEXT_TOKEN, 0); //使用apache mime4j中的EncoderUtil来编码邮件主题 String encodedBody = EncoderUtil.encodeB(body.getBytes()); //使用apache mime4j中的EncoderUtil来编码邮件正文 Log.i(SMSBroadcastReceiver.class.getName(), &quot;encodedSubject: &quot; + encodedSubject); Log.i(SMSBroadcastReceiver.class.getName(), &quot;encodedBody: &quot; + encodedBody); SimpleSMTPHeader header = new SimpleSMTPHeader(me.name, recipientsArray[0], encodedSubject); header.addHeaderField(&quot;Content-Type&quot;, &quot;text/plain; charset=UTF-8&quot;); header.addHeaderField(&quot;Content-Transfer-Encoding&quot;, &quot;base64&quot;); for (int i = 0; i &lt; recipientsArray.length; i++) { if(0 == i) continue; header.addCC(recipientsArray[i]); } writer.write(header.toString()); writer.write(encodedBody); writer.close(); } return true; } catch (Exception e) { return false; } finally { try { client.disconnect(); } catch (IOException e) { } } } }.execute();]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刚刚学习到的Android使用Javamail通过XOauth调用Gmail API发送邮件的方法]]></title>
    <url>%2Ffc4f8587.html</url>
    <content type="text"><![CDATA[前景知识：OAuth，Javamail-android，Javamail api in android using XOauth 我的一个App项目需要在Service中自动发送邮件的功能，因为是后台自动发送邮件，不能出现邮件UI所以需要使用Javamail来发送，在Android中并未包含Javamail，所以需要第三方lib：Javamail-android；同时由于我的App的邮件发送服务不应保存用户的邮件帐号与密码（因为会有安全问题），所以就必须要用到XOauth的方式（也就是无需存储用户邮件帐号和密码的方式）来调用Gmail API来发送邮件。 关键在于XOauth的AuthToken的获取，在这篇文章中讲的很清楚了，需要使用AccountManager来获取AuthToken，关键代码如下： AccountManager accountManager = AccountManager.get(context); //获得本机第一个google账号 Account me = accountManager.getAccountsByType(&quot;com.google&quot;)[0]; //注意在获得AUTHTOKEN前要invalidateAuthToken一下，否则会得到null的AUTHTOKEN accountManager.invalidateAuthToken(&quot;com.google&quot;, mailProperties.oauthToken); accountManager.getAuthToken(me, &quot;oauth2:https://mail.google.com/&quot;, null, true, new AccountManagerCallback&lt;Bundle&gt;() { @Override public void run(AccountManagerFuture&lt;Bundle&gt; future) { try { //通过回调方法获得AUTHTOKEN mailProperties.oauthToken = future.getResult().getString(AccountManager.KEY_AUTHTOKEN); Log.i(SMSBroadcastReceiver2.class.getName(), mailProperties.oauthToken); } catch (OperationCanceledException e) { e.printStackTrace(); } catch (AuthenticatorException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } }, null);获取到了AuthToken后，剩下的就简单了，按部就班使用Javamail发送邮件就可以了，发送邮件的方法参照：Javamail api in android using XOauth 就可以了。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刚刚学习到的Android有效的彻底退出App的方法，记录一下]]></title>
    <url>%2Fc2861e7f.html</url>
    <content type="text"><![CDATA[最近在写一个包含两个Activity和一个Service的App，这个App需要实现彻底退出的功能，也就是关闭所有Activity并且结束Service。 结束Service的方法比较明确，使用stopService就可以了，关键是想要结束所有Activity就需要费点劲了，一开始我尝试用 .getSystemService(ACTIVITY_SERVICE).killBackgroundProcesses(getPackageName());这样的方法来结束掉所有Activity，但是试了一下，没有效果。然后Google了一下，看到了这篇文章，文章中的方法还是比较简单管用的，然后我又按照自己的需要对这个文章中提供的方法做了一些修改，现在基本上实现了我的App的需求。 这个方法其实很简单，就是在一个单例中维护一个Activity的list，在每个Activity的onCreate中调用这个单例的addActivity()，把当前Activity放到list中，然后想要彻底退出App（也就是finsh所有的Activity），只要调用单例中的finshAllActivities()（finshAllActivities()会遍历这个list，调用list中每一元素的finsh）就可以了。 package since1986.opensmspostman; import java.util.Arrays; import java.util.LinkedList; import android.app.Activity; public class ActivityManager { private LinkedList&lt;Activity&gt; activityLinkedList = new LinkedList&lt;Activity&gt;(); private ActivityManager() { } private static ActivityManager instance; public static ActivityManager getInstance(){ if(null == instance){ instance = new ActivityManager(); } return instance; } //向list中添加Activity public ActivityManager addActivity(Activity activity){ activityLinkedList.add(activity); return instance; } //结束特定的Activity(s) public ActivityManager finshActivities(Class&lt;? extends Activity&gt;... activityClasses){ for (Activity activity : activityLinkedList) { if( Arrays.asList(activityClasses).contains( activity.getClass() ) ){ activity.finish(); } } return instance; } //结束所有的Activities public ActivityManager finshAllActivities() { for (Activity activity : activityLinkedList) { activity.finish(); } return instance; } }]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery.formlocalstorage更新]]></title>
    <url>%2F3a36d2f2.html</url>
    <content type="text"><![CDATA[jquery.formlocalstorage更新： 提供了通过检测服务器端返回的flag从而触发自动清除暂存的功能（原来只能在表单提交时自动清除暂存）。 改用addClass与removeClass的方式加载暂存的样式。 暂存触发事件改成了使用.live()的方式加载。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse可以在选中行中替换内容]]></title>
    <url>%2F657513ae.html</url>
    <content type="text"><![CDATA[很实用的功能。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security结合CAS的配置]]></title>
    <url>%2Fc621863d.html</url>
    <content type="text"><![CDATA[在我的几个项目里需要用到单点登录，我选用了CAS，下面给出一个一般性的Spring Security结合CAS的配置文件 &lt;?xml version="1.0"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:security="http://www.springframework.org/schema/security" xmlns:context="http://www.springframework.org/schema/context" xmlns:util="http://www.springframework.org/schema/util" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/util/spring-util-3.0.xsd"&gt; &lt;!-- Enable security, let the casAuthenticationEntryPoint handle all intercepted urls. The CAS_FILTER needs to be in the right position within the filter chain. --&gt; &lt;security:http auto-config="true" entry-point-ref="casAuthenticationEntryPoint" path-type="regex"&gt; &lt;security:port-mappings&gt; &lt;security:port-mapping http="${portHttp}" https="${portHttps}"/&gt; &lt;/security:port-mappings&gt; &lt;security:logout success-handler-ref="simpleUrlLogoutSuccessHandler" /&gt; &lt;security:intercept-url pattern="/.*" requires-channel="https" /&gt; &lt;security:intercept-url pattern="(/admin/){1}\S*" access="ROLE_ADMIN" /&gt; &lt;security:intercept-url pattern="/{1}\S*" access="ROLE_USER, ROLE_ADMIN" /&gt; &lt;security:intercept-url pattern="(/api/ws/){1}\S*" filters="none" /&gt; &lt;security:custom-filter position="CAS_FILTER" ref="casAuthenticationFilter" /&gt; &lt;/security:http&gt; &lt;!-- 似乎casFilter与casEntryPoint的功能有重叠。其实，casEntryPoint只是提供认证入口的作用，当没有登录，将跳转到该地址。 The entryPoint intercepts all the CAS authentication requests. It redirects to the CAS loginUrl for the CAS login page. --&gt; &lt;bean id="casAuthenticationEntryPoint" class="org.springframework.security.cas.web.CasAuthenticationEntryPoint"&gt; &lt;property name="loginUrl" value="${casAuthenticationEntryPoint.loginUrl}" /&gt; &lt;property name="serviceProperties" ref="serviceProperties" /&gt; &lt;/bean&gt; &lt;!-- 注销的url是/j_spring_security_logout --&gt; &lt;!-- The CAS filter handles the redirect from the CAS server and starts the ticket validation. casFilter是处理CAS service ticket的。 --&gt; &lt;bean id="casAuthenticationFilter" class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt; &lt;property name="authenticationManager" ref="authenticationManager" /&gt; &lt;/bean&gt; &lt;!-- Required for the casProcessingFilter, so define it explicitly set and specify an Id Even though the authenticationManager is created by default when namespace based config is used. --&gt; &lt;security:authentication-manager alias="authenticationManager"&gt; &lt;security:authentication-provider ref="casAuthenticationProvider" /&gt; &lt;/security:authentication-manager&gt; &lt;!-- Handles the CAS ticket processing. --&gt; &lt;bean id="casAuthenticationProvider" class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt; &lt;property name="serviceProperties" ref="serviceProperties" /&gt; &lt;property name="authenticationUserDetailsService" ref="authenticationUserDetailsService" /&gt; &lt;property name="ticketValidator"&gt; &lt;bean class="org.jasig.cas.client.validation.Cas20ServiceTicketValidator"&gt; &lt;constructor-arg index="0" value="${casAuthenticationProvider.casServerUrlPrefix}" /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name="key" value="${casAuthenticationProvider.key}" /&gt; &lt;/bean&gt; &lt;!-- 你需要添加一个 ServiceProperties bean，到你的application context里。 这表现你的CAS服务。 这里的service必须是一个由CasAuthenticationFilter监控的URL。 这个sendRenew默认是false，但如果你的程序特别敏感就应该设置成true。 这个参数作用是，告诉CAS登录服务，一个单点登录没有到达。 否则，用户需要重新输入 他们的用户名和密码，来获得访问服务的权限。 --&gt; &lt;bean id="serviceProperties" class="org.springframework.security.cas.ServiceProperties"&gt; &lt;property name="service" value="${serviceProperties.service}" /&gt; &lt;/bean&gt; &lt;bean id="authenticationUserDetailsService" class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"&gt; &lt;property name="userDetailsService" ref="jdbcUserDetailsService" /&gt; &lt;/bean&gt; &lt;security:jdbc-user-service data-source-ref="ucDataSource" id="jdbcUserDetailsService" authorities-by-username-query="${jdbcUserDetailsService.authoritiesByUsernameQuery}" /&gt; &lt;bean id="simpleUrlLogoutSuccessHandler" class="org.springframework.security.web.authentication.logout.SimpleUrlLogoutSuccessHandler"&gt; &lt;property name="alwaysUseDefaultTargetUrl" value="true" /&gt; &lt;property name="defaultTargetUrl" value="${simpleUrlLogoutSuccessHandler.defaultTargetUrl}" /&gt; &lt;/bean&gt; &lt;/beans&gt; 附加说明： 这里我使用的是数据库保存授权信息的方式，因此使用了jdbc-user-service：（在我的项目里数据库名叫&ldquo;uc&rdquo;，下面给出数据库结构吧） DROP TABLE IF EXISTS `uc`.`users`; CREATE TABLE `uc`.`users` (`username` varchar(32) NOT NULL, `password` varchar(255) NOT NULL DEFAULT &#39;&#39;, `enabled` bit(1) NOT NULL DEFAULT b&#39;1&#39;, PRIMARY KEY (`username`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; DROP TABLE IF EXISTS `uc`.`authorities`; CREATE TABLE `uc`.`authorities` (`username` varchar(32) NOT NULL, `application_context` varchar(32) NOT NULL, `authority` varchar(32) NOT NULL, PRIMARY KEY (`username`,`authority`,`application_context`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; DROP TABLE IF EXISTS `uc`.`persistent_logins`; CREATE TABLE `uc`.`persistent_logins` ( `username` varchar(32) NOT NULL, `series` varchar(255) NOT NULL, `token` varchar(255) NOT NULL, `last_used` datetime NOT NULL, PRIMARY KEY (`series`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; data-source-ref=&quot;ucDataSource&quot;里面的ucDataSource是我项目里Spring Security保存授权信息的数据库的数据源，到时候换成你自己的就行]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在eclipse中手工管理依赖项的一点经验]]></title>
    <url>%2F949a74c2.html</url>
    <content type="text"><![CDATA[我的项目一般使用maven来管理依赖项，可是有些jar在maven的那几个公服上找不到，只好下载好了这些jar然后放到项目里，要是每一个项目都把这些jar放一遍，肯定会造成版本混乱等等的问题，最好是统一管理这些jar。（当然你也可以自己搭个maven私服来管理，但是有时候没这个条件）你可以在eclipse中建立一个单独的项目（比如下图名为“lib”的项目），然后把这些jar分门别类都放在里面，需要用这些jar的项目从这个单独的项目里统一引用这些jar就行了，由于所有项目都引用的一个项目里的jar，这样就能实现这些jar的统一管理了，也就不用担心版本混乱之类的问题了。]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在struts2中把配置文件按模块分开]]></title>
    <url>%2Fedafe376.html</url>
    <content type="text"><![CDATA[在struts2中，你可以把配置文件按模块分开，这样能保持代码简洁，方法是在主struts.xml配置文件中使用来引用外部配置文件。 &lt;!-- 外部配置文件 --&gt; &lt;include file=&quot;struts/customer.xml&quot; /&gt; &lt;include file=&quot;struts/user.xml&quot; /&gt; &lt;include file=&quot;struts/order.xml&quot; /&gt;目录结构：]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql server BCP 工具的使用]]></title>
    <url>%2F47c8ad47.html</url>
    <content type="text"><![CDATA[EXEC master..xp_cmdshell &apos;bcp &lt;database-name&gt; &lt;table-name&gt; in &lt;csv-file&gt; -c -t, -S &lt;server-name&gt; -U &lt;username&gt; -P &lt;password&gt;&apos;其中： EXEC master..xp_cmdshell ： master..xp_cmdshell 是master数据库的存储过程，主要用来在管理器里面执行操作系统的一些命令 in: 代表是 导入 : 你CSV文件的绝对路径 如（H:\1.csv）]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 1067 错误产生的一种原因]]></title>
    <url>%2F503c1e52.html</url>
    <content type="text"><![CDATA[启动MySQL时报了个1067错误，起不起来 于是看了看操作系统日志找到了原因 原来是在MySQL安装目录的mysql文件夹下少了一个名为host.MYD的文件，重装MySQL后自然就解决了。]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASCII码与char的互转]]></title>
    <url>%2F4c688f28.html</url>
    <content type="text"><![CDATA[只要强制类型转换就行 int ascii_a = 97; char a = (char) ascii_a ; System.out.println(a);结果为 a char a = &apos;a&apos;; int ascii = (int)a; System.out.println(ascii);结果为 97]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[notepad2中的正则表达式]]></title>
    <url>%2Fe0adeeb7.html</url>
    <content type="text"><![CDATA[翻了翻注册表，看到了几个notepad2(一个文本编辑器)中的正则式，记下来以备用 IP： ^(?:(?:25[0-5]|2[0-4]\d|[01]\d\d|\d?\d)(?(?=\.?\d)\.)){4}$DATE： ((\d{2}(([02468][048])|([13579][26]))[\-\/\s]?((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|([1-2][0-9])))))|(\d{2}(([02468][1235679])|([13579][01345789]))[\-\/\s]?((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))\s?(((0?[1-9])|(1[0-2]))\:([0-5][0-9])((\s)|(\:([0-5][0-9]))))?\s?(AM|PM|am|pm)?]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写了一个实现表单暂存功能的jquery插件]]></title>
    <url>%2Ff253a876.html</url>
    <content type="text"><![CDATA[jquery.formLocalStorage 是一个实现通用表单暂存功能的jquery插件 原理： 监控表单域变化，并使用HTML5 WebStorage中的localStorage来存储这些有变化的表单域的值，并在从新加载表单时将存储的值载入回表单域中，从而实现暂存功能。 功能特点： 1.不使用服务器端存储，节省服务器资源。 2.代码简练，使用默认配置的话只需一小段代码 $(&quot;#your_form_id&quot;).formLocalStorage(); 即可搞定，无需写一大坨服务器端逻辑。 3.丰富的配置项与默认值，通过配置项可以自定义暂存内容的样式，暂存加载完毕、存储完毕与删除完毕后的回调事件以及暂存的存储命名规则，也可使用默认值从而减少过度的配置工作。 用法： 1.使用默认配置： 1$("#your_form_id").formLocalStorage(); 2.使用自定义配置： 1234$("#your_form_id").formLocalStorage(&#123; storage_name_perfix : 'your_storage_name_perfix', //自定义暂存存储的命名前缀 storage_events : 'click' //自定义暂存触发事件&#125;); 已知的问题： 1.有些动态写入表单项的内容无法监测到，也不能暂存。 2.默认的storage_name_perfix是this.context.URL + form_selector + &quot;@&quot;，在提交后若this.context.URL发生变化则会定位不到暂存，最好使用别的唯一值作为默认storage_name_perfix]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[No subject alternative names present的原因]]></title>
    <url>%2F6fbeaa53.html</url>
    <content type="text"><![CDATA[我的一个项目用到cas所以需要用https，需要生成证书，在服务器上生成证书时我用的ip地址作为dname中的CN值，但是却出现了 “No subject alternative names present”异常，后来google了一下，了解到原因大概是不能用ip，必须用域名，见： http://lovespss.blog.51cto.com/1907593/620487 http://www.coderanch.com/t/523511/sockets/java/Certificate-No-subject-alternative-names 所以搞了个域名重新生成证书，OK了，看来原因就是不能用ip。 另附：keytool使用 生成：./keytool -genkeypair -alias &lt;别名&gt; -dname &quot;CN=&lt;域名&gt;&quot; -keystore &lt;keystore路径&gt; -validity &lt;有效天数&gt; 导出：./keytool -export -alias &lt;别名&gt; -file &lt;导出的证书文件路径&gt; -keystore &lt;keystore路径&gt; 导入：./keytool -import -alias &lt;别名&gt; -file &lt;要导入的证书文件路径&gt; -keystore &lt;keystore路径&gt;]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jfreechart出现sun.awt.X11GraphicsEnvironment异常的解决]]></title>
    <url>%2Fa80c5461.html</url>
    <content type="text"><![CDATA[解决这个需要tomcat启动时加上参数 -Djava.awt.headless=true 在系统(我用的centos6.0)的”/etc/profile.d”下建两个文件： 内容如下: java.sh java.csh]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate 不输出sql参数的解决]]></title>
    <url>%2Fbb09a4bd.html</url>
    <content type="text"><![CDATA[我的一个项目(spring hibernate cxf)使用slf4j + log4j 来输出日志，按说只要配置上 log4j.logger.org.hibernate.type.descriptor.sql.BasicBinder=TRACE 即可实现hibernate中sql参数的输出，可是它死活就是没有输出，后来我仔细查了查，发现原来在classpath中存在着 slf4j-jdk14.jar ，因为我使用maven来管理依赖项，这个jar是cxf-distribution-manifest的依赖，所以会在classpath里，只要在maven中排除这个依赖后，这个jar就不会再跑到classpath里了，这样，就能正常的输出参数了。]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
</search>
